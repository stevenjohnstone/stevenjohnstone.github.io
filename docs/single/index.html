<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Weaponised Autism">
    <meta property="og:type" content="website" />
    <meta property="og:title" content="All Posts" />
    <meta property="og:url" content="/single/" />
    
   <link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon">
<link rel="icon" href="/images/favicon.ico" type="image/x-icon">

    <title>All Posts | rm -rf /</title>
   

<link rel="stylesheet" type="text/css" href="/css/style.css">
<link rel="stylesheet" type="text/css" href="/css/fonts.css">
<link rel="stylesheet" href="/css/syntax/syntax.css" />

    
  </head>

  <body>
    <a class="skip-link" href="#maincontent">Skip to main</a>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about">About</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">All Posts</span></h1>


</div>

<main id="maincontent">

    <h2>2020-19-09
    Reporting Vulnerabilities To Snyk
    </h2>
    <p><a href="https://snyk.io">Snyk</a> is a CNA for Golang packages (and other popular languages). When I learned that they&rsquo;d accept vulnerability reports, I decided to
<a href="https://snyk.io/vulnerability-disclosure/">try them</a> out with a couple of old bugs which I&rsquo;d reported but got no response from the project author.</p>
<p>The turnaround on these issues was very quick (a couple of hours, on a weekend no less) and there are now two CVEs assigned:
<a href="https://snyk.io/vuln/SNYK-GOLANG-GITHUBCOMRUSSELLHAERINGGOXMLDSIG-608301">CVE-2020-7711</a> and <a href="https://snyk.io/vuln/SNYK-GOLANG-GITHUBCOMRUSSELLHAERINGGOSAML2-608302">CVE-2020-7731</a>.</p>


    <h2>2020-08-02
    Four of a Kind
    </h2>
    <p>I stumbled across a blog from a really interesting pioneer of computing, <a href="https://www.software-artist.com/">David S Maynard</a>. <a href="https://www.software-artist.com/joy-of-coding-observable/">This post about a probability puzzle</a> nerd-sniped me. The problem statement is:</p>
<pre><code>Imagine we have a deck of 52 standard playing cards.

First question:  How many cards do we have to draw until we can be sure
that we have four of a kind?  In other words:  What is the minimum
number of cards we must draw until we can be certain that four of those
cards are the same kind?

Second question:  What if we started from a tall stack made of TWO decks
of 52 standard playing cards.  How many cards do we have to draw from
this stack until we can be sure that we have four of a kind, where it's
OK to have two of a kind from the same suit?

Third question:  On average, with a standard deck of cards, how many
cards do we have to draw to get four of a kind?
</code></pre><p>The post goes into details about <a href="https://observablehq.com/@dmaynard/tickler-puzzle-four-of-a-kind">how to use simulation in Observable</a> to solve the third question. A <a href="https://en.wikipedia.org/wiki/Closed-form_expression">closed-form solution</a> isn&rsquo;t given and I thought it looked like a good way to brush away some probability cobwebs.</p>
<h2 id="first-and-second-questions">First and Second Questions</h2>
<p>David S Maynard says the first two questions are easy and he&rsquo;s right. If you draw 40 or more cards from the deck and try to arrange them in 13 &ldquo;buckets&rdquo; by rank, then at least one bucket will have at least four cards. If you draw 39 cards, then the buckets can be filled with three cards each (three-of-a-kinds) without resulting in a four-of-a-kind. Therefore,
to guarantee that you get a four-of-a-kind, draw 40 cards.</p>
<p>Note that the solution is independent of the construction of the deck of cards (so long as it has at least 40 cards). In particular, the solution applies to drawing from a single deck or a double deck.</p>
<h2 id="third-question">Third Question</h2>
<p>Here&rsquo;s my attempt at a closed-form solution. Let&rsquo;s remind ourselves of the probability basics (I need probability formality to keep things sane in my head: probability is counter-intuitive, at least to me).</p>
<p><img src="/images/fourok/prob-space.svg#center" alt="probability space for standard deck of cards"></p>
<p>To model counting the number of draws, I introduce a <a href="https://en.wikipedia.org/wiki/Random_variable">random variable</a> and calculate its <a href="https://en.wikipedia.org/wiki/Expected_value">expectation</a>.</p>
<p><img src="/images/fourok/soln.svg#center" alt="solution"></p>
<p><img src="/images/fourok/symmetry.svg#center" alt="symmetry"></p>
<p><img src="/images/fourok/hypergeometric.svg#center" alt="hypergeometric"></p>
<p>I&rsquo;ll show below that the answer is 68719476736/2748462675 (25.002877921927755).</p>
<h2 id="implementation-in-golang">Implementation in Golang</h2>
<p>The <a href="https://play.golang.org/p/ZeYQwya_VLr">following golang program</a> evaluates the close form solution (exactly as a fraction) and approximates the solution with a Monte Carlo experiment.</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;math&#34;</span>
	<span class="s">&#34;math/big&#34;</span>
	<span class="s">&#34;math/rand&#34;</span>
	<span class="s">&#34;runtime&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">mul</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">&amp;</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">{}).</span><span class="nf">Mul</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">binomial</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span> <span class="kt">int64</span><span class="p">)</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">m</span> <span class="p">&gt;</span> <span class="nx">n</span> <span class="o">||</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">m</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">big</span><span class="p">.</span><span class="nf">NewInt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="nx">m</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">big</span><span class="p">.</span><span class="nf">NewInt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">&amp;</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">{}).</span><span class="nf">Binomial</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">choices</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int64</span><span class="p">)</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">binomial</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">&amp;</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">{}).</span><span class="nf">Add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">fraction</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Rat</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">&amp;</span><span class="nx">big</span><span class="p">.</span><span class="nx">Rat</span><span class="p">{}).</span><span class="nf">SetFrac</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">sign</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int64</span><span class="p">)</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">big</span><span class="p">.</span><span class="nf">NewInt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="nx">i</span><span class="o">%</span><span class="mi">2</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">estimate</span><span class="p">(</span><span class="nx">samples</span><span class="p">,</span> <span class="nx">channels</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>

	<span class="kd">type</span> <span class="nx">card</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">suit</span><span class="p">,</span> <span class="nx">rank</span> <span class="kt">int</span>
	<span class="p">}</span>

	<span class="nx">histogram</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">52</span><span class="p">)</span>

	<span class="nx">draw</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">pack</span> <span class="p">[]</span><span class="nx">card</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="nx">set</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
		<span class="k">for</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">card</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pack</span> <span class="p">{</span>
			<span class="nx">set</span><span class="p">[</span><span class="nx">card</span><span class="p">.</span><span class="nx">rank</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
			<span class="k">if</span> <span class="nx">set</span><span class="p">[</span><span class="nx">card</span><span class="p">.</span><span class="nx">rank</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">n</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pack</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">results</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

	<span class="nx">rand</span><span class="p">.</span><span class="nf">Seed</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">())</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">channels</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">r</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">NewSource</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">+</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">()))</span>
			<span class="nx">pack</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">card</span><span class="p">,</span> <span class="mi">52</span><span class="p">)</span>

			<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pack</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
				<span class="nx">pack</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">card</span><span class="p">{</span>
					<span class="nx">suit</span><span class="p">:</span> <span class="nx">i</span> <span class="o">%</span> <span class="mi">4</span><span class="p">,</span>
					<span class="nx">rank</span><span class="p">:</span> <span class="p">(</span><span class="nx">i</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">%</span> <span class="mi">13</span><span class="p">,</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">samples</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
				<span class="nx">r</span><span class="p">.</span><span class="nf">Shuffle</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">pack</span><span class="p">),</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="nx">pack</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">pack</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pack</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">pack</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">})</span>
				<span class="nx">results</span> <span class="o">&lt;-</span> <span class="nf">draw</span><span class="p">(</span><span class="nx">pack</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">channels</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">samples</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">n</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">results</span>
			<span class="nx">histogram</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">histogram</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="nx">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nx">v</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">sum</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">samples</span><span class="p">)</span> <span class="o">*</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">channels</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">const</span> <span class="p">(</span>
		<span class="nx">maxDraws</span>          <span class="kt">int64</span> <span class="p">=</span> <span class="mi">40</span>
		<span class="nx">samplesPerChannel</span>       <span class="p">=</span> <span class="mi">100000</span>
	<span class="p">)</span>

	<span class="nx">channels</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">NumCPU</span><span class="p">()</span>

	<span class="nx">expectation</span> <span class="o">:=</span> <span class="nx">big</span><span class="p">.</span><span class="nf">NewRat</span><span class="p">(</span><span class="nx">maxDraws</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">maxDraws</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">:=</span> <span class="nx">big</span><span class="p">.</span><span class="nf">NewInt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">m</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="nx">m</span> <span class="o">&lt;=</span> <span class="mi">13</span><span class="p">;</span> <span class="nx">m</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">tmp</span> <span class="o">:=</span> <span class="nf">mul</span><span class="p">(</span><span class="nf">mul</span><span class="p">(</span><span class="nf">sign</span><span class="p">(</span><span class="nx">m</span><span class="p">),</span> <span class="nf">choices</span><span class="p">(</span><span class="nx">m</span><span class="p">)),</span> <span class="nf">binomial</span><span class="p">(</span><span class="mi">52</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="nx">m</span><span class="p">))</span>
			<span class="nx">sum</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">sum</span><span class="p">,</span> <span class="nx">tmp</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">expectation</span><span class="p">.</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">expectation</span><span class="p">,</span> <span class="nf">fraction</span><span class="p">(</span><span class="nx">sum</span><span class="p">,</span> <span class="nf">binomial</span><span class="p">(</span><span class="mi">52</span><span class="p">,</span> <span class="nx">n</span><span class="p">)))</span>
	<span class="p">}</span>

	<span class="nx">expectationFloat</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">expectation</span><span class="p">.</span><span class="nf">Float64</span><span class="p">()</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Expectation = %v (%v)\n&#34;</span><span class="p">,</span> <span class="nx">expectation</span><span class="p">,</span> <span class="nx">expectationFloat</span><span class="p">)</span>
	<span class="nx">approximation</span> <span class="o">:=</span> <span class="nf">estimate</span><span class="p">(</span><span class="nx">samplesPerChannel</span><span class="p">,</span> <span class="nx">channels</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Approximation for %d samples = %v (error = %v)\n&#34;</span><span class="p">,</span> <span class="nx">samplesPerChannel</span><span class="o">*</span><span class="nx">channels</span><span class="p">,</span> <span class="nx">approximation</span><span class="p">,</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Abs</span><span class="p">(</span><span class="nx">expectationFloat</span><span class="o">-</span><span class="nx">approximation</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>An example run:</p>
<pre><code>Expectation = 68719476736/2748462675 (25.002877921927755)
Approximation for 100000 samples = 25.02365 (error = 0.020772078072244682)
</code></pre><p>Some things to note:</p>
<ul>
<li>it&rsquo;s necessary to use big.Rat and big.Int as these numbers will overflow built in types</li>
<li>the inner sum of the expectation calculation runs from 4 to 40 (a minor optimisation) because
<ul>
<li>you can&rsquo;t have a four-of-a-kind with less than four cards</li>
<li><a href="#first-and-second-questions">P(X &lt;= n) = 1 for n &gt;= 40</a></li>
</ul>
</li>
<li>the sum is subtracted from 40 (see <a href="#first-and-second-questions">above for why</a>)</li>
</ul>
<h2 id="wolfram-alpha-is-pretty-amazing">Wolfram Alpha is Pretty Amazing</h2>
<p><img src="/images/fourok/wolfram.png#center" alt="Wolfram Alpha Solution"></p>


    <h2>2020-29-01
    I'm Stevie
    </h2>
    <p>I am/have been</p>
<ul>
<li>a <a href="https://www.gla.ac.uk/research/az/cmals/">mathematician</a></li>
<li>a <a href="https://en.wikipedia.org/wiki/Codian">Codian</a>, <a href="https://en.wikipedia.org/wiki/Tandberg">Tandberg</a>, <a href="https://cisco.com">Cisco</a>, <a href="https://www.acano.com/">Acano</a> and <a href="https://jazznetworks.com">Jazz Networks</a> alum</li>
<li>an automation engineer, embedded systems engineer, security specialist, <a href="https://en.wikipedia.org/wiki/Chief_security_officer">CSO</a>.</li>
</ul>
<p>Apart from brief periods after acquisition, my entire professional life has been in startups. I&rsquo;ve done a wide variety of things to build these companies:</p>
<ul>
<li>automated production line tests</li>
<li>wrote processor bootstrap code for embedded systems</li>
<li>ported operating systems</li>
<li>rolled custom linux distributions</li>
<li>wrote kernel drivers</li>
<li>tinkered with FPGAs</li>
<li>optimised network stacks</li>
<li>tracked down silicon bugs</li>
<li>hunted security flaws</li>
<li>built auth systems</li>
<li>ran <a href="https://www.first.org/education/FIRST_PSIRT_Service_Framework_v1.0">PSIRTs</a></li>
</ul>
<p>I know how to program in</p>
<ul>
<li>Golang</li>
<li>C</li>
<li>C++</li>
<li>x86-64 assembler</li>
<li>Ruby</li>
</ul>
<p>After years of suffering C++ as a systems/platform language, I switched to Golang in 2015 and never looked back.</p>
<p>I know some weird stuff and think some of it is worth recording, if only for me.</p>


    <h2>2020-28-01
    Golang: Panicking Safely
    </h2>
    <p>Golang code can panic, causing availability issues, maybe even a denial of service vector.
Compared to C and C++, it&rsquo;s pretty innocuous. Still, denial of service is a serious issue: why not just use <code>recover</code> in all goroutines
and keep the show on the road?</p>
<h1 id="an-example">An Example</h1>
<p>Consider the following code:</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="c1">// buggy reads data from input 16 bytes at a time, munges it and then writes it to output
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">buggy</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">output</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">in</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">in</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span> <span class="c1">// okay to ignore errors
</span><span class="c1"></span>
    <span class="nx">out</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="nx">output</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">buf</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="kt">byte</span>

    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">ReadFull</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="nx">buf</span><span class="p">[:])</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">_</span> <span class="p">=</span> <span class="nx">out</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
            <span class="k">return</span> <span class="nx">err</span>
        <span class="p">}</span>

        <span class="nf">bufferMunger</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:])</span>

        <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">out</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:]);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">_</span> <span class="p">=</span> <span class="nx">out</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
            <span class="k">return</span> <span class="nx">err</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Avoids a common bug where files which are written to
</span><span class="c1"></span>    <span class="c1">// are closed without checking the error...with async IO
</span><span class="c1"></span>    <span class="c1">// the Close() could result in data actually making it to
</span><span class="c1"></span>    <span class="c1">// disk which can error
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">out</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>Now, suppose that this is called in a program which <em>recovers all panics and keeps rolling on</em>. If <code>bufferMunger</code> panics,
then (at least temporarily), <code>buggy</code> will leak a file descriptor for
<code>out</code>, as explained in an <a href="/posts/file-descriptor-go/">earlier post</a>. With a little imagination, these scenarious can be extended to leaks of</p>
<ul>
<li>database connections</li>
<li>database transactions</li>
<li>customer reservations</li>
</ul>
<p>etc.</p>
<p>It could be argued that it&rsquo;d be better if the program failed hard rather than continuing on in some broken way. Nevertheless, a large chunk of Go code in the wild does keep rolling on
because it <em>runs inside an HTTP handler</em>. It may surprise some that <strong>net/http will recover from panics in HTTP handlers</strong>.</p>
<h1 id="http-handlers">HTTP Handlers</h1>
<p>When writing HTTP handlers, we have a couple of strategies for avoiding strange <em>resource exhaustion</em> bugs caused by
panics:</p>
<ol>
<li>make sure all code is &ldquo;panic safe&rdquo; (can be recovered)</li>
<li>configure http middleware to turn a panic into an exit</li>
</ol>
<h2 id="panic-safety">Panic Safety</h2>
<p>Let&rsquo;s make <code>buggy</code> &ldquo;panic safe&rdquo;. For the sake of argument, suppose that <code>bufferMunger</code> doesn&rsquo;t
leak resources when it panics. If it can, it needs modifications too.</p>
<h3 id="using-defer">Using defer</h3>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="c1">// buggy reads data from input 16 bytes at a time, munges it and then writes it to output
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">buggy</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">output</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">in</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">in</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span> <span class="c1">// okay to ignore errors
</span><span class="c1"></span>

    <span class="nx">out</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="nx">output</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>

<span class="hl">    <span class="nx">outClosed</span> <span class="o">:=</span> <span class="kc">false</span>
</span><span class="hl">    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span><span class="hl">        <span class="k">if</span> <span class="p">!</span><span class="nx">outClosed</span> <span class="p">{</span>
</span><span class="hl">            <span class="nx">_</span> <span class="p">=</span> <span class="nx">out</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span><span class="hl">        <span class="p">}</span>
</span><span class="hl">    <span class="p">}()</span>
</span>
    <span class="kd">var</span> <span class="nx">buf</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="kt">byte</span>

    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">ReadFull</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="nx">buf</span><span class="p">[:])</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">err</span>
        <span class="p">}</span>

        <span class="nf">bufferMunger</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:])</span>

        <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">out</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:]);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">err</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Avoids a common bug where files which are written to
</span><span class="c1"></span>    <span class="c1">// are closed without checking the error...with async IO
</span><span class="c1"></span>    <span class="c1">// the Close() could result in data actually making it to
</span><span class="c1"></span>    <span class="c1">// disk which can error
</span><span class="hl"><span class="c1"></span>    <span class="nx">outClosed</span> <span class="p">=</span> <span class="kc">true</span>
</span>    <span class="k">return</span> <span class="nx">out</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>Here, <code>out</code> will be closed in a defered function. Note how I avoid closing <code>out</code> twice.</p>
<h3 id="using-recover">Using recover</h3>
<p>A simple mechanism would be to wrap bufferMunger so it returns an error rather than causing a panic. For example,</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="nf">bufferMungerWrapper</span><span class="p">(</span><span class="nx">buf</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">r</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="nx">x</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="kt">string</span><span class="p">:</span>
                <span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
            <span class="k">case</span> <span class="kt">error</span><span class="p">:</span>
                <span class="nx">err</span> <span class="p">=</span> <span class="nx">x</span>
            <span class="k">default</span><span class="p">:</span>
                <span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;unknown panic&#34;</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="nf">bufferMunger</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h2 id="middleware">Middleware</h2>
<p>If a quick and obvious failure after a panic is preferred to a potentially hard-to-debug resource exhaustion (hint: it is), then wrapping a handler which causes
the program to exit is a good strategy:</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="nf">NewPanicHandler</span><span class="p">(</span><span class="nx">h</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span><span class="p">)</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">http</span><span class="p">.</span><span class="nf">HandlerFunc</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">r</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="c1">// log.Fatalf causes the program to exit
</span><span class="c1"></span>				<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="nx">debug</span><span class="p">.</span><span class="nf">Stack</span><span class="p">())</span>
			<span class="p">}</span>
		<span class="p">}()</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
	<span class="p">})</span>
<span class="p">}</span>
</code></pre></div><h1 id="conclusion">Conclusion</h1>
<p>Using <code>recover</code> isn&rsquo;t a silver bullet. My 2¢: let panic cause a program exit. Fix logic bugs. Find them with fuzzing.</p>


    <h2>2019-12-01
    xchg rax,rax
    </h2>
    <h1 id="x86-64-kata">x86-64 Kata</h1>
<p>The book <a href="https://www.amazon.co.uk/xchg-rax-xorpd/dp/1502958082">xchg rax,rax</a> (<a href="https://www.xorpd.net/pages/xchg_rax/snip_00.html">content available free here</a>) is
a collection of 0x40 x86-64 snippets. It has no text other
than chunks of assembly language. You read the code and ponder
its meaning. <a href="https://en.wikipedia.org/wiki/Kata">Kata</a> for the budding reverse engineer.</p>
<h1 id="spoiler-alert">Spoiler Alert</h1>
<p>Program 0x03 is pretty neat:</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="nf">sub</span> <span class="no">rdx</span><span class="p">,</span><span class="no">rax</span>
<span class="nf">sbb</span> <span class="no">rcx</span><span class="p">,</span><span class="no">rcx</span>
<span class="nf">and</span> <span class="no">rcx</span><span class="p">,</span><span class="no">rdx</span>
<span class="nf">add</span> <span class="no">rax</span><span class="p">,</span><span class="no">rcx</span>
</code></pre></div><p>Let me spoil this for you: at the end of this program, rax will contain
the smaller of the original rax and rdx values. I know this from reading
it. What if I couldn&rsquo;t work out what this did? What tools could I use?</p>
<h1 id="assemble-it">Assemble It</h1>
<p>We can embed the snippet in a C program and run it for some test cases:</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">x3</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>

    <span class="kt">int</span> <span class="n">out</span><span class="p">;</span>
    <span class="k">asm</span><span class="p">(</span>
        <span class="c1">// it&#39;s not stated in xchg rax,rax but it&#39;s
</span><span class="c1"></span>        <span class="c1">// intel syntax. Note the noprefix means we
</span><span class="c1"></span>        <span class="c1">// don&#39;t need % before registers
</span><span class="c1"></span>        <span class="s">&#34;.intel_syntax noprefix;&#34;</span>
        <span class="c1">// a bit of preamble to get registers
</span><span class="c1"></span>        <span class="c1">// set up correctly. We&#39;re okay with just working
</span><span class="c1"></span>        <span class="c1">// with int rather than long int
</span><span class="c1"></span>        <span class="s">&#34;mov eax, %1;&#34;</span>
        <span class="s">&#34;mov edx, %2;&#34;</span>

        <span class="c1">// 0x03 code below
</span><span class="c1"></span>        <span class="s">&#34;sub rdx, rax;&#34;</span>
        <span class="s">&#34;sbb rcx,rcx;&#34;</span>
        <span class="s">&#34;and rcx,rdx;&#34;</span>
        <span class="s">&#34;add rax,rcx;&#34;</span>

        <span class="c1">// put the result into out
</span><span class="c1"></span>        <span class="s">&#34;mov %0, eax;&#34;</span>
        <span class="c1">// tell the compiler that out is in memory
</span><span class="c1"></span>        <span class="o">:</span> <span class="s">&#34;=m&#34;</span> <span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="c1">// tell the compiler that a and b are inputs
</span><span class="c1"></span>        <span class="o">:</span> <span class="s">&#34;m&#34;</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">,</span> <span class="s">&#34;m&#34;</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="c1">// this is the list of registers which are clobbered
</span><span class="c1"></span>        <span class="o">:</span> <span class="s">&#34;rax&#34;</span><span class="p">,</span><span class="s">&#34;rdx&#34;</span><span class="p">,</span><span class="s">&#34;rcx&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">input</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>


    <span class="k">struct</span> <span class="n">input</span> <span class="n">inputs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">},</span>
        <span class="p">{</span><span class="mh">0x1</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">},</span>
        <span class="p">{</span><span class="mh">0xf</span><span class="p">,</span> <span class="mh">0xe</span><span class="p">},</span>
        <span class="p">{</span><span class="mh">0xe</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">},</span>
        <span class="p">{</span><span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span>
    <span class="p">};</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d (rax: %016x rdx %016x) -&gt;  rax: %016x</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">a</span><span class="p">,</span> <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">b</span><span class="p">,</span> <span class="n">x3</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">a</span><span class="p">,</span> <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">b</span><span class="p">));</span>
    <span class="p">}</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>Compile with</p>
<pre><code>gcc -masm=intel 0x3.c
</code></pre><p>and run to get</p>
<pre><code>0 (rax: 0000000000000000 rdx 0000000000000001) -&gt;  rax: 0000000000000000
1 (rax: 0000000000000001 rdx 0000000000000001) -&gt;  rax: 0000000000000001
2 (rax: 000000000000000f rdx 000000000000000e) -&gt;  rax: 000000000000000e
3 (rax: 000000000000000e rdx 000000000000000f) -&gt;  rax: 000000000000000e
4 (rax: 00000000ffffffff rdx 0000000000000000) -&gt;  rax: 0000000000000000
</code></pre><h1 id="emulation">Emulation</h1>
<p>Suppose that we aren&rsquo;t running on the target system (something without an
x86-64 processor) or we&rsquo;re concerned about the code being malware (when we start
to look at more complex code). Then actually running the code natively isn&rsquo;t an
option.</p>
<p>Emulation allows us to run the code while keeping our tinfoil helmets on. Here&rsquo;s a
program I wrote in Golang which</p>
<ul>
<li>assembles <a href="https://www.xorpd.net/pages/xchg_rax/snip_03.html">0x03</a> into machine code using <a href="http://www.keystone-engine.org/">keystone</a></li>
<li>sets up the <a href="https://www.unicorn-engine.org/">unicorn</a> emulator to run the machine code</li>
<li>passes in a few pairs of register values and prints the value of rax at the end</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>

	<span class="c1">// a branch of keystone golang bindings which builds on linux
</span><span class="c1"></span>	<span class="s">&#34;github.com/stevenjohnstone/keystone/bindings/go/keystone&#34;</span>
	<span class="nx">uc</span> <span class="s">&#34;github.com/unicorn-engine/unicorn/bindings/go/unicorn&#34;</span>
<span class="p">)</span>

<span class="c1">// This program explores a few inputs to
</span><span class="c1">// problem 0x03 of xchg rax,rax:
</span><span class="c1">// https://www.xorpd.net/pages/xchg_rax/snip_03.html
</span><span class="c1">//
</span><span class="c1">// This is a good excuse to give keystone and unicorn
</span><span class="c1">// a spin in golang
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

	<span class="c1">// first, convert the assembly language into numerical opcodes
</span><span class="c1"></span>	<span class="c1">// (machine language)
</span><span class="c1"></span>	<span class="nx">assembly</span> <span class="o">:=</span> <span class="s">&#34;sub rdx,rax; sbb rcx,rcx; and rcx,rdx; add rax,rcx&#34;</span>

	<span class="nx">ks</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">keystone</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">keystone</span><span class="p">.</span><span class="nx">ARCH_X86</span><span class="p">,</span> <span class="nx">keystone</span><span class="p">.</span><span class="nx">MODE_64</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">ks</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="nx">err</span> <span class="p">=</span> <span class="nx">ks</span><span class="p">.</span><span class="nf">Option</span><span class="p">(</span><span class="nx">keystone</span><span class="p">.</span><span class="nx">OPT_SYNTAX</span><span class="p">,</span> <span class="nx">keystone</span><span class="p">.</span><span class="nx">OPT_SYNTAX_INTEL</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">insn</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">ks</span><span class="p">.</span><span class="nf">Assemble</span><span class="p">(</span><span class="nx">assembly</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;failed to assemble&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// choose some initial values for rax and rdx
</span><span class="c1"></span>	<span class="c1">// to get a feel for what the algorithm does
</span><span class="c1"></span>	<span class="nx">regPairs</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">rax</span><span class="p">,</span> <span class="nx">rdx</span> <span class="kt">uint64</span>
	<span class="p">}{</span>
		<span class="p">{</span><span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">},</span>
		<span class="p">{</span><span class="mh">0x1</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">},</span>
		<span class="p">{</span><span class="mh">0xf</span><span class="p">,</span> <span class="mh">0xe</span><span class="p">},</span>
		<span class="p">{</span><span class="mh">0xe</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">},</span>
		<span class="p">{</span><span class="mh">0xffffffff</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span>
	<span class="p">}</span>

	<span class="c1">// try each pair of initial register values with the emulator
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">regPair</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">regPairs</span> <span class="p">{</span>
		<span class="nx">mu</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">uc</span><span class="p">.</span><span class="nf">NewUnicorn</span><span class="p">(</span><span class="nx">uc</span><span class="p">.</span><span class="nx">ARCH_X86</span><span class="p">,</span> <span class="nx">uc</span><span class="p">.</span><span class="nx">MODE_64</span><span class="p">)</span>
		<span class="nx">mu</span><span class="p">.</span><span class="nf">MemMap</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">)</span>
		<span class="nx">mu</span><span class="p">.</span><span class="nf">MemWrite</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">,</span> <span class="nx">insn</span><span class="p">)</span>

		<span class="nx">mu</span><span class="p">.</span><span class="nf">RegWrite</span><span class="p">(</span><span class="nx">uc</span><span class="p">.</span><span class="nx">X86_REG_RAX</span><span class="p">,</span> <span class="nx">regPair</span><span class="p">.</span><span class="nx">rax</span><span class="p">)</span>
		<span class="nx">mu</span><span class="p">.</span><span class="nf">RegWrite</span><span class="p">(</span><span class="nx">uc</span><span class="p">.</span><span class="nx">X86_REG_RDX</span><span class="p">,</span> <span class="nx">regPair</span><span class="p">.</span><span class="nx">rdx</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">mu</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">,</span> <span class="mh">0x1000</span><span class="o">+</span><span class="nb">uint64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">insn</span><span class="p">)));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nx">endRax</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">mu</span><span class="p">.</span><span class="nf">RegRead</span><span class="p">(</span><span class="nx">uc</span><span class="p">.</span><span class="nx">X86_REG_RAX</span><span class="p">)</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d (rax: %016x rdx %016x) -&gt;  rax: %016x\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">regPair</span><span class="p">.</span><span class="nx">rax</span><span class="p">,</span> <span class="nx">regPair</span><span class="p">.</span><span class="nx">rdx</span><span class="p">,</span> <span class="nx">endRax</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>Here&rsquo;s the output (just as above):</p>
<pre><code>0 (rax: 0000000000000000 rdx 0000000000000001) -&gt;  rax: 0000000000000000
1 (rax: 0000000000000001 rdx 0000000000000001) -&gt;  rax: 0000000000000001
2 (rax: 000000000000000f rdx 000000000000000e) -&gt;  rax: 000000000000000e
3 (rax: 000000000000000e rdx 000000000000000f) -&gt;  rax: 000000000000000e
4 (rax: 00000000ffffffff rdx 0000000000000000) -&gt;  rax: 0000000000000000
</code></pre><p>It appears plausible that 0x03 gives the minimum of rax and rdx. However, this is not a proof. Let&rsquo;s take things
further.</p>
<h1 id="z3">Z3</h1>
<p><a href="https://github.com/Z3Prover/z3">Z3</a>: read about it for yourself, I wouldn&rsquo;t do it justice. Suffice it to say,
we can use SMT solvers to prove properties of software.</p>
<p>The plan of attack is:</p>
<ul>
<li>turn the assembly into <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA</a> form</li>
<li>make <em>assertions</em> which model the effects of the instructions in the program</li>
<li>show that an assertion which contradicts our <em>theorem</em> leads to the model being unsatisfiable</li>
</ul>
<p>I&rsquo;ve opted to use <a href="http://smtlib.cs.uiowa.edu/">SMT-LIB</a> to demonstrate.</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">set-logic</span> <span class="nv">QF_BV</span><span class="p">)</span>

<span class="c1">; Convention here is add a label to the end of the register</span>
<span class="c1">; to mark a step in the program for which the value applies.</span>
<span class="c1">; e.g.</span>
<span class="c1">; rdx0 is the first value of rdx, rdx1 is the value at the</span>
<span class="c1">; next step of the program, rdxN is the value at the Nth</span>
<span class="c1">; step.</span>
<span class="c1">;</span>
<span class="c1">; Essentially, we&#39;re turning an assembly program into SSA form</span>
<span class="p">(</span><span class="nv">declare-fun</span> <span class="nv">rdx0</span> <span class="p">()</span> <span class="p">(</span> <span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">64</span><span class="p">))</span>
<span class="p">(</span><span class="nv">declare-fun</span> <span class="nv">rdx1</span> <span class="p">()</span> <span class="p">(</span> <span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">64</span><span class="p">))</span>

<span class="p">(</span><span class="nv">declare-fun</span> <span class="nv">rcx0</span> <span class="p">()</span> <span class="p">(</span> <span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">64</span><span class="p">))</span>
<span class="p">(</span><span class="nv">declare-fun</span> <span class="nv">rcx1</span> <span class="p">()</span> <span class="p">(</span> <span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">64</span><span class="p">))</span>
<span class="p">(</span><span class="nv">declare-fun</span> <span class="nv">rcx2</span> <span class="p">()</span> <span class="p">(</span> <span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">64</span><span class="p">))</span>

<span class="p">(</span><span class="nv">declare-fun</span> <span class="nv">rax0</span> <span class="p">()</span> <span class="p">(</span> <span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">64</span><span class="p">))</span>
<span class="p">(</span><span class="nv">declare-fun</span> <span class="nv">rax3</span> <span class="p">()</span> <span class="p">(</span> <span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">64</span><span class="p">))</span>

<span class="c1">; The carry flag</span>
<span class="p">(</span><span class="nv">declare-fun</span> <span class="nv">cf</span> <span class="p">()</span> <span class="p">(</span><span class="nv">_</span> <span class="nv">Bool</span><span class="p">))</span>

<span class="c1">; sub sets the carry flag if unsigned subtraction will result in</span>
<span class="c1">; an overflow i.e. rax0 &gt; rdx0</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span> <span class="nf">=</span> <span class="nv">cf</span> <span class="p">(</span><span class="nv">bvult</span> <span class="nv">rdx0</span> <span class="nv">rax0</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span> <span class="nf">=</span> <span class="nv">rdx1</span> <span class="p">(</span><span class="nv">bvsub</span> <span class="nv">rdx0</span> <span class="nv">rax0</span><span class="p">)))</span>

<span class="c1">; sbb is &#39;subtract with carry&#39;. If the carry flag is set, we take</span>
<span class="c1">; away one from the result of sub</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span> <span class="nf">=</span> <span class="nv">rcx1</span>
<span class="p">(</span><span class="nv">ite</span> <span class="p">(</span><span class="nf">=</span> <span class="nv">cf</span> <span class="nv">true</span><span class="p">)</span>
 <span class="p">(</span><span class="nv">bvsub</span> <span class="p">(</span><span class="nv">bvsub</span> <span class="nv">rcx0</span> <span class="nv">rcx0</span><span class="p">)</span> <span class="mh">#x0000000000000001</span><span class="p">)</span>
 <span class="p">(</span><span class="nv">bvsub</span> <span class="nv">rcx0</span> <span class="nv">rcx0</span><span class="p">))</span>
<span class="p">))</span>

<span class="c1">; and rxc1,rdx1</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span> <span class="nf">=</span> <span class="nv">rcx2</span> <span class="p">(</span><span class="nv">bvand</span> <span class="nv">rcx1</span> <span class="nv">rdx1</span><span class="p">)))</span>
<span class="c1">; add rax0,rcv2</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span> <span class="nf">=</span> <span class="nv">rax3</span> <span class="p">(</span><span class="nv">bvadd</span> <span class="nv">rax0</span> <span class="nv">rcx2</span><span class="p">)))</span>

<span class="c1">; assert conditions which should fail if this is indeed a minimum</span>
<span class="c1">; function. In the case below, we assert that rax0 &lt;= rdx0 and</span>
<span class="c1">; rax3 != rax0 (which we suspect is false) and so if we get &#39;unsat&#39;</span>
<span class="c1">; as the result, then we&#39;ve proved rax0 &lt;= rdx0 =&gt; rax3 == rax0</span>

<span class="c1">; note the use of push here. Allows us to reuse the work above by</span>
<span class="c1">; popping the asserts below from the stack</span>
<span class="p">(</span><span class="nb">push</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">assert</span> <span class="p">(</span> <span class="nb">or</span> <span class="p">(</span><span class="nv">bvult</span> <span class="nv">rax0</span> <span class="nv">rdx0</span><span class="p">)</span> <span class="p">(</span><span class="nf">not</span> <span class="p">(</span><span class="nv">distinct</span> <span class="nv">rax0</span> <span class="nv">rdx0</span><span class="p">))))</span>
        <span class="p">(</span><span class="nv">check-sat</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">push</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">assert</span> <span class="p">(</span> <span class="nv">distinct</span> <span class="nv">rax3</span> <span class="nv">rax0</span><span class="p">))</span>
            <span class="p">(</span><span class="nv">check-sat</span><span class="p">)</span>
<span class="p">(</span><span class="nb">pop</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1">; We show here that rax0 &gt; rdx0 (along with our previous assertions) can</span>
<span class="c1">; can be satisfied. We then show that adding rax3 != rdx0 leads to</span>
<span class="c1">; unsat, which means that rax3 == rdx0</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nv">bvugt</span> <span class="nv">rax0</span> <span class="nv">rdx0</span><span class="p">))</span>
<span class="p">(</span><span class="nv">check-sat</span><span class="p">)</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span> <span class="nv">distinct</span> <span class="nv">rax3</span> <span class="nv">rdx0</span><span class="p">))</span>

<span class="p">(</span><span class="nv">check-sat</span><span class="p">)</span>
</code></pre></div><p>Running with z3 gives</p>
<pre><code>sat
unsat
sat
unsat
</code></pre><h1 id="why">Why?</h1>
<p>This is surely overkill for such a small problem? Yes. However, as we move to more complex binary executables (e.g. malware)
the ideas touched on here come into their own.</p>


    <h2>2017-13-10
    SO_REUASEADDR and Golang
    </h2>
    <h1 id="a-flaky-test">A Flaky Test</h1>
<p>I was investigating a test which failed with a very low probability. It boiled down to this:</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;net&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//port zero means let the OS choose a free port
</span><span class="c1"></span>	<span class="nx">l</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;127.0.0.1:0&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">addr</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Addr</span><span class="p">().</span><span class="nf">String</span><span class="p">()</span>

	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="nx">c</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Close</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">//listen on the same port as before
</span><span class="c1"></span>	<span class="nx">l</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">addr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>It&rsquo;s pretty standard to stop a goroutine which is blocked in Accept() by calling Close() on the listener. Passes casual inspection, linters don&rsquo;t complain etc. However, if you run the above enough times, you may see something like this:</p>
<pre><code>panic: listen tcp 127.0.0.1:37327: bind: address already in use
</code></pre><p>Address already in use? This caused me some confusion as I know that <a href="http://man7.org/linux/man-pages/man7/socket.7.html">SO_RESUSEADDR</a> is set set by Golang in net.Listen and I&rsquo;ve been conditioned to think &ldquo;SO_RESUSEADDR&rdquo; when I see EALREADY in a situation like this.</p>
<h1 id="root-cause">Root Cause</h1>
<p>The problem here is that Close() of a listener doesn&rsquo;t immediately close the underlying file descriptor. What it <a href="https://golang.org/src/internal/poll/fd_unix.go#L69">does</a> is decrement a reference count and if that reference count is non-zero will exit with a file descriptor still open. Subsequent calls to net.Listen may fail with &ldquo;bind: address already in use&rdquo; because the address really is in use. Not waiting on sockets to leave TIME_WAIT, just <em>open</em>.</p>
<p>The reference count on the underlying file descriptor may be non-zero because a goroutine is still in the guts of <a href="https://golang.org/src/internal/poll/fd_unix.go#L317">Accept()</a> where it has locked the file-descriptor. This explains our intermittent failure: we call Close() and then Listen() but there&rsquo;s a goroutine still in Accept() which has prevented the underlying file-descriptor from being closed.</p>
<h1 id="the-fix">The fix</h1>
<p>&hellip;is to ensure that the goroutine is not in Accept() when we try to listen again on the same port. For example, we can close a channel to signal that the goroutine is done:</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;net&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//port zero means let the OS choose a free port
</span><span class="c1"></span>	<span class="nx">l</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;127.0.0.1:0&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">addr</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Addr</span><span class="p">().</span><span class="nf">String</span><span class="p">()</span>
	<span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>

	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nb">close</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="nx">c</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Close</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">//wait for the goroutine to have left Accept()
</span><span class="c1"></span>	<span class="o">&lt;-</span><span class="nx">done</span>

	<span class="c1">//listen on the same port as before
</span><span class="c1"></span>	<span class="nx">l</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">addr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h1 id="lessons-learned">Lessons Learned</h1>
<ul>
<li>when Close() of a listener returns, the underlying file descriptor may still be open</li>
<li>any method calls for the listener must complete to be sure that the underlying file descriptor is closed</li>
</ul>


    <h2>2017-13-10
    Leaking File Descriptors in Go
    </h2>
    <h1 id="golang-file-descriptors-and-finalizers">Golang, File Descriptors and Finalizers</h1>
<p>If you <a href="https://golang.org/pkg/os/#Open">Open()</a> a file in Golang and it goes out of scope, then it&rsquo;ll be closed the next time the garbage collector runs as there&rsquo;s a  cleanup <em>finalizer</em> set when Open() is called.</p>
<p>You can see this in action in the following program:</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;runtime&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">allocate</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">//use this file as our test subject
</span><span class="c1"></span>	<span class="nx">_</span><span class="p">,</span> <span class="nx">sourceFile</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">Caller</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;source file not found&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">counter</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="kd">var</span> <span class="nx">files</span> <span class="p">[]</span><span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">sourceFile</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;successful opens= %d\n&#34;</span><span class="p">,</span> <span class="nx">counter</span><span class="p">)</span>
			<span class="k">return</span> <span class="nx">counter</span>
		<span class="p">}</span>
		<span class="nx">counter</span><span class="o">++</span>
		<span class="nx">files</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">files</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">allocate</span><span class="p">()</span>
    <span class="nx">runtime</span><span class="p">.</span><span class="nf">GC</span><span class="p">()</span>
    <span class="nf">allocate</span><span class="p">()</span>
<span class="p">}</span>

</code></pre></div><p>On my system, the output is</p>
<pre><code>successful opens = 1020
successful opens = 1020
</code></pre><p>The first time allocate() is called, it manages to open the file 1020 times before returning. The call to <a href="https://golang.org/pkg/runtime/#GC">runtime.GC()</a> causes the garbage collector to run which closes the open files allowing the next allocate() to open the file 1020 times. What happens if we don&rsquo;t call the garbage collector?</p>
<p>We modify main:</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">allocate</span><span class="p">()</span>
    <span class="nf">allocate</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>The result is now:</p>
<pre><code>successful opens = 1020
successful opens = 0
</code></pre><p>The garbage collector hasn&rsquo;t run by the time the second allocate() call happens so the available file descriptors for the process are exhausted. When would the garbage collector run?</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">allocate</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nf">allocate</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;garbage collection ran after %d iterations&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><p>With main as above, it takes ~30k iterations of allocate for the garbage collector to run on my system. This isn&rsquo;t too surprising. Exhaustion of file descriptors will not result in enough memory being used to trigger a garbage collection. The garbage collector is oblivious to the lack of system resources other than memory.</p>
<h1 id="dont-rely-on-the-garbage-collector">Don&rsquo;t Rely on the Garbage Collector</h1>
<p>&hellip;for anything other than collecting memory resources. Tying other resource types to garbage collection is a bad idea and could lead to resource exhaustion. After all, you aren&rsquo;t guaranteed to ever have the garbage collector run for your program. Close files when you&rsquo;re finished with them; defer is your friend.</p>


    <h2>2017-07-10
    CVE-2017-15042
    </h2>
    <h1 id="i-went-looking-for-a-starttlshttpsenwikipediaorgwikiopportunistic_tls-bug">I Went Looking For A <a href="https://en.wikipedia.org/wiki/Opportunistic_TLS">STARTTLS</a> Bug</h1>
<p>I&rsquo;ve been putting together a cryptography course for my colleagues which focuses on <em>mistakes</em>. Its working title is <em>Cryptography Done Wrong</em> which should give you an idea of the tone. There&rsquo;s a wealth of examples of systems assembled from sound cryptographic components which end up with security issues (for some definition of secure).</p>
<p>Over the years, <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS</a> has been an excellent source of examples for such a course. I&rsquo;m not talking about <a href="heartbleed.com">heartbleed</a>, <a href="https://en.wikipedia.org/wiki/CRIME">CRIME</a> and all that; I&rsquo;m talking about mistakes made <em>using TLS</em>.</p>
<p>It&rsquo;s very common for developers with only a passing familiarity with TLS to focus primarily on the encryption of the data stream and neglect how the identity of the remote party is established. When the identity of the other party is not established a <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">man-in-the-middle (MITM)</a> can intercept and modify traffic and the victims will have no idea. Think about how many potential attackers there are: the wifi access point in Starbucks, your ISP, your friendly three-letter-agencies etc. If you haven&rsquo;t already, I suggest reading <a href="http://crypto.stanford.edu/~dabo/pubs/abstracts/ssl-client-bugs.html"><em>The Most Dangerous Code in the World</em></a> to see just how many big names have gotten this very wrong.  If you&rsquo;re a poor soul working with OpenSSL, I suggest taking a look at the <a href="https://github.com/iSECPartners/ssl-conservatory">SSL conservatory project</a> for practical advice.</p>
<p>As if to make things more error prone, some protocols (<a href="https://www.limilabs.com/blog/ssl-vs-tls-vs-starttls-stls">SMTP</a>, <a href="https://tools.ietf.org/html/rfc6120#section-5">XMPP</a>, postgresql) were retrofitted with TLS support using STARTTLS so that the same port could be used for legacy plaintext communication and TLS. Having worked in the field of <a href="https://www.acano.com/"><em>unified communications</em></a> where XMPP was a big deal, I&rsquo;ve seen my fair share of STARTTLS related security vulnerabilities. Could I find some new ones on a rainy Saturday afternoon?</p>
<h1 id="starttls-bugs">STARTTLS bugs</h1>
<p>To STARTTLS, the client and server negotiate in plaintext with a variation on the following:</p>
<p><strong>Client: &ldquo;Hey server, how&rsquo;s it going?&quot;</strong></p>
<p><strong>Server: &ldquo;Not bad, client&rdquo;</strong></p>
<p><strong>Server: &ldquo;Hey client, I support TLS! Do you?&quot;</strong></p>
<p><strong>Client: &ldquo;Yes&rdquo;</strong></p>
<p><strong>Server: &ldquo;Cool! Let&rsquo;s do TLS&rdquo;</strong></p>
<p><strong>Client: &ldquo;Ok&rdquo;</strong></p>
<p>There is no mechanism to establish the identity of either party or the authenticity of the received messages. Therefore, a MITM can modify this conversation so it appears to the client that the server doesn&rsquo;t support TLS e.g. the client see this:</p>
<p><strong>Client: &ldquo;Hey server, how&rsquo;s it going?&quot;</strong></p>
<p><strong>Server: &ldquo;Not bad, client&rdquo;</strong></p>
<p><strong>Server: &ldquo;Hey client, I don&rsquo;t support TLS&rdquo;</strong></p>
<p><strong>Client: &ldquo;Ok&rdquo;</strong></p>
<p>The client will proceed to communicate in plaintext revealing sensitive data, credentials etc.</p>
<p>When using STARTTLS or other <em>opportunistic encryption</em> schemes it&rsquo;s important that the client can specify a policy which says how to behave if TLS is not negotiated. Your web browser will warn you if there&rsquo;s something wrong with the TLS negotiation with a website and may offer you a chance to proceed at your own risk: you&rsquo;d expect no less from an email or chat client.</p>
<h1 id="the-trawl">The Trawl</h1>
<p>I work mostly in golang these days so I decided to focus on opensource golang libraries. I picked SMTP, XMPP and postgres wire protocol as targets for investigation.</p>
<p>I looked at some golang SMTP packages and decided quickly that they all boiled down to <a href="https://golang.org/pkg/net/smtp/">net/smtp</a>.</p>
<p><strong>I wasn&rsquo;t optimistic that I&rsquo;d find any issues and there&rsquo;s probably a lesson there.</strong></p>
<p>The function <a href="https://golang.org/src/net/smtp/smtp.go?s=8958:9036#L296">SendMail</a> was immediately fishy because it has no means to pass in a policy or callback to decide what to do when TLS negotiation fails. A quick read of the code (it&rsquo;s a very easy read like much of golang&rsquo;s standard library) confirmed that the default was to roll on if TLS was not negotiated.</p>
<p>I read the code over and over for about 30 minutes with a vaguely paranoid feeling that I must be wrong. So I parked it and went on the hunt for more bugs and almost immediately found another, though not in something as well-known as golang&rsquo;s standard library. That bug will have to wait for another post. I guess it helps to have a focus for a code review and having many possible targets. Starting off with a single code base looking for <em>any</em> security bug is probably a lot harder than looking for one type of security bug in all public repos on github for a given language.</p>
<h1 id="reporting-process">Reporting Process</h1>
<p>Go has an easy to follow process for reporting security vulnerabilities: <a href="https://golang.org/security">https://golang.org/security</a>. Here&rsquo;s how it worked in practice:</p>
<ul>
<li>I reported the issue at 11:09 AM GMT on Tuesday 3rd October 2017 via email to <a href="mailto:security@golang.org">security@golang.org</a></li>
<li>I received a response at 2:29 AM GMT the following day from Russ Cox (<a href="mailto:rsc@google.com">rsc@google.com</a>) confirming the issue and spelling out the timeline for dealing with the issue.</li>
<li>Over the course of the next 24 hours or so I was informed of the actions which would be taken and given a link to a <a href="https://go-review.googlesource.com/c/go/+/68170">patch</a> <em>so I had a chance to comment</em></li>
<li>1.9.1 and 1.8.4 were released on Oct 4th 2017 addressing the capture of PLAIN credentials</li>
<li>I was asked if I wanted <a href="https://github.com/golang/go/issues/22134">credit</a> and since I&rsquo;m human I said &ldquo;yes, please&rdquo;</li>
</ul>
<p>I was pleasantly surprised by the quick turnaround and the fact that I was kept in the loop. The golang team decided to solve the issues in two stages:</p>
<ol>
<li>in the security point release: disallow PLAIN credentials on non-TLS connections</li>
<li>acknowledge the general weakness in a public issue <a href="https://github.com/golang/go/issues/22145">https://github.com/golang/go/issues/22145</a> and aim to fix in 1.10</li>
</ol>
<p>As someone who has run a PSIRT (Product Security Incident Response Team) I appreciate the professionalism shown here. They are following the important parts of <a href="http://standards.iso.org/ittf/PubliclyAvailableStandards/c045170_ISO_IEC_29147_2014.zip">ISO 29417</a>.</p>
<h1 id="lessons-learned">Lessons Learned</h1>
<ul>
<li>No codebase is above suspicion no matter how nice</li>
<li>Hunting for one type of bug in a large number of projects can yield results quickly</li>
<li>STARTLS is easy to get wrong</li>
<li>golang has a mature security vulnerability reporting mechanism</li>
</ul>



</main>

  <footer>
  
  
  <hr/>
  © Stevie Johnstone 2017-2020 | <a href="https://github.com/stevenjohnstone">Github</a>
  
  </footer>
  </body>
</html>

