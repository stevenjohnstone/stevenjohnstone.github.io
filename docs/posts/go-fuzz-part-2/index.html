<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Weaponised Autism">
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Gofuzz Part 2: Strings" />
    <meta property="og:url" content="/posts/go-fuzz-part-2/" />
    
   <link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon">
<link rel="icon" href="/images/favicon.ico" type="image/x-icon">

    <title>Gofuzz Part 2: Strings | rm -rf /</title>
   

<link rel="stylesheet" type="text/css" href="/css/style.css">
<link rel="stylesheet" type="text/css" href="/css/fonts.css">
<link rel="stylesheet" href="/css/syntax/syntax.css" />

    
  </head>

  <body>
    <a class="skip-link" href="#maincontent">Skip to main</a>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about">About</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Gofuzz Part 2: Strings</span></h1>

<h2 class="date">2021/02/12</h2>
</div>

<main id="maincontent">
<p>In this post, I&rsquo;ll <a href="/posts/go-fuzz-without-the-hyphen">continue</a> going into far too much detail about how <em><a href="https://pkg.go.dev/github.com/google/gofuzz#NewFromGoFuzz">NewFromGoFuzz</a></em> in <a href="https://github.com/google/gofuzz">gofuzz</a>
doesn&rsquo;t play nicely with <a href="https://github.com/dvyukov/go-fuzz">go-fuzz</a> (note the hyphen).</p>
<h2 id="strings">Strings</h2>
<blockquote>
<p>It&rsquo;s important to state right up front that a string holds arbitrary bytes. It is not required to hold Unicode text, UTF-8 text, or any other predefined format. As far as the content of a string is concerned, it is exactly equivalent to a slice of bytes.
<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a></p>
</blockquote>
<p>When fuzzing a function which accepts strings (or objects containing strings),
it&rsquo;s a good idea to try strings which are not well-formed UTF-8.</p>
<p>Strings generated by gofuzz are restricted to well-formed UTF-8 with zero to 19 (inclusive) runes.</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="c1">// randString of UnicodeRange makes a random string up to 20 characters long.
</span><span class="c1">// Each character is selected form ur(UnicodeRange).
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ur</span> <span class="nx">UnicodeRange</span><span class="p">)</span> <span class="nf">randString</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">rand</span><span class="p">.</span><span class="nx">Rand</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="nx">sb</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Builder</span><span class="p">{}</span>
    <span class="nx">sb</span><span class="p">.</span><span class="nf">Grow</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">sb</span><span class="p">.</span><span class="nf">WriteRune</span><span class="p">(</span><span class="nx">ur</span><span class="p">.</span><span class="nf">choose</span><span class="p">(</span><span class="nx">r</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">sb</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p><a href="https://github.com/google/gofuzz/blob/2083bd8c37e7e627ec31e1eea8adcd9ff456fc81/fuzz.go#L550">reference</a></p>
<p>Reading the <em>randString</em> function, we see that there will be the
following reads from the data provided by go-fuzz:</p>
<ul>
<li>r.Intn(20) requires at least eight bytes</li>
<li>ur.choose(r) calls r.Int63n(), which requires eight bytes</li>
</ul>
<p>In total, at least n*8 + 1 bytes will be used of the data from go-fuzz
to construct a string. None of the data will survive as
recognisable fragments.
For example,</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>

    <span class="nx">fuzz</span> <span class="s">&#34;github.com/google/gofuzz&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;-----BEGIN RSA PRIVATE KEY-----&#34;</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">str</span> <span class="kt">string</span>
    <span class="nx">fuzz</span><span class="p">.</span><span class="nf">NewFromGoFuzz</span><span class="p">(</span><span class="nx">data</span><span class="p">).</span><span class="nf">Fuzz</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">str</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;str = %s\n&#34;</span><span class="p">,</span> <span class="nx">str</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>outputs</p>
<pre><code>str = Ȱ#ǻŐ蒉
</code></pre><p>This renders go-fuzz&rsquo;s sonar, literal and versifier functionality
ineffective. When fuzzing a function with go-fuzz, string comparisons are reported back to go-fuzz by
the sonar. Either side of the comparison can be used as a starting
point for new mutational fuzzing. To be useful, the structure
of the string needs to be preserved but gofuzz slices and dices
the string to feed a random number generator, choose a string length and then choose offsets into an array of unicode characters.</p>
<h2 id="experiment">Experiment</h2>
<p>I maintain a <a href="https://github.com/stevenjohnstone/toughfuzzer">repository</a> which demonstrates how go-fuzz can navigate
&ldquo;obstacles&rdquo; in code. Here&rsquo;s an example fuzzer demonstrating how
the sonar can detect string comparisons so as to intelligently
choose fuzzing inputs:</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang">  
<span class="kn">package</span> <span class="nx">sonar</span>

<span class="kd">const</span> <span class="nx">leet</span> <span class="p">=</span> <span class="s">&#34;1337 string abcdefg&#34;</span>

<span class="kd">func</span> <span class="nf">reverse</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">r</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">rune</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
        <span class="nx">r</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">c</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">findString</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">t</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nf">reverse</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;found string&#34;</span><span class="p">)</span>
     <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// FuzzString challenges the fuzzer to find a simple string which is reversed
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">FuzzString</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="c1">// note that if we swap the arguments of findString,
</span><span class="c1"></span>    <span class="c1">// sonar will not help us find a matching string
</span><span class="c1"></span>    <span class="nf">findString</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">data</span><span class="p">),</span> <span class="nx">leet</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div><p>On my laptop, go-fuzz can discover the input &ldquo;gfedcba gnirts 7331&rdquo; in about 6 seconds. Let&rsquo;s see what happens if we build
the string <em>NewFromGoFuzz</em>:</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kn">package</span> <span class="nx">sonar</span>

<span class="kn">import</span> <span class="nx">fuzz</span> <span class="s">&#34;github.com/google/gofuzz&#34;</span>

<span class="kd">const</span> <span class="nx">leet</span> <span class="p">=</span> <span class="s">&#34;1337 string abcdefg&#34;</span>

<span class="kd">func</span> <span class="nf">reverse</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">r</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">rune</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
        <span class="nx">r</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">c</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">findString</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">t</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nf">reverse</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;found string&#34;</span><span class="p">)</span>
     <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// FuzzString challenges the fuzzer to find a simple string which is reversed
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">FuzzString</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">str</span> <span class="kt">string</span>
    <span class="c1">// note that if we swap the arguments of findString,
</span><span class="c1"></span>    <span class="c1">// sonar will not help us find a matching string
</span><span class="c1"></span>    <span class="nx">fuzz</span><span class="p">.</span><span class="nf">NewFromGoFuzz</span><span class="p">(</span><span class="nx">data</span><span class="p">).</span><span class="nf">Fuzz</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">str</span><span class="p">)</span>
    <span class="nf">findString</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="nx">leet</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div><p>After an hour on my laptop, no crashers.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Gofuzz generates strings which are</p>
<ul>
<li>limited in length</li>
<li>well-formed UTF-8</li>
<li>do not resemble inputs</li>
</ul>
<p>It&rsquo;s probably not a good idea to use gofuzz to generate objects
from go-fuzz inputs if those object have string elements.</p>
<blockquote>
<p>Note: I&rsquo;m not saying that gofuzz on its own doesn&rsquo;t work. I&rsquo;m saying that it&rsquo;s not suited to transforming data provided by a mutational fuzzer into objects</p>
</blockquote>

</main>

  <footer>
  
  
  <hr/>
  © Stevie Johnstone 2017-2020 | <a href="https://github.com/stevenjohnstone">Github</a>
  
  </footer>
  </body>
</html>

