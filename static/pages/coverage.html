<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>sourcegraph-fuzz: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">/home/stevie/go/src/github.com/stevenjohnstone/sourcegraph-fuzz/urlfuzz.go (83.3%)</option>
				
				<option value="file1">/usr/local/go/src/fmt/errors.go (75.0%)</option>
				
				<option value="file2">/usr/local/go/src/fmt/format.go (3.8%)</option>
				
				<option value="file3">/usr/local/go/src/fmt/print.go (8.8%)</option>
				
				<option value="file4">/usr/local/go/src/fmt/scan.go (0.2%)</option>
				
				<option value="file5">/usr/local/go/src/internal/poll/sockopt.go (8.3%)</option>
				
				<option value="file6">/usr/local/go/src/math/erf.go (2.1%)</option>
				
				<option value="file7">/usr/local/go/src/math/fma.go (4.1%)</option>
				
				<option value="file8">/usr/local/go/src/math/j1.go (1.0%)</option>
				
				<option value="file9">/usr/local/go/src/math/ldexp.go (5.0%)</option>
				
				<option value="file10">/usr/local/go/src/math/log.go (0.0%)</option>
				
				<option value="file11">/usr/local/go/src/math/remainder.go (0.0%)</option>
				
				<option value="file12">/usr/local/go/src/math/sin.go (0.0%)</option>
				
				<option value="file13">/usr/local/go/src/net/url/url.go (48.0%)</option>
				
				<option value="file14">/usr/local/go/src/os/exec_posix.go (0.0%)</option>
				
				<option value="file15">/usr/local/go/src/os/file_unix.go (1.6%)</option>
				
				<option value="file16">/usr/local/go/src/os/removeall_at.go (2.4%)</option>
				
				<option value="file17">/usr/local/go/src/os/stat_linux.go (0.0%)</option>
				
				<option value="file18">/usr/local/go/src/reflect/type.go (0.7%)</option>
				
				<option value="file19">/usr/local/go/src/reflect/value.go (0.7%)</option>
				
				<option value="file20">/usr/local/go/src/sort/sort.go (1.6%)</option>
				
				<option value="file21">/usr/local/go/src/strconv/atof.go (0.3%)</option>
				
				<option value="file22">/usr/local/go/src/strconv/decimal.go (0.0%)</option>
				
				<option value="file23">/usr/local/go/src/strconv/ftoa.go (0.4%)</option>
				
				<option value="file24">/usr/local/go/src/strconv/itoa.go (5.0%)</option>
				
				<option value="file25">/usr/local/go/src/strconv/quote.go (16.6%)</option>
				
				<option value="file26">/usr/local/go/src/strings/builder.go (52.6%)</option>
				
				<option value="file27">/usr/local/go/src/strings/replace.go (1.6%)</option>
				
				<option value="file28">/usr/local/go/src/strings/strings.go (7.1%)</option>
				
				<option value="file29">/usr/local/go/src/unicode/utf8/utf8.go (12.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package sourcegraph

import (
        "net/url"
        "strings"
)

func SafeRedirectURL(urlStr string) string <span class="cov8" title="1">{
        u, err := url.Parse(urlStr)
        if err != nil || !strings.HasPrefix(u.Path, "/") </span><span class="cov8" title="1">{
                return "/"
        }</span><span class="cov8" title="1">
</span>
        // Only take certain known-safe fields.
        <span class="cov8" title="1">u = &amp;url.URL{Path: u.Path, RawQuery: u.RawQuery}
        return u.String()</span>
}

func Fuzz(input []byte) int <span class="cov8" title="1">{
        s := SafeRedirectURL(string(input))
        u, err := url.Parse(s)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span><span class="cov8" title="1">
</span>
        <span class="cov8" title="1">// if u.Host is </span><span class="cov0" title="0">non-empty then this is definitely not a relative URL
        if u.Host != "</span>" {
                <span class="cov8" title="1">panic(u.Host)
</span>        <span class="cov8" title="1">}
</span>        return 1
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fmt

import "errors"

// Errorf formats according to a format specifier and returns the string as a
// value that satisfies error.
//
// If the format specifier includes a %w verb with an error operand,
// the returned error will implement an Unwrap method returning the operand. It is
// invalid to include more than one %w verb or to supply it with an operand
// that does not implement the error interface. The %w verb is otherwise
// a synonym for %v.
func Errorf(format string, a ...interface{}) error <span class="cov8" title="1">{
        p := newPrinter()
        p.wrapErrs = true
        p.doPrintf(format, a)
        s := string(p.buf)
        var err error
        if p.wrappedErr == nil </span><span class="cov8" title="1">{
                err = errors.New(s)
        }</span><span class="cov0" title="0"> else {
                err = &amp;wrapError{s, p.wrappedErr}
        }</span>
        <span class="cov8" title="1">p.free()
        return err</span>
}

type wrapError struct {
        msg string
        err error
}

func (e *wrapError) Error() string <span class="cov0" title="0">{
        return e.msg
}</span>

func (e *wrapError) Unwrap() error <span class="cov0" title="0">{
        return e.err
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fmt

import (
        "strconv"
        "unicode/utf8"
)

const (
        ldigits = "0123456789abcdefx"
        udigits = "0123456789ABCDEFX"
)

const (
        signed   = true
        unsigned = false
)

// flags placed in a separate struct for easy clearing.
type fmtFlags struct {
        widPresent  bool
        precPresent bool
        minus       bool
        plus        bool
        sharp       bool
        space       bool
        zero        bool

        // For the formats %+v %#v, we set the plusV/sharpV flags
        // and clear the plus/sharp flags since %+v and %#v are in effect
        // different, flagless formats set at the top level.
        plusV  bool
        sharpV bool
}

// A fmt is the raw formatter used by Printf etc.
// It prints into a buffer that must be set up separately.
type fmt struct {
        buf *buffer

        fmtFlags

        wid  int // width
        prec int // precision

        // intbuf is large enough to store %b of an int64 with a sign and
        // avoids padding at the end of the struct on 32 bit architectures.
        intbuf [68]byte
}

func (f *fmt) clearflags() <span class="cov8" title="1">{
        f.fmtFlags = fmtFlags{}
}</span>

func (f *fmt) init(buf *buffer) {
        f.buf = buf
        f.clearflags()
}

// writePadding generates n bytes of padding.
func (f *fmt) writePadding(n int) <span class="cov0" title="0">{
        if n &lt;= 0 </span><span class="cov0" title="0">{ // No padding bytes needed.
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">buf := *f.buf
        oldLen := len(buf)
        newLen := oldLen + n
        // Make enough room for padding.
        if newLen &gt; cap(buf) </span><span class="cov0" title="0">{
                buf = make(buffer, cap(buf)*2+n)
                copy(buf, *f.buf)
        }</span><span class="cov0" title="0">
</span>        // Decide which byte the padding should be filled with.
        <span class="cov0" title="0">padByte := byte(' ')
        if f.zero </span><span class="cov0" title="0">{
                padByte = byte('0')
        }</span><span class="cov0" title="0">
</span>        // Fill padding with padByte.
        <span class="cov0" title="0">padding := buf[oldLen:newLen]
        for i := range padding </span><span class="cov0" title="0">{
                padding[i] = padByte
        }</span>
        <span class="cov0" title="0">*f.buf = buf[:newLen]</span>
}

// pad appends b to f.buf, padded on left (!f.minus) or right (f.minus).
func (f *fmt) pad(b []byte) <span class="cov8" title="1">{
        if !f.widPresent || f.wid == 0 </span><span class="cov8" title="1">{
                f.buf.write(b)
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">width := f.wid - utf8.RuneCount(b)
        if !f.minus </span><span class="cov0" title="0">{
                // left padding
                f.writePadding(width)
                f.buf.write(b)
        }</span><span class="cov0" title="0"> else {
                // right padding
                f.buf.write(b)
                f.writePadding(width)
        }</span>
}

// padString appends s to f.buf, padded on left (!f.minus) or right (f.minus).
func (f *fmt) padString(s string) <span class="cov0" title="0">{
        if !f.widPresent || f.wid == 0 </span><span class="cov0" title="0">{
                f.buf.writeString(s)
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">width := f.wid - utf8.RuneCountInString(s)
        if !f.minus </span><span class="cov0" title="0">{
                // left padding
                f.writePadding(width)
                f.buf.writeString(s)
        }</span><span class="cov0" title="0"> else {
                // right padding
                f.buf.writeString(s)
                f.writePadding(width)
        }</span>
}

// fmtBoolean formats a boolean.
func (f *fmt) fmtBoolean(v bool) <span class="cov0" title="0">{
        if v </span><span class="cov0" title="0">{
                f.padString("true")
        }</span><span class="cov0" title="0"> else {
                f.padString("false")
        }</span>
}

// fmtUnicode formats a uint64 as "U+0078" or with f.sharp set as "U+0078 'x'".
func (f *fmt) fmtUnicode(u uint64) <span class="cov0" title="0">{
        buf := f.intbuf[0:]

        // With default precision set the maximum needed buf length is 18
        // for formatting -1 with %#U ("U+FFFFFFFFFFFFFFFF") which fits
        // into the already allocated intbuf with a capacity of 68 bytes.
        prec := 4
        if f.precPresent &amp;&amp; f.prec &gt; 4 </span><span class="cov0" title="0">{
                prec = f.prec
                // Compute space needed for "U+" , number, " '", character, "'".
                width := 2 + prec + 2 + utf8.UTFMax + 1
                if width &gt; len(buf) </span><span class="cov0" title="0">{
                        buf = make([]byte, width)
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>
        // Format into buf, ending at buf[i]. Formatting numbers is easier right-to-left.
        <span class="cov0" title="0">i := len(buf)

        // For %#U we want to add a space and a quoted character at the end of the buffer.
        if f.sharp &amp;&amp; u &lt;= utf8.MaxRune &amp;&amp; strconv.IsPrint(rune(u)) </span><span class="cov0" title="0">{
                i--
                buf[i] = '\''
                i -= utf8.RuneLen(rune(u))
                utf8.EncodeRune(buf[i:], rune(u))
                i--
                buf[i] = '\''
                i--
                buf[i] = ' '
        }</span><span class="cov0" title="0">
</span>        // Format the Unicode code point u as a hexadecimal number.
        <span class="cov0" title="0">for u &gt;= 16 </span><span class="cov0" title="0">{
                i--
                buf[i] = udigits[u&amp;0xF]
                prec--
                u &gt;&gt;= 4
        }</span>
        <span class="cov0" title="0">i--
        buf[i] = udigits[u]
        prec--
        // Add zeros in front of the number until requested precision is reached.
        for prec &gt; 0 </span><span class="cov0" title="0">{
                i--
                buf[i] = '0'
                prec--
        }</span>
        // Add a leading "U+".
        <span class="cov0" title="0">i--
        buf[i] = '+'
        i--
        buf[i] = 'U'

        oldZero := f.zero
        f.zero = false
        f.pad(buf[i:])
        f.zero = oldZero</span>
}

// fmtInteger formats signed and unsigned integers.
func (f *fmt) fmtInteger(u uint64, base int, isSigned bool, verb rune, digits string) <span class="cov0" title="0">{
        negative := isSigned &amp;&amp; int64(u) &lt; 0
        if negative </span><span class="cov0" title="0">{
                u = -u
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">buf := f.intbuf[0:]
        // The already allocated f.intbuf with a capacity of 68 bytes
        // is large enough for integer formatting when no precision or width is set.
        if f.widPresent || f.precPresent </span><span class="cov0" title="0">{
                // Account 3 extra bytes for possible addition of a sign and "0x".
                width := 3 + f.wid + f.prec // wid and prec are always positive.
                if width &gt; len(buf) </span><span class="cov0" title="0">{
                        // We're going to need a bigger boat.
                        buf = make([]byte, width)
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>
        // Two ways to ask for extra leading zero digits: %.3d or %03d.
        // If both are specified the f.zero flag is ignored and
        // padding with spaces is used instead.
        <span class="cov0" title="0">prec := 0
        if f.precPresent </span><span class="cov0" title="0">{
                prec = f.prec
                // Precision of 0 and value of 0 means "print nothing" but padding.
                if prec == 0 &amp;&amp; u == 0 </span><span class="cov0" title="0">{
                        oldZero := f.zero
                        f.zero = false
                        f.writePadding(f.wid)
                        f.zero = oldZero
                        return
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0"> else if f.zero &amp;&amp; f.widPresent </span><span class="cov0" title="0">{
                prec = f.wid
                if negative || f.plus || f.space </span><span class="cov0" title="0">{
                        prec-- // leave room for sign
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>
        // Because printing is easier right-to-left: format u into buf, ending at buf[i].
        // We could make things marginally faster by splitting the 32-bit case out
        // into a separate block but it's not worth the duplication, so u has 64 bits.
        <span class="cov0" title="0">i := len(buf)
        // Use constants for the division and modulo for more efficient code.
        // Switch cases ordered by popularity.
        switch base </span>{
        <span class="cov0" title="0">case 10:
                for u &gt;= 10 </span><span class="cov0" title="0">{
                        i--
                        next := u / 10
                        buf[i] = byte('0' + u - next*10)
                        u = next
                }</span>
        <span class="cov0" title="0">case 16:
                for u &gt;= 16 </span><span class="cov0" title="0">{
                        i--
                        buf[i] = digits[u&amp;0xF]
                        u &gt;&gt;= 4
                }</span>
        <span class="cov0" title="0">case 8:
                for u &gt;= 8 </span><span class="cov0" title="0">{
                        i--
                        buf[i] = byte('0' + u&amp;7)
                        u &gt;&gt;= 3
                }</span>
        <span class="cov0" title="0">case 2:
                for u &gt;= 2 </span><span class="cov0" title="0">{
                        i--
                        buf[i] = byte('0' + u&amp;1)
                        u &gt;&gt;= 1
                }</span>
        <span class="cov0" title="0">default:
                panic("fmt: unknown base; can't happen")</span>
        }
        <span class="cov0" title="0">i--
        buf[i] = digits[u]
        for i &gt; 0 &amp;&amp; prec &gt; len(buf)-i </span><span class="cov0" title="0">{
                i--
                buf[i] = '0'
        }</span>

        // Various prefixes: 0x, -, etc.
        <span class="cov0" title="0">if f.sharp </span><span class="cov0" title="0">{
                switch base </span>{
                <span class="cov0" title="0">case 2:
                        // Add a leading 0b.
                        i--
                        buf[i] = 'b'
                        i--
                        buf[i] = '0'</span>
                <span class="cov0" title="0">case 8:
                        if buf[i] != '0' </span><span class="cov0" title="0">{
                                i--
                                buf[i] = '0'
                        }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">case 16:
                        // Add a leading 0x or 0X.
                        i--
                        buf[i] = digits[16]
                        i--
                        buf[i] = '0'</span>
                }
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if verb == 'O' </span><span class="cov0" title="0">{
                i--
                buf[i] = 'o'
                i--
                buf[i] = '0'
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if negative </span><span class="cov0" title="0">{
                i--
                buf[i] = '-'
        }</span><span class="cov0" title="0"> else if f.plus </span><span class="cov0" title="0">{
                i--
                buf[i] = '+'
        }</span><span class="cov0" title="0"> else if f.space </span><span class="cov0" title="0">{
                i--
                buf[i] = ' '
        }</span><span class="cov0" title="0">
</span>
        // Left padding with zeros has already been handled like precision earlier
        // or the f.zero flag is ignored due to an explicitly set precision.
        <span class="cov0" title="0">oldZero := f.zero
        f.zero = false
        f.pad(buf[i:])
        f.zero = oldZero</span>
}

// truncate truncates the string s to the specified precision, if present.
func (f *fmt) truncateString(s string) string <span class="cov8" title="1">{
        if f.precPresent </span><span class="cov0" title="0">{
                n := f.prec
                for i := range s </span><span class="cov0" title="0">{
                        n--
                        if n &lt; 0 </span><span class="cov0" title="0">{
                                return s[:i]
                        }</span><span class="cov0" title="0">
</span>                }
        }<span class="cov8" title="1">
</span>        <span class="cov8" title="1">return s</span>
}

// truncate truncates the byte slice b as a string of the specified precision, if present.
func (f *fmt) truncate(b []byte) []byte <span class="cov0" title="0">{
        if f.precPresent </span><span class="cov0" title="0">{
                n := f.prec
                for i := 0; i &lt; len(b); </span><span class="cov0" title="0">{
                        n--
                        if n &lt; 0 </span><span class="cov0" title="0">{
                                return b[:i]
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">wid := 1
                        if b[i] &gt;= utf8.RuneSelf </span><span class="cov0" title="0">{
                                _, wid = utf8.DecodeRune(b[i:])
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">i += wid</span>
                }
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">return b</span>
}

// fmtS formats a string.
func (f *fmt) fmtS(s string) <span class="cov0" title="0">{
        s = f.truncateString(s)
        f.padString(s)
}</span>

// fmtBs formats the byte slice b as if it was formatted as string with fmtS.
func (f *fmt) fmtBs(b []byte) <span class="cov0" title="0">{
        b = f.truncate(b)
        f.pad(b)
}</span>

// fmtSbx formats a string or byte slice as a hexadecimal encoding of its bytes.
func (f *fmt) fmtSbx(s string, b []byte, digits string) <span class="cov0" title="0">{
        length := len(b)
        if b == nil </span><span class="cov0" title="0">{
                // No byte slice present. Assume string s should be encoded.
                length = len(s)
        }</span><span class="cov0" title="0">
</span>        // Set length to not process more bytes than the precision demands.
        <span class="cov0" title="0">if f.precPresent &amp;&amp; f.prec &lt; length </span><span class="cov0" title="0">{
                length = f.prec
        }</span><span class="cov0" title="0">
</span>        // Compute width of the encoding taking into account the f.sharp and f.space flag.
        <span class="cov0" title="0">width := 2 * length
        if width &gt; 0 </span><span class="cov0" title="0">{
                if f.space </span><span class="cov0" title="0">{
                        // Each element encoded by two hexadecimals will get a leading 0x or 0X.
                        if f.sharp </span><span class="cov0" title="0">{
                                width *= 2
                        }</span><span class="cov0" title="0">
</span>                        // Elements will be separated by a space.
                        <span class="cov0" title="0">width += length - 1</span>
                }<span class="cov0" title="0"> else if f.sharp </span><span class="cov0" title="0">{
                        // Only a leading 0x or 0X will be added for the whole string.
                        width += 2
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0"> else { // The byte slice or string that should be encoded is empty.
                if f.widPresent </span><span class="cov0" title="0">{
                        f.writePadding(f.wid)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return</span>
        }
        // Handle padding to the left.
        <span class="cov0" title="0">if f.widPresent &amp;&amp; f.wid &gt; width &amp;&amp; !f.minus </span><span class="cov0" title="0">{
                f.writePadding(f.wid - width)
        }</span><span class="cov0" title="0">
</span>        // Write the encoding directly into the output buffer.
        <span class="cov0" title="0">buf := *f.buf
        if f.sharp </span><span class="cov0" title="0">{
                // Add leading 0x or 0X.
                buf = append(buf, '0', digits[16])
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">var c byte
        for i := 0; i &lt; length; i++ </span><span class="cov0" title="0">{
                if f.space &amp;&amp; i &gt; 0 </span><span class="cov0" title="0">{
                        // Separate elements with a space.
                        buf = append(buf, ' ')
                        if f.sharp </span><span class="cov0" title="0">{
                                // Add leading 0x or 0X for each element.
                                buf = append(buf, '0', digits[16])
                        }</span><span class="cov0" title="0">
</span>                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">if b != nil </span><span class="cov0" title="0">{
                        c = b[i] // Take a byte from the input byte slice.
                }</span><span class="cov0" title="0"> else {
                        c = s[i] // Take a byte from the input string.
                }</span>
                // Encode each byte as two hexadecimal digits.
                <span class="cov0" title="0">buf = append(buf, digits[c&gt;&gt;4], digits[c&amp;0xF])</span>
        }
        <span class="cov0" title="0">*f.buf = buf
        // Handle padding to the right.
        if f.widPresent &amp;&amp; f.wid &gt; width &amp;&amp; f.minus </span><span class="cov0" title="0">{
                f.writePadding(f.wid - width)
        }</span><span class="cov0" title="0">
</span>}

// fmtSx formats a string as a hexadecimal encoding of its bytes.
func (f *fmt) fmtSx(s, digits string) <span class="cov0" title="0">{
        f.fmtSbx(s, nil, digits)
}</span>

// fmtBx formats a byte slice as a hexadecimal encoding of its bytes.
func (f *fmt) fmtBx(b []byte, digits string) <span class="cov0" title="0">{
        f.fmtSbx("", b, digits)
}</span>

// fmtQ formats a string as a double-quoted, escaped Go string constant.
// If f.sharp is set a raw (backquoted) string may be returned instead
// if the string does not contain any control characters other than tab.
func (f *fmt) fmtQ(s string) <span class="cov8" title="1">{
        s = f.truncateString(s)
        if f.sharp &amp;&amp; strconv.CanBackquote(s) </span><span class="cov0" title="0">{
                f.padString("`" + s + "`")
                return
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">buf := f.intbuf[:0]
        if f.plus </span><span class="cov0" title="0">{
                f.pad(strconv.AppendQuoteToASCII(buf, s))
        }</span><span class="cov8" title="1"> else {
                f.pad(strconv.AppendQuote(buf, s))
        }</span>
}

// fmtC formats an integer as a Unicode character.
// If the character is not valid Unicode, it will print '\ufffd'.
func (f *fmt) fmtC(c uint64) <span class="cov0" title="0">{
        r := rune(c)
        if c &gt; utf8.MaxRune </span><span class="cov0" title="0">{
                r = utf8.RuneError
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">buf := f.intbuf[:0]
        w := utf8.EncodeRune(buf[:utf8.UTFMax], r)
        f.pad(buf[:w])</span>
}

// fmtQc formats an integer as a single-quoted, escaped Go character constant.
// If the character is not valid Unicode, it will print '\ufffd'.
func (f *fmt) fmtQc(c uint64) <span class="cov0" title="0">{
        r := rune(c)
        if c &gt; utf8.MaxRune </span><span class="cov0" title="0">{
                r = utf8.RuneError
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">buf := f.intbuf[:0]
        if f.plus </span><span class="cov0" title="0">{
                f.pad(strconv.AppendQuoteRuneToASCII(buf, r))
        }</span><span class="cov0" title="0"> else {
                f.pad(strconv.AppendQuoteRune(buf, r))
        }</span>
}

// fmtFloat formats a float64. It assumes that verb is a valid format specifier
// for strconv.AppendFloat and therefore fits into a byte.
func (f *fmt) fmtFloat(v float64, size int, verb rune, prec int) <span class="cov0" title="0">{
        // Explicit precision in format specifier overrules default precision.
        if f.precPresent </span><span class="cov0" title="0">{
                prec = f.prec
        }</span><span class="cov0" title="0">
</span>        // Format number, reserving space for leading + sign if needed.
        <span class="cov0" title="0">num := strconv.AppendFloat(f.intbuf[:1], v, byte(verb), prec, size)
        if num[1] == '-' || num[1] == '+' </span><span class="cov0" title="0">{
                num = num[1:]
        }</span><span class="cov0" title="0"> else {
                num[0] = '+'
        }</span>
        // f.space means to add a leading space instead of a "+" sign unless
        // the sign is explicitly asked for by f.plus.
        <span class="cov0" title="0">if f.space &amp;&amp; num[0] == '+' &amp;&amp; !f.plus </span><span class="cov0" title="0">{
                num[0] = ' '
        }</span><span class="cov0" title="0">
</span>        // Special handling for infinities and NaN,
        // which don't look like a number so shouldn't be padded with zeros.
        <span class="cov0" title="0">if num[1] == 'I' || num[1] == 'N' </span><span class="cov0" title="0">{
                oldZero := f.zero
                f.zero = false
                // Remove sign before NaN if not asked for.
                if num[1] == 'N' &amp;&amp; !f.space &amp;&amp; !f.plus </span><span class="cov0" title="0">{
                        num = num[1:]
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">f.pad(num)
                f.zero = oldZero
                return</span>
        }<span class="cov0" title="0">
</span>        // The sharp flag forces printing a decimal point for non-binary formats
        // and retains trailing zeros, which we may need to restore.
        <span class="cov0" title="0">if f.sharp &amp;&amp; verb != 'b' </span><span class="cov0" title="0">{
                digits := 0
                switch verb </span>{
                <span class="cov0" title="0">case 'v', 'g', 'G', 'x':
                        digits = prec
                        // If no precision is set explicitly use a precision of 6.
                        if digits == -1 </span><span class="cov0" title="0">{
                                digits = 6
                        }</span><span class="cov0" title="0">
</span>                }

                // Buffer pre-allocated with enough room for
                // exponent notations of the form "e+123" or "p-1023".
                <span class="cov0" title="0">var tailBuf [6]byte
                tail := tailBuf[:0]

                hasDecimalPoint := false
                sawNonzeroDigit := false
                // Starting from i = 1 to skip sign at num[0].
                for i := 1; i &lt; len(num); i++ </span><span class="cov0" title="0">{
                        switch num[i] </span>{
                        <span class="cov0" title="0">case '.':
                                hasDecimalPoint = true</span>
                        <span class="cov0" title="0">case 'p', 'P':
                                tail = append(tail, num[i:]...)
                                num = num[:i]</span>
                        <span class="cov0" title="0">case 'e', 'E':
                                if verb != 'x' &amp;&amp; verb != 'X' </span><span class="cov0" title="0">{
                                        tail = append(tail, num[i:]...)
                                        num = num[:i]
                                        break</span>
                                }<span class="cov0" title="0">
</span>                                <span class="cov0" title="0">fallthrough</span>
                        <span class="cov0" title="0">default:
                                if num[i] != '0' </span><span class="cov0" title="0">{
                                        sawNonzeroDigit = true
                                }</span><span class="cov0" title="0">
</span>                                // Count significant digits after the first non-zero digit.
                                <span class="cov0" title="0">if sawNonzeroDigit </span><span class="cov0" title="0">{
                                        digits--
                                }</span><span class="cov0" title="0">
</span>                        }
                }
                <span class="cov0" title="0">if !hasDecimalPoint </span><span class="cov0" title="0">{
                        // Leading digit 0 should contribute once to digits.
                        if len(num) == 2 &amp;&amp; num[1] == '0' </span><span class="cov0" title="0">{
                                digits--
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">num = append(num, '.')</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">for digits &gt; 0 </span><span class="cov0" title="0">{
                        num = append(num, '0')
                        digits--
                }</span>
                <span class="cov0" title="0">num = append(num, tail...)</span>
        }<span class="cov0" title="0">
</span>        // We want a sign if asked for and if the sign is not positive.
        <span class="cov0" title="0">if f.plus || num[0] != '+' </span><span class="cov0" title="0">{
                // If we're zero padding to the left we want the sign before the leading zeros.
                // Achieve this by writing the sign out and then padding the unsigned number.
                if f.zero &amp;&amp; f.widPresent &amp;&amp; f.wid &gt; len(num) </span><span class="cov0" title="0">{
                        f.buf.writeByte(num[0])
                        f.writePadding(f.wid - len(num))
                        f.buf.write(num[1:])
                        return
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">f.pad(num)
                return</span>
        }<span class="cov0" title="0">
</span>        // No sign to show and the number is positive; just print the unsigned number.
        <span class="cov0" title="0">f.pad(num[1:])</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fmt

import (
        "internal/fmtsort"
        "io"
        "os"
        "reflect"
        "sync"
        "unicode/utf8"
)

// Strings for use with buffer.WriteString.
// This is less overhead than using buffer.Write with byte arrays.
const (
        commaSpaceString  = ", "
        nilAngleString    = "&lt;nil&gt;"
        nilParenString    = "(nil)"
        nilString         = "nil"
        mapString         = "map["
        percentBangString = "%!"
        missingString     = "(MISSING)"
        badIndexString    = "(BADINDEX)"
        panicString       = "(PANIC="
        extraString       = "%!(EXTRA "
        badWidthString    = "%!(BADWIDTH)"
        badPrecString     = "%!(BADPREC)"
        noVerbString      = "%!(NOVERB)"
        invReflectString  = "&lt;invalid reflect.Value&gt;"
)

// State represents the printer state passed to custom formatters.
// It provides access to the io.Writer interface plus information about
// the flags and options for the operand's format specifier.
type State interface {
        // Write is the function to call to emit formatted output to be printed.
        Write(b []byte) (n int, err error)
        // Width returns the value of the width option and whether it has been set.
        Width() (wid int, ok bool)
        // Precision returns the value of the precision option and whether it has been set.
        Precision() (prec int, ok bool)

        // Flag reports whether the flag c, a character, has been set.
        Flag(c int) bool
}

// Formatter is the interface implemented by values with a custom formatter.
// The implementation of Format may call Sprint(f) or Fprint(f) etc.
// to generate its output.
type Formatter interface {
        Format(f State, c rune)
}

// Stringer is implemented by any value that has a String method,
// which defines the ``native'' format for that value.
// The String method is used to print values passed as an operand
// to any format that accepts a string or to an unformatted printer
// such as Print.
type Stringer interface {
        String() string
}

// GoStringer is implemented by any value that has a GoString method,
// which defines the Go syntax for that value.
// The GoString method is used to print values passed as an operand
// to a %#v format.
type GoStringer interface {
        GoString() string
}

// Use simple []byte instead of bytes.Buffer to avoid large dependency.
type buffer []byte

func (b *buffer) write(p []byte) <span class="cov8" title="1">{
        *b = append(*b, p...)
}</span>

func (b *buffer) writeString(s string) <span class="cov8" title="1">{
        *b = append(*b, s...)
}</span>

func (b *buffer) writeByte(c byte) <span class="cov0" title="0">{
        *b = append(*b, c)
}</span>

func (bp *buffer) writeRune(r rune) <span class="cov0" title="0">{
        if r &lt; utf8.RuneSelf </span><span class="cov0" title="0">{
                *bp = append(*bp, byte(r))
                return
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">b := *bp
        n := len(b)
        for n+utf8.UTFMax &gt; cap(b) </span><span class="cov0" title="0">{
                b = append(b, 0)
        }</span>
        <span class="cov0" title="0">w := utf8.EncodeRune(b[n:n+utf8.UTFMax], r)
        *bp = b[:n+w]</span>
}

// pp is used to store a printer's state and is reused with sync.Pool to avoid allocations.
type pp struct {
        buf buffer

        // arg holds the current item, as an interface{}.
        arg interface{}

        // value is used instead of arg for reflect values.
        value reflect.Value

        // fmt is used to format basic items such as integers or strings.
        fmt fmt

        // reordered records whether the format string used argument reordering.
        reordered bool
        // goodArgNum records whether the most recent reordering directive was valid.
        goodArgNum bool
        // panicking is set by catchPanic to avoid infinite panic, recover, panic, ... recursion.
        panicking bool
        // erroring is set when printing an error string to guard against calling handleMethods.
        erroring bool
        // wrapErrs is set when the format string may contain a %w verb.
        wrapErrs bool
        // wrappedErr records the target of the %w verb.
        wrappedErr error
}

var ppFree = sync.Pool{
        New: func() interface{} <span class="cov0" title="0">{ return new(pp) }</span>,
}

// newPrinter allocates a new pp struct or grabs a cached one.
func newPrinter() *pp <span class="cov8" title="1">{
        p := ppFree.Get().(*pp)
        p.panicking = false
        p.erroring = false
        p.wrapErrs = false
        p.fmt.init(&amp;p.buf)
        return p
}</span>

// free saves used pp structs in ppFree; avoids an allocation per invocation.
func (p *pp) free() <span class="cov8" title="1">{
        // Proper usage of a sync.Pool requires each entry to have approximately
        // the same memory cost. To obtain this property when the stored type
        // contains a variably-sized buffer, we add a hard limit on the maximum buffer
        // to place back in the pool.
        //
        // See https://golang.org/issue/23199
        if cap(p.buf) &gt; 64&lt;&lt;10 </span><span class="cov0" title="0">{
                return
        }</span><span class="cov8" title="1">
</span>
        <span class="cov8" title="1">p.buf = p.buf[:0]
        p.arg = nil
        p.value = reflect.Value{}
        p.wrappedErr = nil
        ppFree.Put(p)</span>
}

func (p *pp) Width() (wid int, ok bool) <span class="cov0" title="0">{ return p.fmt.wid, p.fmt.widPresent }</span>

func (p *pp) Precision() (prec int, ok bool) <span class="cov0" title="0">{ return p.fmt.prec, p.fmt.precPresent }</span>

func (p *pp) Flag(b int) bool <span class="cov0" title="0">{
        switch b </span>{
        <span class="cov0" title="0">case '-':
                return p.fmt.minus</span>
        <span class="cov0" title="0">case '+':
                return p.fmt.plus || p.fmt.plusV</span>
        <span class="cov0" title="0">case '#':
                return p.fmt.sharp || p.fmt.sharpV</span>
        <span class="cov0" title="0">case ' ':
                return p.fmt.space</span>
        <span class="cov0" title="0">case '0':
                return p.fmt.zero</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Implement Write so we can call Fprintf on a pp (through State), for
// recursive use in custom verbs.
func (p *pp) Write(b []byte) (ret int, err error) <span class="cov0" title="0">{
        p.buf.write(b)
        return len(b), nil
}</span>

// Implement WriteString so that we can call io.WriteString
// on a pp (through state), for efficiency.
func (p *pp) WriteString(s string) (ret int, err error) <span class="cov0" title="0">{
        p.buf.writeString(s)
        return len(s), nil
}</span>

// These routines end in 'f' and take a format string.

// Fprintf formats according to a format specifier and writes to w.
// It returns the number of bytes written and any write error encountered.
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) <span class="cov0" title="0">{
        p := newPrinter()
        p.doPrintf(format, a)
        n, err = w.Write(p.buf)
        p.free()
        return
}</span>

// Printf formats according to a format specifier and writes to standard output.
// It returns the number of bytes written and any write error encountered.
func Printf(format string, a ...interface{}) (n int, err error) <span class="cov0" title="0">{
        return Fprintf(os.Stdout, format, a...)
}</span>

// Sprintf formats according to a format specifier and returns the resulting string.
func Sprintf(format string, a ...interface{}) string <span class="cov0" title="0">{
        p := newPrinter()
        p.doPrintf(format, a)
        s := string(p.buf)
        p.free()
        return s
}</span>

// These routines do not take a format string

// Fprint formats using the default formats for its operands and writes to w.
// Spaces are added between operands when neither is a string.
// It returns the number of bytes written and any write error encountered.
func Fprint(w io.Writer, a ...interface{}) (n int, err error) <span class="cov0" title="0">{
        p := newPrinter()
        p.doPrint(a)
        n, err = w.Write(p.buf)
        p.free()
        return
}</span>

// Print formats using the default formats for its operands and writes to standard output.
// Spaces are added between operands when neither is a string.
// It returns the number of bytes written and any write error encountered.
func Print(a ...interface{}) (n int, err error) <span class="cov0" title="0">{
        return Fprint(os.Stdout, a...)
}</span>

// Sprint formats using the default formats for its operands and returns the resulting string.
// Spaces are added between operands when neither is a string.
func Sprint(a ...interface{}) string <span class="cov0" title="0">{
        p := newPrinter()
        p.doPrint(a)
        s := string(p.buf)
        p.free()
        return s
}</span>

// These routines end in 'ln', do not take a format string,
// always add spaces between operands, and add a newline
// after the last operand.

// Fprintln formats using the default formats for its operands and writes to w.
// Spaces are always added between operands and a newline is appended.
// It returns the number of bytes written and any write error encountered.
func Fprintln(w io.Writer, a ...interface{}) (n int, err error) <span class="cov0" title="0">{
        p := newPrinter()
        p.doPrintln(a)
        n, err = w.Write(p.buf)
        p.free()
        return
}</span>

// Println formats using the default formats for its operands and writes to standard output.
// Spaces are always added between operands and a newline is appended.
// It returns the number of bytes written and any write error encountered.
func Println(a ...interface{}) (n int, err error) <span class="cov0" title="0">{
        return Fprintln(os.Stdout, a...)
}</span>

// Sprintln formats using the default formats for its operands and returns the resulting string.
// Spaces are always added between operands and a newline is appended.
func Sprintln(a ...interface{}) string <span class="cov0" title="0">{
        p := newPrinter()
        p.doPrintln(a)
        s := string(p.buf)
        p.free()
        return s
}</span>

// getField gets the i'th field of the struct value.
// If the field is itself is an interface, return a value for
// the thing inside the interface, not the interface itself.
func getField(v reflect.Value, i int) reflect.Value <span class="cov0" title="0">{
        val := v.Field(i)
        if val.Kind() == reflect.Interface &amp;&amp; !val.IsNil() </span><span class="cov0" title="0">{
                val = val.Elem()
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return val</span>
}

// tooLarge reports whether the magnitude of the integer is
// too large to be used as a formatting width or precision.
func tooLarge(x int) bool <span class="cov0" title="0">{
        const max int = 1e6
        return x &gt; max || x &lt; -max
}</span>

// parsenum converts ASCII to integer.  num is 0 (and isnum is false) if no number present.
func parsenum(s string, start, end int) (num int, isnum bool, newi int) <span class="cov0" title="0">{
        if start &gt;= end </span><span class="cov0" title="0">{
                return 0, false, end
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">for newi = start; newi &lt; end &amp;&amp; '0' &lt;= s[newi] &amp;&amp; s[newi] &lt;= '9'; newi++ </span><span class="cov0" title="0">{
                if tooLarge(num) </span><span class="cov0" title="0">{
                        return 0, false, end // Overflow; crazy long number most likely.
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">num = num*10 + int(s[newi]-'0')
                isnum = true</span>
        }
        <span class="cov0" title="0">return</span>
}

func (p *pp) unknownType(v reflect.Value) <span class="cov0" title="0">{
        if !v.IsValid() </span><span class="cov0" title="0">{
                p.buf.writeString(nilAngleString)
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">p.buf.writeByte('?')
        p.buf.writeString(v.Type().String())
        p.buf.writeByte('?')</span>
}

func (p *pp) badVerb(verb rune) <span class="cov0" title="0">{
        p.erroring = true
        p.buf.writeString(percentBangString)
        p.buf.writeRune(verb)
        p.buf.writeByte('(')
        switch </span>{
        <span class="cov0" title="0">case p.arg != nil:
                p.buf.writeString(reflect.TypeOf(p.arg).String())
                p.buf.writeByte('=')
                p.printArg(p.arg, 'v')</span>
        <span class="cov0" title="0">case p.value.IsValid():
                p.buf.writeString(p.value.Type().String())
                p.buf.writeByte('=')
                p.printValue(p.value, 'v', 0)</span>
        <span class="cov0" title="0">default:
                p.buf.writeString(nilAngleString)</span>
        }
        <span class="cov0" title="0">p.buf.writeByte(')')
        p.erroring = false</span>
}

func (p *pp) fmtBool(v bool, verb rune) <span class="cov0" title="0">{
        switch verb </span>{
        <span class="cov0" title="0">case 't', 'v':
                p.fmt.fmtBoolean(v)</span>
        <span class="cov0" title="0">default:
                p.badVerb(verb)</span>
        }
}

// fmt0x64 formats a uint64 in hexadecimal and prefixes it with 0x or
// not, as requested, by temporarily setting the sharp flag.
func (p *pp) fmt0x64(v uint64, leading0x bool) <span class="cov0" title="0">{
        sharp := p.fmt.sharp
        p.fmt.sharp = leading0x
        p.fmt.fmtInteger(v, 16, unsigned, 'v', ldigits)
        p.fmt.sharp = sharp
}</span>

// fmtInteger formats a signed or unsigned integer.
func (p *pp) fmtInteger(v uint64, isSigned bool, verb rune) <span class="cov0" title="0">{
        switch verb </span>{
        <span class="cov0" title="0">case 'v':
                if p.fmt.sharpV &amp;&amp; !isSigned </span><span class="cov0" title="0">{
                        p.fmt0x64(v, true)
                }</span><span class="cov0" title="0"> else {
                        p.fmt.fmtInteger(v, 10, isSigned, verb, ldigits)
                }</span>
        <span class="cov0" title="0">case 'd':
                p.fmt.fmtInteger(v, 10, isSigned, verb, ldigits)</span>
        <span class="cov0" title="0">case 'b':
                p.fmt.fmtInteger(v, 2, isSigned, verb, ldigits)</span>
        <span class="cov0" title="0">case 'o', 'O':
                p.fmt.fmtInteger(v, 8, isSigned, verb, ldigits)</span>
        <span class="cov0" title="0">case 'x':
                p.fmt.fmtInteger(v, 16, isSigned, verb, ldigits)</span>
        <span class="cov0" title="0">case 'X':
                p.fmt.fmtInteger(v, 16, isSigned, verb, udigits)</span>
        <span class="cov0" title="0">case 'c':
                p.fmt.fmtC(v)</span>
        <span class="cov0" title="0">case 'q':
                if v &lt;= utf8.MaxRune </span><span class="cov0" title="0">{
                        p.fmt.fmtQc(v)
                }</span><span class="cov0" title="0"> else {
                        p.badVerb(verb)
                }</span>
        <span class="cov0" title="0">case 'U':
                p.fmt.fmtUnicode(v)</span>
        <span class="cov0" title="0">default:
                p.badVerb(verb)</span>
        }
}

// fmtFloat formats a float. The default precision for each verb
// is specified as last argument in the call to fmt_float.
func (p *pp) fmtFloat(v float64, size int, verb rune) <span class="cov0" title="0">{
        switch verb </span>{
        <span class="cov0" title="0">case 'v':
                p.fmt.fmtFloat(v, size, 'g', -1)</span>
        <span class="cov0" title="0">case 'b', 'g', 'G', 'x', 'X':
                p.fmt.fmtFloat(v, size, verb, -1)</span>
        <span class="cov0" title="0">case 'f', 'e', 'E':
                p.fmt.fmtFloat(v, size, verb, 6)</span>
        <span class="cov0" title="0">case 'F':
                p.fmt.fmtFloat(v, size, 'f', 6)</span>
        <span class="cov0" title="0">default:
                p.badVerb(verb)</span>
        }
}

// fmtComplex formats a complex number v with
// r = real(v) and j = imag(v) as (r+ji) using
// fmtFloat for r and j formatting.
func (p *pp) fmtComplex(v complex128, size int, verb rune) <span class="cov0" title="0">{
        // Make sure any unsupported verbs are found before the
        // calls to fmtFloat to not generate an incorrect error string.
        switch verb </span>{
        <span class="cov0" title="0">case 'v', 'b', 'g', 'G', 'x', 'X', 'f', 'F', 'e', 'E':
                oldPlus := p.fmt.plus
                p.buf.writeByte('(')
                p.fmtFloat(real(v), size/2, verb)
                // Imaginary part always has a sign.
                p.fmt.plus = true
                p.fmtFloat(imag(v), size/2, verb)
                p.buf.writeString("i)")
                p.fmt.plus = oldPlus</span>
        <span class="cov0" title="0">default:
                p.badVerb(verb)</span>
        }
}

func (p *pp) fmtString(v string, verb rune) <span class="cov8" title="1">{
        switch verb </span>{
        <span class="cov0" title="0">case 'v':
                if p.fmt.sharpV </span><span class="cov0" title="0">{
                        p.fmt.fmtQ(v)
                }</span><span class="cov0" title="0"> else {
                        p.fmt.fmtS(v)
                }</span>
        <span class="cov0" title="0">case 's':
                p.fmt.fmtS(v)</span>
        <span class="cov0" title="0">case 'x':
                p.fmt.fmtSx(v, ldigits)</span>
        <span class="cov0" title="0">case 'X':
                p.fmt.fmtSx(v, udigits)</span>
        <span class="cov8" title="1">case 'q':
                p.fmt.fmtQ(v)</span>
        <span class="cov0" title="0">default:
                p.badVerb(verb)</span>
        }
}

func (p *pp) fmtBytes(v []byte, verb rune, typeString string) <span class="cov0" title="0">{
        switch verb </span>{
        <span class="cov0" title="0">case 'v', 'd':
                if p.fmt.sharpV </span><span class="cov0" title="0">{
                        p.buf.writeString(typeString)
                        if v == nil </span><span class="cov0" title="0">{
                                p.buf.writeString(nilParenString)
                                return
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">p.buf.writeByte('{')
                        for i, c := range v </span><span class="cov0" title="0">{
                                if i &gt; 0 </span><span class="cov0" title="0">{
                                        p.buf.writeString(commaSpaceString)
                                }</span><span class="cov0" title="0">
</span>                                <span class="cov0" title="0">p.fmt0x64(uint64(c), true)</span>
                        }
                        <span class="cov0" title="0">p.buf.writeByte('}')</span>
                }<span class="cov0" title="0"> else {
                        p.buf.writeByte('[')
                        for i, c := range v </span><span class="cov0" title="0">{
                                if i &gt; 0 </span><span class="cov0" title="0">{
                                        p.buf.writeByte(' ')
                                }</span><span class="cov0" title="0">
</span>                                <span class="cov0" title="0">p.fmt.fmtInteger(uint64(c), 10, unsigned, verb, ldigits)</span>
                        }
                        <span class="cov0" title="0">p.buf.writeByte(']')</span>
                }
        <span class="cov0" title="0">case 's':
                p.fmt.fmtBs(v)</span>
        <span class="cov0" title="0">case 'x':
                p.fmt.fmtBx(v, ldigits)</span>
        <span class="cov0" title="0">case 'X':
                p.fmt.fmtBx(v, udigits)</span>
        <span class="cov0" title="0">case 'q':
                p.fmt.fmtQ(string(v))</span>
        <span class="cov0" title="0">default:
                p.printValue(reflect.ValueOf(v), verb, 0)</span>
        }
}

func (p *pp) fmtPointer(value reflect.Value, verb rune) <span class="cov0" title="0">{
        var u uintptr
        switch value.Kind() </span>{
        <span class="cov0" title="0">case reflect.Chan, reflect.Func, reflect.Map, reflect.Ptr, reflect.Slice, reflect.UnsafePointer:
                u = value.Pointer()</span>
        <span class="cov0" title="0">default:
                p.badVerb(verb)
                return</span>
        }

        <span class="cov0" title="0">switch verb </span>{
        <span class="cov0" title="0">case 'v':
                if p.fmt.sharpV </span><span class="cov0" title="0">{
                        p.buf.writeByte('(')
                        p.buf.writeString(value.Type().String())
                        p.buf.writeString(")(")
                        if u == 0 </span><span class="cov0" title="0">{
                                p.buf.writeString(nilString)
                        }</span><span class="cov0" title="0"> else {
                                p.fmt0x64(uint64(u), true)
                        }</span>
                        <span class="cov0" title="0">p.buf.writeByte(')')</span>
                }<span class="cov0" title="0"> else {
                        if u == 0 </span><span class="cov0" title="0">{
                                p.fmt.padString(nilAngleString)
                        }</span><span class="cov0" title="0"> else {
                                p.fmt0x64(uint64(u), !p.fmt.sharp)
                        }</span>
                }
        <span class="cov0" title="0">case 'p':
                p.fmt0x64(uint64(u), !p.fmt.sharp)</span>
        <span class="cov0" title="0">case 'b', 'o', 'd', 'x', 'X':
                p.fmtInteger(uint64(u), unsigned, verb)</span>
        <span class="cov0" title="0">default:
                p.badVerb(verb)</span>
        }
}

func (p *pp) catchPanic(arg interface{}, verb rune, method string) <span class="cov0" title="0">{
        if err := recover(); err != nil </span><span class="cov0" title="0">{
                // If it's a nil pointer, just say "&lt;nil&gt;". The likeliest causes are a
                // Stringer that fails to guard against nil or a nil pointer for a
                // value receiver, and in either case, "&lt;nil&gt;" is a nice result.
                if v := reflect.ValueOf(arg); v.Kind() == reflect.Ptr &amp;&amp; v.IsNil() </span><span class="cov0" title="0">{
                        p.buf.writeString(nilAngleString)
                        return
                }</span><span class="cov0" title="0">
</span>                // Otherwise print a concise panic message. Most of the time the panic
                // value will print itself nicely.
                <span class="cov0" title="0">if p.panicking </span><span class="cov0" title="0">{
                        // Nested panics; the recursion in printArg cannot succeed.
                        panic(err)</span>
                }<span class="cov0" title="0">
</span>
                <span class="cov0" title="0">oldFlags := p.fmt.fmtFlags
                // For this output we want default behavior.
                p.fmt.clearflags()

                p.buf.writeString(percentBangString)
                p.buf.writeRune(verb)
                p.buf.writeString(panicString)
                p.buf.writeString(method)
                p.buf.writeString(" method: ")
                p.panicking = true
                p.printArg(err, 'v')
                p.panicking = false
                p.buf.writeByte(')')

                p.fmt.fmtFlags = oldFlags</span>
        }<span class="cov0" title="0">
</span>}

func (p *pp) handleMethods(verb rune) (handled bool) <span class="cov0" title="0">{
        if p.erroring </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if verb == 'w' </span><span class="cov0" title="0">{
                // It is invalid to use %w other than with Errorf, more than once,
                // or with a non-error arg.
                err, ok := p.arg.(error)
                if !ok || !p.wrapErrs || p.wrappedErr != nil </span><span class="cov0" title="0">{
                        p.wrappedErr = nil
                        p.wrapErrs = false
                        p.badVerb(verb)
                        return true
                }</span><span class="cov8" title="1">
</span>                <span class="cov0" title="0">p.wrappedErr = err
                // If the arg is a Formatter, pass 'v' as the verb to it.
                verb = 'v'</span>
        }<span class="cov0" title="0">
</span>
        // Is it a Formatter?
        <span class="cov0" title="0">if formatter, ok := p.arg.(Formatter); ok </span><span class="cov0" title="0">{
                handled = true
                defer p.catchPanic(p.arg, verb, "Format")
                formatter.Format(p, verb)
                return
        }</span><span class="cov0" title="0">
</span>
        // If we're doing Go syntax and the argument knows how to supply it, take care of it now.
        <span class="cov0" title="0">if p.fmt.sharpV </span><span class="cov0" title="0">{
                if stringer, ok := p.arg.(GoStringer); ok </span><span class="cov0" title="0">{
                        handled = true
                        defer p.catchPanic(p.arg, verb, "GoString")
                        // Print the result of GoString unadorned.
                        p.fmt.fmtS(stringer.GoString())
                        return
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0"> else {
                // If a string is acceptable according to the format, see if
                // the value satisfies one of the string-valued interfaces.
                // Println etc. set verb to %v, which is "stringable".
                switch verb </span>{
                <span class="cov0" title="0">case 'v', 's', 'x', 'X', 'q':
                        // Is it an error or Stringer?
                        // The duplication in the bodies is necessary:
                        // setting handled and deferring catchPanic
                        // must happen before calling the method.
                        switch v := p.arg.(type) </span>{
                        <span class="cov0" title="0">case error:
                                handled = true
                                defer p.catchPanic(p.arg, verb, "Error")
                                p.fmtString(v.Error(), verb)
                                return</span>

                        <span class="cov0" title="0">case Stringer:
                                handled = true
                                defer p.catchPanic(p.arg, verb, "String")
                                p.fmtString(v.String(), verb)
                                return</span>
                        }
                }
        }
        <span class="cov0" title="0">return false</span>
}

func (p *pp) printArg(arg interface{}, verb rune) <span class="cov8" title="1">{
        p.arg = arg
        p.value = reflect.Value{}

        if arg == nil </span><span class="cov0" title="0">{
                switch verb </span>{
                <span class="cov0" title="0">case 'T', 'v':
                        p.fmt.padString(nilAngleString)</span>
                <span class="cov0" title="0">default:
                        p.badVerb(verb)</span>
                }
                <span class="cov0" title="0">return</span>
        }<span class="cov8" title="1">
</span>
        // Special processing considerations.
        // %T (the value's type) and %p (its address) are special; we always do them first.
        <span class="cov8" title="1">switch verb </span>{
        <span class="cov0" title="0">case 'T':
                p.fmt.fmtS(reflect.TypeOf(arg).String())
                return</span>
        <span class="cov0" title="0">case 'p':
                p.fmtPointer(reflect.ValueOf(arg), 'p')
                return</span>
        }

        // Some types can be done without reflection.
        <span class="cov8" title="1">switch f := arg.(type) </span>{
        <span class="cov0" title="0">case bool:
                p.fmtBool(f, verb)</span>
        <span class="cov0" title="0">case float32:
                p.fmtFloat(float64(f), 32, verb)</span>
        <span class="cov0" title="0">case float64:
                p.fmtFloat(f, 64, verb)</span>
        <span class="cov0" title="0">case complex64:
                p.fmtComplex(complex128(f), 64, verb)</span>
        <span class="cov0" title="0">case complex128:
                p.fmtComplex(f, 128, verb)</span>
        <span class="cov0" title="0">case int:
                p.fmtInteger(uint64(f), signed, verb)</span>
        <span class="cov0" title="0">case int8:
                p.fmtInteger(uint64(f), signed, verb)</span>
        <span class="cov0" title="0">case int16:
                p.fmtInteger(uint64(f), signed, verb)</span>
        <span class="cov0" title="0">case int32:
                p.fmtInteger(uint64(f), signed, verb)</span>
        <span class="cov0" title="0">case int64:
                p.fmtInteger(uint64(f), signed, verb)</span>
        <span class="cov0" title="0">case uint:
                p.fmtInteger(uint64(f), unsigned, verb)</span>
        <span class="cov0" title="0">case uint8:
                p.fmtInteger(uint64(f), unsigned, verb)</span>
        <span class="cov0" title="0">case uint16:
                p.fmtInteger(uint64(f), unsigned, verb)</span>
        <span class="cov0" title="0">case uint32:
                p.fmtInteger(uint64(f), unsigned, verb)</span>
        <span class="cov0" title="0">case uint64:
                p.fmtInteger(f, unsigned, verb)</span>
        <span class="cov0" title="0">case uintptr:
                p.fmtInteger(uint64(f), unsigned, verb)</span>
        <span class="cov8" title="1">case string:
                p.fmtString(f, verb)</span>
        <span class="cov0" title="0">case []byte:
                p.fmtBytes(f, verb, "[]byte")</span>
        <span class="cov0" title="0">case reflect.Value:
                // Handle extractable values with special methods
                // since printValue does not handle them at depth 0.
                if f.IsValid() &amp;&amp; f.CanInterface() </span><span class="cov0" title="0">{
                        p.arg = f.Interface()
                        if p.handleMethods(verb) </span><span class="cov0" title="0">{
                                return
                        }</span><span class="cov0" title="0">
</span>                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">p.printValue(f, verb, 0)</span>
        <span class="cov0" title="0">default:
                // If the type is not simple, it might have methods.
                if !p.handleMethods(verb) </span><span class="cov0" title="0">{
                        // Need to use reflection, since the type had no
                        // interface methods that could be used for formatting.
                        p.printValue(reflect.ValueOf(f), verb, 0)
                }</span><span class="cov0" title="0">
</span>        }
}

// printValue is similar to printArg but starts with a reflect value, not an interface{} value.
// It does not handle 'p' and 'T' verbs because these should have been already handled by printArg.
func (p *pp) printValue(value reflect.Value, verb rune, depth int) <span class="cov0" title="0">{
        // Handle values with special methods if not already handled by printArg (depth == 0).
        if depth &gt; 0 &amp;&amp; value.IsValid() &amp;&amp; value.CanInterface() </span><span class="cov0" title="0">{
                p.arg = value.Interface()
                if p.handleMethods(verb) </span><span class="cov0" title="0">{
                        return
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">p.arg = nil
        p.value = value

        switch f := value; value.Kind() </span>{
        <span class="cov0" title="0">case reflect.Invalid:
                if depth == 0 </span><span class="cov0" title="0">{
                        p.buf.writeString(invReflectString)
                }</span><span class="cov0" title="0"> else {
                        switch verb </span>{
                        <span class="cov0" title="0">case 'v':
                                p.buf.writeString(nilAngleString)</span>
                        <span class="cov0" title="0">default:
                                p.badVerb(verb)</span>
                        }
                }
        <span class="cov0" title="0">case reflect.Bool:
                p.fmtBool(f.Bool(), verb)</span>
        <span class="cov0" title="0">case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
                p.fmtInteger(uint64(f.Int()), signed, verb)</span>
        <span class="cov0" title="0">case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
                p.fmtInteger(f.Uint(), unsigned, verb)</span>
        <span class="cov0" title="0">case reflect.Float32:
                p.fmtFloat(f.Float(), 32, verb)</span>
        <span class="cov0" title="0">case reflect.Float64:
                p.fmtFloat(f.Float(), 64, verb)</span>
        <span class="cov0" title="0">case reflect.Complex64:
                p.fmtComplex(f.Complex(), 64, verb)</span>
        <span class="cov0" title="0">case reflect.Complex128:
                p.fmtComplex(f.Complex(), 128, verb)</span>
        <span class="cov0" title="0">case reflect.String:
                p.fmtString(f.String(), verb)</span>
        <span class="cov0" title="0">case reflect.Map:
                if p.fmt.sharpV </span><span class="cov0" title="0">{
                        p.buf.writeString(f.Type().String())
                        if f.IsNil() </span><span class="cov0" title="0">{
                                p.buf.writeString(nilParenString)
                                return
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">p.buf.writeByte('{')</span>
                }<span class="cov0" title="0"> else {
                        p.buf.writeString(mapString)
                }</span>
                <span class="cov0" title="0">sorted := fmtsort.Sort(f)
                for i, key := range sorted.Key </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                if p.fmt.sharpV </span><span class="cov0" title="0">{
                                        p.buf.writeString(commaSpaceString)
                                }</span><span class="cov0" title="0"> else {
                                        p.buf.writeByte(' ')
                                }</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">p.printValue(key, verb, depth+1)
                        p.buf.writeByte(':')
                        p.printValue(sorted.Value[i], verb, depth+1)</span>
                }
                <span class="cov0" title="0">if p.fmt.sharpV </span><span class="cov0" title="0">{
                        p.buf.writeByte('}')
                }</span><span class="cov0" title="0"> else {
                        p.buf.writeByte(']')
                }</span>
        <span class="cov0" title="0">case reflect.Struct:
                if p.fmt.sharpV </span><span class="cov0" title="0">{
                        p.buf.writeString(f.Type().String())
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">p.buf.writeByte('{')
                for i := 0; i &lt; f.NumField(); i++ </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                if p.fmt.sharpV </span><span class="cov0" title="0">{
                                        p.buf.writeString(commaSpaceString)
                                }</span><span class="cov0" title="0"> else {
                                        p.buf.writeByte(' ')
                                }</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">if p.fmt.plusV || p.fmt.sharpV </span><span class="cov0" title="0">{
                                if name := f.Type().Field(i).Name; name != "" </span><span class="cov0" title="0">{
                                        p.buf.writeString(name)
                                        p.buf.writeByte(':')
                                }</span><span class="cov0" title="0">
</span>                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">p.printValue(getField(f, i), verb, depth+1)</span>
                }
                <span class="cov0" title="0">p.buf.writeByte('}')</span>
        <span class="cov0" title="0">case reflect.Interface:
                value := f.Elem()
                if !value.IsValid() </span><span class="cov0" title="0">{
                        if p.fmt.sharpV </span><span class="cov0" title="0">{
                                p.buf.writeString(f.Type().String())
                                p.buf.writeString(nilParenString)
                        }</span><span class="cov0" title="0"> else {
                                p.buf.writeString(nilAngleString)
                        }</span>
                }<span class="cov0" title="0"> else {
                        p.printValue(value, verb, depth+1)
                }</span>
        <span class="cov0" title="0">case reflect.Array, reflect.Slice:
                switch verb </span>{
                <span class="cov0" title="0">case 's', 'q', 'x', 'X':
                        // Handle byte and uint8 slices and arrays special for the above verbs.
                        t := f.Type()
                        if t.Elem().Kind() == reflect.Uint8 </span><span class="cov0" title="0">{
                                var bytes []byte
                                if f.Kind() == reflect.Slice </span><span class="cov0" title="0">{
                                        bytes = f.Bytes()
                                }</span><span class="cov0" title="0"> else if f.CanAddr() </span><span class="cov0" title="0">{
                                        bytes = f.Slice(0, f.Len()).Bytes()
                                }</span><span class="cov0" title="0"> else {
                                        // We have an array, but we cannot Slice() a non-addressable array,
                                        // so we build a slice by hand. This is a rare case but it would be nice
                                        // if reflection could help a little more.
                                        bytes = make([]byte, f.Len())
                                        for i := range bytes </span><span class="cov0" title="0">{
                                                bytes[i] = byte(f.Index(i).Uint())
                                        }</span>
                                }
                                <span class="cov0" title="0">p.fmtBytes(bytes, verb, t.String())
                                return</span>
                        }<span class="cov0" title="0">
</span>                }
                <span class="cov0" title="0">if p.fmt.sharpV </span><span class="cov0" title="0">{
                        p.buf.writeString(f.Type().String())
                        if f.Kind() == reflect.Slice &amp;&amp; f.IsNil() </span><span class="cov0" title="0">{
                                p.buf.writeString(nilParenString)
                                return
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">p.buf.writeByte('{')
                        for i := 0; i &lt; f.Len(); i++ </span><span class="cov0" title="0">{
                                if i &gt; 0 </span><span class="cov0" title="0">{
                                        p.buf.writeString(commaSpaceString)
                                }</span><span class="cov0" title="0">
</span>                                <span class="cov0" title="0">p.printValue(f.Index(i), verb, depth+1)</span>
                        }
                        <span class="cov0" title="0">p.buf.writeByte('}')</span>
                }<span class="cov0" title="0"> else {
                        p.buf.writeByte('[')
                        for i := 0; i &lt; f.Len(); i++ </span><span class="cov0" title="0">{
                                if i &gt; 0 </span><span class="cov0" title="0">{
                                        p.buf.writeByte(' ')
                                }</span><span class="cov0" title="0">
</span>                                <span class="cov0" title="0">p.printValue(f.Index(i), verb, depth+1)</span>
                        }
                        <span class="cov0" title="0">p.buf.writeByte(']')</span>
                }
        <span class="cov0" title="0">case reflect.Ptr:
                // pointer to array or slice or struct? ok at top level
                // but not embedded (avoid loops)
                if depth == 0 &amp;&amp; f.Pointer() != 0 </span><span class="cov0" title="0">{
                        switch a := f.Elem(); a.Kind() </span>{
                        <span class="cov0" title="0">case reflect.Array, reflect.Slice, reflect.Struct, reflect.Map:
                                p.buf.writeByte('&amp;')
                                p.printValue(a, verb, depth+1)
                                return</span>
                        }
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">fallthrough</span>
        <span class="cov0" title="0">case reflect.Chan, reflect.Func, reflect.UnsafePointer:
                p.fmtPointer(f, verb)</span>
        <span class="cov0" title="0">default:
                p.unknownType(f)</span>
        }
}

// intFromArg gets the argNumth element of a. On return, isInt reports whether the argument has integer type.
func intFromArg(a []interface{}, argNum int) (num int, isInt bool, newArgNum int) <span class="cov0" title="0">{
        newArgNum = argNum
        if argNum &lt; len(a) </span><span class="cov0" title="0">{
                num, isInt = a[argNum].(int) // Almost always OK.
                if !isInt </span><span class="cov0" title="0">{
                        // Work harder.
                        switch v := reflect.ValueOf(a[argNum]); v.Kind() </span>{
                        <span class="cov0" title="0">case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
                                n := v.Int()
                                if int64(int(n)) == n </span><span class="cov0" title="0">{
                                        num = int(n)
                                        isInt = true
                                }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
                                n := v.Uint()
                                if int64(n) &gt;= 0 &amp;&amp; uint64(int(n)) == n </span><span class="cov0" title="0">{
                                        num = int(n)
                                        isInt = true
                                }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">default:</span>
                                // Already 0, false.
                        }
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">newArgNum = argNum + 1
                if tooLarge(num) </span><span class="cov0" title="0">{
                        num = 0
                        isInt = false
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">return</span>
}

// parseArgNumber returns the value of the bracketed number, minus 1
// (explicit argument numbers are one-indexed but we want zero-indexed).
// The opening bracket is known to be present at format[0].
// The returned values are the index, the number of bytes to consume
// up to the closing paren, if present, and whether the number parsed
// ok. The bytes to consume will be 1 if no closing paren is present.
func parseArgNumber(format string) (index int, wid int, ok bool) <span class="cov0" title="0">{
        // There must be at least 3 bytes: [n].
        if len(format) &lt; 3 </span><span class="cov0" title="0">{
                return 0, 1, false
        }</span><span class="cov0" title="0">
</span>
        // Find closing bracket.
        <span class="cov0" title="0">for i := 1; i &lt; len(format); i++ </span><span class="cov0" title="0">{
                if format[i] == ']' </span><span class="cov0" title="0">{
                        width, ok, newi := parsenum(format, 1, i)
                        if !ok || newi != i </span><span class="cov0" title="0">{
                                return 0, i + 1, false
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">return width - 1, i + 1, true</span> // arg numbers are one-indexed and skip paren.
                }<span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return 0, 1, false</span>
}

// argNumber returns the next argument to evaluate, which is either the value of the passed-in
// argNum or the value of the bracketed integer that begins format[i:]. It also returns
// the new value of i, that is, the index of the next byte of the format to process.
func (p *pp) argNumber(argNum int, format string, i int, numArgs int) (newArgNum, newi int, found bool) <span class="cov0" title="0">{
        if len(format) &lt;= i || format[i] != '[' </span><span class="cov0" title="0">{
                return argNum, i, false
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">p.reordered = true
        index, wid, ok := parseArgNumber(format[i:])
        if ok &amp;&amp; 0 &lt;= index &amp;&amp; index &lt; numArgs </span><span class="cov0" title="0">{
                return index, i + wid, true
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">p.goodArgNum = false
        return argNum, i + wid, ok</span>
}

func (p *pp) badArgNum(verb rune) <span class="cov0" title="0">{
        p.buf.writeString(percentBangString)
        p.buf.writeRune(verb)
        p.buf.writeString(badIndexString)
}</span>

func (p *pp) missingArg(verb rune) <span class="cov0" title="0">{
        p.buf.writeString(percentBangString)
        p.buf.writeRune(verb)
        p.buf.writeString(missingString)
}</span>

func (p *pp) doPrintf(format string, a []interface{}) <span class="cov8" title="1">{
        end := len(format)
        argNum := 0         // we process one argument per non-trivial format
        afterIndex := false // previous item in format was an index like [3].
        p.reordered = false
formatLoop:
        for i := 0; i &lt; end; </span><span class="cov8" title="1">{
                p.goodArgNum = true
                lasti := i
                for i &lt; end &amp;&amp; format[i] != '%' </span><span class="cov8" title="1">{
                        i++
                }</span>
                <span class="cov8" title="1">if i &gt; lasti </span><span class="cov8" title="1">{
                        p.buf.writeString(format[lasti:i])
                }</span><span class="cov0" title="0">
</span>                <span class="cov8" title="1">if i &gt;= end </span><span class="cov8" title="1">{
                        // done processing format string
                        break</span>
                }<span class="cov8" title="1">
</span>
                // Process one verb
                <span class="cov8" title="1">i++

                // Do we have flags?
                p.fmt.clearflags()
        simpleFormat:
                for ; i &lt; end; i++ </span><span class="cov8" title="1">{
                        c := format[i]
                        switch c </span>{
                        <span class="cov0" title="0">case '#':
                                p.fmt.sharp = true</span>
                        <span class="cov0" title="0">case '0':
                                p.fmt.zero = !p.fmt.minus</span> // Only allow zero padding to the left.
                        <span class="cov0" title="0">case '+':
                                p.fmt.plus = true</span>
                        <span class="cov0" title="0">case '-':
                                p.fmt.minus = true
                                p.fmt.zero = false</span> // Do not pad with zeros to the right.
                        <span class="cov0" title="0">case ' ':
                                p.fmt.space = true</span>
                        <span class="cov8" title="1">default:
                                // Fast path for common case of ascii lower case simple verbs
                                // without precision or width or argument indices.
                                if 'a' &lt;= c &amp;&amp; c &lt;= 'z' &amp;&amp; argNum &lt; len(a) </span><span class="cov8" title="1">{
                                        if c == 'v' </span><span class="cov0" title="0">{
                                                // Go syntax
                                                p.fmt.sharpV = p.fmt.sharp
                                                p.fmt.sharp = false
                                                // Struct-field syntax
                                                p.fmt.plusV = p.fmt.plus
                                                p.fmt.plus = false
                                        }</span><span class="cov8" title="1">
</span>                                        <span class="cov8" title="1">p.printArg(a[argNum], rune(c))
                                        argNum++
                                        i++
                                        continue formatLoop</span>
                                }<span class="cov0" title="0">
</span>                                // Format is more complex than simple flags and a verb or is malformed.
                                <span class="cov0" title="0">break simpleFormat</span>
                        }
                }

                // Do we have an explicit argument index?
                <span class="cov0" title="0">argNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))

                // Do we have width?
                if i &lt; end &amp;&amp; format[i] == '*' </span><span class="cov0" title="0">{
                        i++
                        p.fmt.wid, p.fmt.widPresent, argNum = intFromArg(a, argNum)

                        if !p.fmt.widPresent </span><span class="cov0" title="0">{
                                p.buf.writeString(badWidthString)
                        }</span><span class="cov0" title="0">
</span>
                        // We have a negative width, so take its value and ensure
                        // that the minus flag is set
                        <span class="cov0" title="0">if p.fmt.wid &lt; 0 </span><span class="cov0" title="0">{
                                p.fmt.wid = -p.fmt.wid
                                p.fmt.minus = true
                                p.fmt.zero = false // Do not pad with zeros to the right.
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">afterIndex = false</span>
                }<span class="cov0" title="0"> else {
                        p.fmt.wid, p.fmt.widPresent, i = parsenum(format, i, end)
                        if afterIndex &amp;&amp; p.fmt.widPresent </span><span class="cov0" title="0">{ // "%[3]2d"
                                p.goodArgNum = false
                        }</span><span class="cov0" title="0">
</span>                }

                // Do we have precision?
                <span class="cov0" title="0">if i+1 &lt; end &amp;&amp; format[i] == '.' </span><span class="cov0" title="0">{
                        i++
                        if afterIndex </span><span class="cov0" title="0">{ // "%[3].2d"
                                p.goodArgNum = false
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">argNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))
                        if i &lt; end &amp;&amp; format[i] == '*' </span><span class="cov0" title="0">{
                                i++
                                p.fmt.prec, p.fmt.precPresent, argNum = intFromArg(a, argNum)
                                // Negative precision arguments don't make sense
                                if p.fmt.prec &lt; 0 </span><span class="cov0" title="0">{
                                        p.fmt.prec = 0
                                        p.fmt.precPresent = false
                                }</span><span class="cov0" title="0">
</span>                                <span class="cov0" title="0">if !p.fmt.precPresent </span><span class="cov0" title="0">{
                                        p.buf.writeString(badPrecString)
                                }</span><span class="cov0" title="0">
</span>                                <span class="cov0" title="0">afterIndex = false</span>
                        }<span class="cov0" title="0"> else {
                                p.fmt.prec, p.fmt.precPresent, i = parsenum(format, i, end)
                                if !p.fmt.precPresent </span><span class="cov0" title="0">{
                                        p.fmt.prec = 0
                                        p.fmt.precPresent = true
                                }</span><span class="cov0" title="0">
</span>                        }
                }<span class="cov0" title="0">
</span>
                <span class="cov0" title="0">if !afterIndex </span><span class="cov0" title="0">{
                        argNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))
                }</span><span class="cov0" title="0">
</span>
                <span class="cov0" title="0">if i &gt;= end </span><span class="cov0" title="0">{
                        p.buf.writeString(noVerbString)
                        break</span>
                }<span class="cov0" title="0">
</span>
                <span class="cov0" title="0">verb, size := rune(format[i]), 1
                if verb &gt;= utf8.RuneSelf </span><span class="cov0" title="0">{
                        verb, size = utf8.DecodeRuneInString(format[i:])
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">i += size

                switch </span>{
                <span class="cov0" title="0">case verb == '%': // Percent does not absorb operands and ignores f.wid and f.prec.
                        p.buf.writeByte('%')</span>
                <span class="cov0" title="0">case !p.goodArgNum:
                        p.badArgNum(verb)</span>
                <span class="cov0" title="0">case argNum &gt;= len(a): // No argument left over to print for the current verb.
                        p.missingArg(verb)</span>
                <span class="cov0" title="0">case verb == 'v':
                        // Go syntax
                        p.fmt.sharpV = p.fmt.sharp
                        p.fmt.sharp = false
                        // Struct-field syntax
                        p.fmt.plusV = p.fmt.plus
                        p.fmt.plus = false
                        fallthrough</span>
                <span class="cov0" title="0">default:
                        p.printArg(a[argNum], verb)
                        argNum++</span>
                }
        }

        // Check for extra arguments unless the call accessed the arguments
        // out of order, in which case it's too expensive to detect if they've all
        // been used and arguably OK if they're not.
        <span class="cov8" title="1">if !p.reordered &amp;&amp; argNum &lt; len(a) </span><span class="cov0" title="0">{
                p.fmt.clearflags()
                p.buf.writeString(extraString)
                for i, arg := range a[argNum:] </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                p.buf.writeString(commaSpaceString)
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">if arg == nil </span><span class="cov0" title="0">{
                                p.buf.writeString(nilAngleString)
                        }</span><span class="cov0" title="0"> else {
                                p.buf.writeString(reflect.TypeOf(arg).String())
                                p.buf.writeByte('=')
                                p.printArg(arg, 'v')
                        }</span>
                }
                <span class="cov0" title="0">p.buf.writeByte(')')</span>
        }<span class="cov8" title="1">
</span>}

func (p *pp) doPrint(a []interface{}) <span class="cov0" title="0">{
        prevString := false
        for argNum, arg := range a </span><span class="cov0" title="0">{
                isString := arg != nil &amp;&amp; reflect.TypeOf(arg).Kind() == reflect.String
                // Add a space between two non-string arguments.
                if argNum &gt; 0 &amp;&amp; !isString &amp;&amp; !prevString </span><span class="cov0" title="0">{
                        p.buf.writeByte(' ')
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">p.printArg(arg, 'v')
                prevString = isString</span>
        }
}

// doPrintln is like doPrint but always adds a space between arguments
// and a newline after the last argument.
func (p *pp) doPrintln(a []interface{}) <span class="cov0" title="0">{
        for argNum, arg := range a </span><span class="cov0" title="0">{
                if argNum &gt; 0 </span><span class="cov0" title="0">{
                        p.buf.writeByte(' ')
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">p.printArg(arg, 'v')</span>
        }
        <span class="cov0" title="0">p.buf.writeByte('\n')</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fmt

import (
        "errors"
        "io"
        "math"
        "os"
        "reflect"
        "strconv"
        "sync"
        "unicode/utf8"
)

// ScanState represents the scanner state passed to custom scanners.
// Scanners may do rune-at-a-time scanning or ask the ScanState
// to discover the next space-delimited token.
type ScanState interface {
        // ReadRune reads the next rune (Unicode code point) from the input.
        // If invoked during Scanln, Fscanln, or Sscanln, ReadRune() will
        // return EOF after returning the first '\n' or when reading beyond
        // the specified width.
        ReadRune() (r rune, size int, err error)
        // UnreadRune causes the next call to ReadRune to return the same rune.
        UnreadRune() error
        // SkipSpace skips space in the input. Newlines are treated appropriately
        // for the operation being performed; see the package documentation
        // for more information.
        SkipSpace()
        // Token skips space in the input if skipSpace is true, then returns the
        // run of Unicode code points c satisfying f(c).  If f is nil,
        // !unicode.IsSpace(c) is used; that is, the token will hold non-space
        // characters. Newlines are treated appropriately for the operation being
        // performed; see the package documentation for more information.
        // The returned slice points to shared data that may be overwritten
        // by the next call to Token, a call to a Scan function using the ScanState
        // as input, or when the calling Scan method returns.
        Token(skipSpace bool, f func(rune) bool) (token []byte, err error)
        // Width returns the value of the width option and whether it has been set.
        // The unit is Unicode code points.
        Width() (wid int, ok bool)
        // Because ReadRune is implemented by the interface, Read should never be
        // called by the scanning routines and a valid implementation of
        // ScanState may choose always to return an error from Read.
        Read(buf []byte) (n int, err error)
}

// Scanner is implemented by any value that has a Scan method, which scans
// the input for the representation of a value and stores the result in the
// receiver, which must be a pointer to be useful. The Scan method is called
// for any argument to Scan, Scanf, or Scanln that implements it.
type Scanner interface {
        Scan(state ScanState, verb rune) error
}

// Scan scans text read from standard input, storing successive
// space-separated values into successive arguments. Newlines count
// as space. It returns the number of items successfully scanned.
// If that is less than the number of arguments, err will report why.
func Scan(a ...interface{}) (n int, err error) <span class="cov0" title="0">{
        return Fscan(os.Stdin, a...)
}</span>

// Scanln is similar to Scan, but stops scanning at a newline and
// after the final item there must be a newline or EOF.
func Scanln(a ...interface{}) (n int, err error) <span class="cov0" title="0">{
        return Fscanln(os.Stdin, a...)
}</span>

// Scanf scans text read from standard input, storing successive
// space-separated values into successive arguments as determined by
// the format. It returns the number of items successfully scanned.
// If that is less than the number of arguments, err will report why.
// Newlines in the input must match newlines in the format.
// The one exception: the verb %c always scans the next rune in the
// input, even if it is a space (or tab etc.) or newline.
func Scanf(format string, a ...interface{}) (n int, err error) <span class="cov0" title="0">{
        return Fscanf(os.Stdin, format, a...)
}</span>

type stringReader string

func (r *stringReader) Read(b []byte) (n int, err error) <span class="cov0" title="0">{
        n = copy(b, *r)
        *r = (*r)[n:]
        if n == 0 </span><span class="cov0" title="0">{
                err = io.EOF
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return</span>
}

// Sscan scans the argument string, storing successive space-separated
// values into successive arguments. Newlines count as space. It
// returns the number of items successfully scanned. If that is less
// than the number of arguments, err will report why.
func Sscan(str string, a ...interface{}) (n int, err error) <span class="cov0" title="0">{
        return Fscan((*stringReader)(&amp;str), a...)
}</span>

// Sscanln is similar to Sscan, but stops scanning at a newline and
// after the final item there must be a newline or EOF.
func Sscanln(str string, a ...interface{}) (n int, err error) <span class="cov0" title="0">{
        return Fscanln((*stringReader)(&amp;str), a...)
}</span>

// Sscanf scans the argument string, storing successive space-separated
// values into successive arguments as determined by the format. It
// returns the number of items successfully parsed.
// Newlines in the input must match newlines in the format.
func Sscanf(str string, format string, a ...interface{}) (n int, err error) <span class="cov0" title="0">{
        return Fscanf((*stringReader)(&amp;str), format, a...)
}</span>

// Fscan scans text read from r, storing successive space-separated
// values into successive arguments. Newlines count as space. It
// returns the number of items successfully scanned. If that is less
// than the number of arguments, err will report why.
func Fscan(r io.Reader, a ...interface{}) (n int, err error) <span class="cov0" title="0">{
        s, old := newScanState(r, true, false)
        n, err = s.doScan(a)
        s.free(old)
        return
}</span>

// Fscanln is similar to Fscan, but stops scanning at a newline and
// after the final item there must be a newline or EOF.
func Fscanln(r io.Reader, a ...interface{}) (n int, err error) <span class="cov0" title="0">{
        s, old := newScanState(r, false, true)
        n, err = s.doScan(a)
        s.free(old)
        return
}</span>

// Fscanf scans text read from r, storing successive space-separated
// values into successive arguments as determined by the format. It
// returns the number of items successfully parsed.
// Newlines in the input must match newlines in the format.
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error) <span class="cov0" title="0">{
        s, old := newScanState(r, false, false)
        n, err = s.doScanf(format, a)
        s.free(old)
        return
}</span>

// scanError represents an error generated by the scanning software.
// It's used as a unique signature to identify such errors when recovering.
type scanError struct {
        err error
}

const eof = -1

// ss is the internal implementation of ScanState.
type ss struct {
        rs    io.RuneScanner // where to read input
        buf   buffer         // token accumulator
        count int            // runes consumed so far.
        atEOF bool           // already read EOF
        ssave
}

// ssave holds the parts of ss that need to be
// saved and restored on recursive scans.
type ssave struct {
        validSave bool // is or was a part of an actual ss.
        nlIsEnd   bool // whether newline terminates scan
        nlIsSpace bool // whether newline counts as white space
        argLimit  int  // max value of ss.count for this arg; argLimit &lt;= limit
        limit     int  // max value of ss.count.
        maxWid    int  // width of this arg.
}

// The Read method is only in ScanState so that ScanState
// satisfies io.Reader. It will never be called when used as
// intended, so there is no need to make it actually work.
func (s *ss) Read(buf []byte) (n int, err error) <span class="cov0" title="0">{
        return 0, errors.New("ScanState's Read should not be called. Use ReadRune")
}</span>

func (s *ss) ReadRune() (r rune, size int, err error) <span class="cov0" title="0">{
        if s.atEOF || s.count &gt;= s.argLimit </span><span class="cov0" title="0">{
                err = io.EOF
                return
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">r, size, err = s.rs.ReadRune()
        if err == nil </span><span class="cov0" title="0">{
                s.count++
                if s.nlIsEnd &amp;&amp; r == '\n' </span><span class="cov0" title="0">{
                        s.atEOF = true
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0"> else if err == io.EOF </span><span class="cov0" title="0">{
                s.atEOF = true
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return</span>
}

func (s *ss) Width() (wid int, ok bool) <span class="cov0" title="0">{
        if s.maxWid == hugeWid </span><span class="cov0" title="0">{
                return 0, false
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return s.maxWid, true</span>
}

// The public method returns an error; this private one panics.
// If getRune reaches EOF, the return value is EOF (-1).
func (s *ss) getRune() (r rune) <span class="cov0" title="0">{
        r, _, err := s.ReadRune()
        if err != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        return eof
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">s.error(err)</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">return</span>
}

// mustReadRune turns io.EOF into a panic(io.ErrUnexpectedEOF).
// It is called in cases such as string scanning where an EOF is a
// syntax error.
func (s *ss) mustReadRune() (r rune) <span class="cov0" title="0">{
        r = s.getRune()
        if r == eof </span><span class="cov0" title="0">{
                s.error(io.ErrUnexpectedEOF)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return</span>
}

func (s *ss) UnreadRune() error <span class="cov0" title="0">{
        s.rs.UnreadRune()
        s.atEOF = false
        s.count--
        return nil
}</span>

func (s *ss) error(err error) <span class="cov0" title="0">{
        panic(scanError{err})</span>
}

func (s *ss) errorString(err string) <span class="cov0" title="0">{
        panic(scanError{errors.New(err)})</span>
}

func (s *ss) Token(skipSpace bool, f func(rune) bool) (tok []byte, err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if e := recover(); e != nil </span><span class="cov0" title="0">{
                        if se, ok := e.(scanError); ok </span><span class="cov0" title="0">{
                                err = se.err
                        }</span><span class="cov0" title="0"> else {
                                panic(e)</span>
                        }
                }<span class="cov0" title="0">
</span>        }()
        <span class="cov0" title="0">if f == nil </span><span class="cov0" title="0">{
                f = notSpace
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">s.buf = s.buf[:0]
        tok = s.token(skipSpace, f)
        return</span>
}

// space is a copy of the unicode.White_Space ranges,
// to avoid depending on package unicode.
var space = [][2]uint16{
        {0x0009, 0x000d},
        {0x0020, 0x0020},
        {0x0085, 0x0085},
        {0x00a0, 0x00a0},
        {0x1680, 0x1680},
        {0x2000, 0x200a},
        {0x2028, 0x2029},
        {0x202f, 0x202f},
        {0x205f, 0x205f},
        {0x3000, 0x3000},
}

func isSpace(r rune) bool <span class="cov0" title="0">{
        if r &gt;= 1&lt;&lt;16 </span><span class="cov0" title="0">{
                return false
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">rx := uint16(r)
        for _, rng := range space </span><span class="cov0" title="0">{
                if rx &lt; rng[0] </span><span class="cov0" title="0">{
                        return false
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if rx &lt;= rng[1] </span><span class="cov0" title="0">{
                        return true
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return false</span>
}

// notSpace is the default scanning function used in Token.
func notSpace(r rune) bool <span class="cov0" title="0">{
        return !isSpace(r)
}</span>

// readRune is a structure to enable reading UTF-8 encoded code points
// from an io.Reader. It is used if the Reader given to the scanner does
// not already implement io.RuneScanner.
type readRune struct {
        reader   io.Reader
        buf      [utf8.UTFMax]byte // used only inside ReadRune
        pending  int               // number of bytes in pendBuf; only &gt;0 for bad UTF-8
        pendBuf  [utf8.UTFMax]byte // bytes left over
        peekRune rune              // if &gt;=0 next rune; when &lt;0 is ^(previous Rune)
}

// readByte returns the next byte from the input, which may be
// left over from a previous read if the UTF-8 was ill-formed.
func (r *readRune) readByte() (b byte, err error) <span class="cov0" title="0">{
        if r.pending &gt; 0 </span><span class="cov0" title="0">{
                b = r.pendBuf[0]
                copy(r.pendBuf[0:], r.pendBuf[1:])
                r.pending--
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">n, err := io.ReadFull(r.reader, r.pendBuf[:1])
        if n != 1 </span><span class="cov0" title="0">{
                return 0, err
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return r.pendBuf[0], err</span>
}

// ReadRune returns the next UTF-8 encoded code point from the
// io.Reader inside r.
func (r *readRune) ReadRune() (rr rune, size int, err error) <span class="cov0" title="0">{
        if r.peekRune &gt;= 0 </span><span class="cov0" title="0">{
                rr = r.peekRune
                r.peekRune = ^r.peekRune
                size = utf8.RuneLen(rr)
                return
        }</span><span class="cov8" title="1">
</span>        <span class="cov0" title="0">r.buf[0], err = r.readByte()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if r.buf[0] &lt; utf8.RuneSelf </span><span class="cov0" title="0">{ // fast check for common ASCII case
                rr = rune(r.buf[0])
                size = 1 // Known to be 1.
                // Flip the bits of the rune so it's available to UnreadRune.
                r.peekRune = ^rr
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">var n int
        for n = 1; !utf8.FullRune(r.buf[:n]); n++ </span><span class="cov0" title="0">{
                r.buf[n], err = r.readByte()
                if err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                err = nil
                                break</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">return</span>
                }<span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">rr, size = utf8.DecodeRune(r.buf[:n])
        if size &lt; n </span><span class="cov0" title="0">{ // an error, save the bytes for the next read
                copy(r.pendBuf[r.pending:], r.buf[size:n])
                r.pending += n - size
        }</span><span class="cov0" title="0">
</span>        // Flip the bits of the rune so it's available to UnreadRune.
        <span class="cov0" title="0">r.peekRune = ^rr
        return</span>
}

func (r *readRune) UnreadRune() error <span class="cov0" title="0">{
        if r.peekRune &gt;= 0 </span><span class="cov0" title="0">{
                return errors.New("fmt: scanning called UnreadRune with no rune available")
        }</span><span class="cov0" title="0">
</span>        // Reverse bit flip of previously read rune to obtain valid &gt;=0 state.
        <span class="cov0" title="0">r.peekRune = ^r.peekRune
        return nil</span>
}

var ssFree = sync.Pool{
        New: func() interface{} <span class="cov0" title="0">{ return new(ss) }</span>,
}

// newScanState allocates a new ss struct or grab a cached one.
func newScanState(r io.Reader, nlIsSpace, nlIsEnd bool) (s *ss, old ssave) <span class="cov0" title="0">{
        s = ssFree.Get().(*ss)
        if rs, ok := r.(io.RuneScanner); ok </span><span class="cov0" title="0">{
                s.rs = rs
        }</span><span class="cov0" title="0"> else {
                s.rs = &amp;readRune{reader: r, peekRune: -1}
        }</span>
        <span class="cov0" title="0">s.nlIsSpace = nlIsSpace
        s.nlIsEnd = nlIsEnd
        s.atEOF = false
        s.limit = hugeWid
        s.argLimit = hugeWid
        s.maxWid = hugeWid
        s.validSave = true
        s.count = 0
        return</span>
}

// free saves used ss structs in ssFree; avoid an allocation per invocation.
func (s *ss) free(old ssave) <span class="cov0" title="0">{
        // If it was used recursively, just restore the old state.
        if old.validSave </span><span class="cov0" title="0">{
                s.ssave = old
                return
        }</span><span class="cov0" title="0">
</span>        // Don't hold on to ss structs with large buffers.
        <span class="cov0" title="0">if cap(s.buf) &gt; 1024 </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">s.buf = s.buf[:0]
        s.rs = nil
        ssFree.Put(s)</span>
}

// SkipSpace provides Scan methods the ability to skip space and newline
// characters in keeping with the current scanning mode set by format strings
// and Scan/Scanln.
func (s *ss) SkipSpace() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                r := s.getRune()
                if r == eof </span><span class="cov0" title="0">{
                        return
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if r == '\r' &amp;&amp; s.peek("\n") </span><span class="cov0" title="0">{
                        continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">if r == '\n' </span><span class="cov0" title="0">{
                        if s.nlIsSpace </span><span class="cov0" title="0">{
                                continue</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">s.errorString("unexpected newline")
                        return</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">if !isSpace(r) </span><span class="cov0" title="0">{
                        s.UnreadRune()
                        break</span>
                }<span class="cov0" title="0">
</span>        }
}

// token returns the next space-delimited string from the input. It
// skips white space. For Scanln, it stops at newlines. For Scan,
// newlines are treated as spaces.
func (s *ss) token(skipSpace bool, f func(rune) bool) []byte <span class="cov0" title="0">{
        if skipSpace </span><span class="cov0" title="0">{
                s.SkipSpace()
        }</span><span class="cov0" title="0">
</span>        // read until white space or newline
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                r := s.getRune()
                if r == eof </span><span class="cov0" title="0">{
                        break</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">if !f(r) </span><span class="cov0" title="0">{
                        s.UnreadRune()
                        break</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">s.buf.writeRune(r)</span>
        }
        <span class="cov0" title="0">return s.buf</span>
}

var complexError = errors.New("syntax error scanning complex number")
var boolError = errors.New("syntax error scanning boolean")

func indexRune(s string, r rune) int <span class="cov0" title="0">{
        for i, c := range s </span><span class="cov0" title="0">{
                if c == r </span><span class="cov0" title="0">{
                        return i
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return -1</span>
}

// consume reads the next rune in the input and reports whether it is in the ok string.
// If accept is true, it puts the character into the input token.
func (s *ss) consume(ok string, accept bool) bool <span class="cov0" title="0">{
        r := s.getRune()
        if r == eof </span><span class="cov0" title="0">{
                return false
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if indexRune(ok, r) &gt;= 0 </span><span class="cov0" title="0">{
                if accept </span><span class="cov0" title="0">{
                        s.buf.writeRune(r)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return true</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if r != eof &amp;&amp; accept </span><span class="cov0" title="0">{
                s.UnreadRune()
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return false</span>
}

// peek reports whether the next character is in the ok string, without consuming it.
func (s *ss) peek(ok string) bool <span class="cov0" title="0">{
        r := s.getRune()
        if r != eof </span><span class="cov0" title="0">{
                s.UnreadRune()
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return indexRune(ok, r) &gt;= 0</span>
}

func (s *ss) notEOF() <span class="cov0" title="0">{
        // Guarantee there is data to be read.
        if r := s.getRune(); r == eof </span><span class="cov0" title="0">{
                panic(io.EOF)</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">s.UnreadRune()</span>
}

// accept checks the next rune in the input. If it's a byte (sic) in the string, it puts it in the
// buffer and returns true. Otherwise it return false.
func (s *ss) accept(ok string) bool <span class="cov0" title="0">{
        return s.consume(ok, true)
}</span>

// okVerb verifies that the verb is present in the list, setting s.err appropriately if not.
func (s *ss) okVerb(verb rune, okVerbs, typ string) bool <span class="cov0" title="0">{
        for _, v := range okVerbs </span><span class="cov0" title="0">{
                if v == verb </span><span class="cov0" title="0">{
                        return true
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">s.errorString("bad verb '%" + string(verb) + "' for " + typ)
        return false</span>
}

// scanBool returns the value of the boolean represented by the next token.
func (s *ss) scanBool(verb rune) bool <span class="cov0" title="0">{
        s.SkipSpace()
        s.notEOF()
        if !s.okVerb(verb, "tv", "boolean") </span><span class="cov0" title="0">{
                return false
        }</span><span class="cov0" title="0">
</span>        // Syntax-checking a boolean is annoying. We're not fastidious about case.
        <span class="cov0" title="0">switch s.getRune() </span>{
        <span class="cov0" title="0">case '0':
                return false</span>
        <span class="cov0" title="0">case '1':
                return true</span>
        <span class="cov0" title="0">case 't', 'T':
                if s.accept("rR") &amp;&amp; (!s.accept("uU") || !s.accept("eE")) </span><span class="cov0" title="0">{
                        s.error(boolError)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return true</span>
        <span class="cov0" title="0">case 'f', 'F':
                if s.accept("aA") &amp;&amp; (!s.accept("lL") || !s.accept("sS") || !s.accept("eE")) </span><span class="cov0" title="0">{
                        s.error(boolError)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return false</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Numerical elements
const (
        binaryDigits      = "01"
        octalDigits       = "01234567"
        decimalDigits     = "0123456789"
        hexadecimalDigits = "0123456789aAbBcCdDeEfF"
        sign              = "+-"
        period            = "."
        exponent          = "eEpP"
)

// getBase returns the numeric base represented by the verb and its digit string.
func (s *ss) getBase(verb rune) (base int, digits string) <span class="cov0" title="0">{
        s.okVerb(verb, "bdoUxXv", "integer") // sets s.err
        base = 10
        digits = decimalDigits
        switch verb </span>{
        <span class="cov0" title="0">case 'b':
                base = 2
                digits = binaryDigits</span>
        <span class="cov0" title="0">case 'o':
                base = 8
                digits = octalDigits</span>
        <span class="cov0" title="0">case 'x', 'X', 'U':
                base = 16
                digits = hexadecimalDigits</span>
        }
        <span class="cov0" title="0">return</span>
}

// scanNumber returns the numerical string with specified digits starting here.
func (s *ss) scanNumber(digits string, haveDigits bool) string <span class="cov0" title="0">{
        if !haveDigits </span><span class="cov0" title="0">{
                s.notEOF()
                if !s.accept(digits) </span><span class="cov0" title="0">{
                        s.errorString("expected integer")
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">for s.accept(digits) </span><span class="cov0" title="0">{
        }</span>
        <span class="cov0" title="0">return string(s.buf)</span>
}

// scanRune returns the next rune value in the input.
func (s *ss) scanRune(bitSize int) int64 <span class="cov0" title="0">{
        s.notEOF()
        r := s.getRune()
        n := uint(bitSize)
        x := (int64(r) &lt;&lt; (64 - n)) &gt;&gt; (64 - n)
        if x != int64(r) </span><span class="cov0" title="0">{
                s.errorString("overflow on character value " + string(r))
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return int64(r)</span>
}

// scanBasePrefix reports whether the integer begins with a base prefix
// and returns the base, digit string, and whether a zero was found.
// It is called only if the verb is %v.
func (s *ss) scanBasePrefix() (base int, digits string, zeroFound bool) <span class="cov0" title="0">{
        if !s.peek("0") </span><span class="cov0" title="0">{
                return 0, decimalDigits + "_", false
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">s.accept("0")
        // Special cases for 0, 0b, 0o, 0x.
        switch </span>{
        <span class="cov0" title="0">case s.peek("bB"):
                s.consume("bB", true)
                return 0, binaryDigits + "_", true</span>
        <span class="cov0" title="0">case s.peek("oO"):
                s.consume("oO", true)
                return 0, octalDigits + "_", true</span>
        <span class="cov0" title="0">case s.peek("xX"):
                s.consume("xX", true)
                return 0, hexadecimalDigits + "_", true</span>
        <span class="cov0" title="0">default:
                return 0, octalDigits + "_", true</span>
        }
}

// scanInt returns the value of the integer represented by the next
// token, checking for overflow. Any error is stored in s.err.
func (s *ss) scanInt(verb rune, bitSize int) int64 <span class="cov8" title="1">{
        if verb == 'c' </span><span class="cov0" title="0">{
                return s.scanRune(bitSize)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">s.SkipSpace()
        s.notEOF()
        base, digits := s.getBase(verb)
        haveDigits := false
        if verb == 'U' </span><span class="cov0" title="0">{
                if !s.consume("U", false) || !s.consume("+", false) </span><span class="cov0" title="0">{
                        s.errorString("bad unicode format ")
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0"> else {
                s.accept(sign) // If there's a sign, it will be left in the token buffer.
                if verb == 'v' </span><span class="cov0" title="0">{
                        base, digits, haveDigits = s.scanBasePrefix()
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">tok := s.scanNumber(digits, haveDigits)
        i, err := strconv.ParseInt(tok, base, 64)
        if err != nil </span><span class="cov0" title="0">{
                s.error(err)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">n := uint(bitSize)
        x := (i &lt;&lt; (64 - n)) &gt;&gt; (64 - n)
        if x != i </span><span class="cov0" title="0">{
                s.errorString("integer overflow on token " + tok)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return i</span>
}

// scanUint returns the value of the unsigned integer represented
// by the next token, checking for overflow. Any error is stored in s.err.
func (s *ss) scanUint(verb rune, bitSize int) uint64 <span class="cov0" title="0">{
        if verb == 'c' </span><span class="cov0" title="0">{
                return uint64(s.scanRune(bitSize))
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">s.SkipSpace()
        s.notEOF()
        base, digits := s.getBase(verb)
        haveDigits := false
        if verb == 'U' </span><span class="cov0" title="0">{
                if !s.consume("U", false) || !s.consume("+", false) </span><span class="cov0" title="0">{
                        s.errorString("bad unicode format ")
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0"> else if verb == 'v' </span><span class="cov0" title="0">{
                base, digits, haveDigits = s.scanBasePrefix()
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">tok := s.scanNumber(digits, haveDigits)
        i, err := strconv.ParseUint(tok, base, 64)
        if err != nil </span><span class="cov0" title="0">{
                s.error(err)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">n := uint(bitSize)
        x := (i &lt;&lt; (64 - n)) &gt;&gt; (64 - n)
        if x != i </span><span class="cov0" title="0">{
                s.errorString("unsigned integer overflow on token " + tok)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return i</span>
}

// floatToken returns the floating-point number starting here, no longer than swid
// if the width is specified. It's not rigorous about syntax because it doesn't check that
// we have at least some digits, but Atof will do that.
func (s *ss) floatToken() string <span class="cov0" title="0">{
        s.buf = s.buf[:0]
        // NaN?
        if s.accept("nN") &amp;&amp; s.accept("aA") &amp;&amp; s.accept("nN") </span><span class="cov0" title="0">{
                return string(s.buf)
        }</span><span class="cov0" title="0">
</span>        // leading sign?
        <span class="cov0" title="0">s.accept(sign)
        // Inf?
        if s.accept("iI") &amp;&amp; s.accept("nN") &amp;&amp; s.accept("fF") </span><span class="cov0" title="0">{
                return string(s.buf)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">digits := decimalDigits + "_"
        exp := exponent
        if s.accept("0") &amp;&amp; s.accept("xX") </span><span class="cov0" title="0">{
                digits = hexadecimalDigits + "_"
                exp = "pP"
        }</span><span class="cov0" title="0">
</span>        // digits?
        <span class="cov0" title="0">for s.accept(digits) </span><span class="cov0" title="0">{
        }</span>
        // decimal point?
        <span class="cov0" title="0">if s.accept(period) </span><span class="cov0" title="0">{
                // fraction?
                for s.accept(digits) </span><span class="cov0" title="0">{
                }</span>
        }<span class="cov0" title="0">
</span>        // exponent?
        <span class="cov0" title="0">if s.accept(exp) </span><span class="cov0" title="0">{
                // leading sign?
                s.accept(sign)
                // digits?
                for s.accept(decimalDigits + "_") </span><span class="cov0" title="0">{
                }</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">return string(s.buf)</span>
}

// complexTokens returns the real and imaginary parts of the complex number starting here.
// The number might be parenthesized and has the format (N+Ni) where N is a floating-point
// number and there are no spaces within.
func (s *ss) complexTokens() (real, imag string) <span class="cov0" title="0">{
        // TODO: accept N and Ni independently?
        parens := s.accept("(")
        real = s.floatToken()
        s.buf = s.buf[:0]
        // Must now have a sign.
        if !s.accept("+-") </span><span class="cov0" title="0">{
                s.error(complexError)
        }</span><span class="cov0" title="0">
</span>        // Sign is now in buffer
        <span class="cov0" title="0">imagSign := string(s.buf)
        imag = s.floatToken()
        if !s.accept("i") </span><span class="cov0" title="0">{
                s.error(complexError)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if parens &amp;&amp; !s.accept(")") </span><span class="cov0" title="0">{
                s.error(complexError)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return real, imagSign + imag</span>
}

func hasX(s string) bool <span class="cov0" title="0">{
        for i := 0; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                if s[i] == 'x' || s[i] == 'X' </span><span class="cov0" title="0">{
                        return true
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return false</span>
}

// convertFloat converts the string to a float64value.
func (s *ss) convertFloat(str string, n int) float64 <span class="cov0" title="0">{
        // strconv.ParseFloat will handle "+0x1.fp+2",
        // but we have to implement our non-standard
        // decimal+binary exponent mix (1.2p4) ourselves.
        if p := indexRune(str, 'p'); p &gt;= 0 &amp;&amp; !hasX(str) </span><span class="cov0" title="0">{
                // Atof doesn't handle power-of-2 exponents,
                // but they're easy to evaluate.
                f, err := strconv.ParseFloat(str[:p], n)
                if err != nil </span><span class="cov0" title="0">{
                        // Put full string into error.
                        if e, ok := err.(*strconv.NumError); ok </span><span class="cov0" title="0">{
                                e.Num = str
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">s.error(err)</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">m, err := strconv.Atoi(str[p+1:])
                if err != nil </span><span class="cov0" title="0">{
                        // Put full string into error.
                        if e, ok := err.(*strconv.NumError); ok </span><span class="cov0" title="0">{
                                e.Num = str
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">s.error(err)</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">return math.Ldexp(f, m)</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">f, err := strconv.ParseFloat(str, n)
        if err != nil </span><span class="cov0" title="0">{
                s.error(err)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return f</span>
}

// convertComplex converts the next token to a complex128 value.
// The atof argument is a type-specific reader for the underlying type.
// If we're reading complex64, atof will parse float32s and convert them
// to float64's to avoid reproducing this code for each complex type.
func (s *ss) scanComplex(verb rune, n int) complex128 <span class="cov0" title="0">{
        if !s.okVerb(verb, floatVerbs, "complex") </span><span class="cov0" title="0">{
                return 0
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">s.SkipSpace()
        s.notEOF()
        sreal, simag := s.complexTokens()
        real := s.convertFloat(sreal, n/2)
        imag := s.convertFloat(simag, n/2)
        return complex(real, imag)</span>
}

// convertString returns the string represented by the next input characters.
// The format of the input is determined by the verb.
func (s *ss) convertString(verb rune) (str string) <span class="cov0" title="0">{
        if !s.okVerb(verb, "svqxX", "string") </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">s.SkipSpace()
        s.notEOF()
        switch verb </span>{
        <span class="cov0" title="0">case 'q':
                str = s.quotedString()</span>
        <span class="cov0" title="0">case 'x', 'X':
                str = s.hexString()</span>
        <span class="cov0" title="0">default:
                str = string(s.token(true, notSpace))</span> // %s and %v just return the next word
        }
        <span class="cov0" title="0">return</span>
}

// quotedString returns the double- or back-quoted string represented by the next input characters.
func (s *ss) quotedString() string <span class="cov0" title="0">{
        s.notEOF()
        quote := s.getRune()
        switch quote </span>{
        <span class="cov0" title="0">case '`':
                // Back-quoted: Anything goes until EOF or back quote.
                for </span><span class="cov0" title="0">{
                        r := s.mustReadRune()
                        if r == quote </span><span class="cov0" title="0">{
                                break</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">s.buf.writeRune(r)</span>
                }
                <span class="cov0" title="0">return string(s.buf)</span>
        <span class="cov0" title="0">case '"':
                // Double-quoted: Include the quotes and let strconv.Unquote do the backslash escapes.
                s.buf.writeByte('"')
                for </span><span class="cov0" title="0">{
                        r := s.mustReadRune()
                        s.buf.writeRune(r)
                        if r == '\\' </span><span class="cov0" title="0">{
                                // In a legal backslash escape, no matter how long, only the character
                                // immediately after the escape can itself be a backslash or quote.
                                // Thus we only need to protect the first character after the backslash.
                                s.buf.writeRune(s.mustReadRune())
                        }</span><span class="cov0" title="0"> else if r == '"' </span><span class="cov0" title="0">{
                                break</span>
                        }<span class="cov0" title="0">
</span>                }
                <span class="cov0" title="0">result, err := strconv.Unquote(string(s.buf))
                if err != nil </span><span class="cov0" title="0">{
                        s.error(err)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return result</span>
        <span class="cov0" title="0">default:
                s.errorString("expected quoted string")</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// hexDigit returns the value of the hexadecimal digit.
func hexDigit(d rune) (int, bool) <span class="cov0" title="0">{
        digit := int(d)
        switch digit </span>{
        <span class="cov0" title="0">case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
                return digit - '0', true</span>
        <span class="cov0" title="0">case 'a', 'b', 'c', 'd', 'e', 'f':
                return 10 + digit - 'a', true</span>
        <span class="cov0" title="0">case 'A', 'B', 'C', 'D', 'E', 'F':
                return 10 + digit - 'A', true</span>
        }
        <span class="cov0" title="0">return -1, false</span>
}

// hexByte returns the next hex-encoded (two-character) byte from the input.
// It returns ok==false if the next bytes in the input do not encode a hex byte.
// If the first byte is hex and the second is not, processing stops.
func (s *ss) hexByte() (b byte, ok bool) <span class="cov0" title="0">{
        rune1 := s.getRune()
        if rune1 == eof </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">value1, ok := hexDigit(rune1)
        if !ok </span><span class="cov0" title="0">{
                s.UnreadRune()
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">value2, ok := hexDigit(s.mustReadRune())
        if !ok </span><span class="cov0" title="0">{
                s.errorString("illegal hex digit")
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return byte(value1&lt;&lt;4 | value2), true</span>
}

// hexString returns the space-delimited hexpair-encoded string.
func (s *ss) hexString() string <span class="cov0" title="0">{
        s.notEOF()
        for </span><span class="cov0" title="0">{
                b, ok := s.hexByte()
                if !ok </span><span class="cov0" title="0">{
                        break</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">s.buf.writeByte(b)</span>
        }
        <span class="cov0" title="0">if len(s.buf) == 0 </span><span class="cov0" title="0">{
                s.errorString("no hex data for %x string")
                return ""
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return string(s.buf)</span>
}

const (
        floatVerbs = "beEfFgGv"

        hugeWid = 1 &lt;&lt; 30

        intBits     = 32 &lt;&lt; (^uint(0) &gt;&gt; 63)
        uintptrBits = 32 &lt;&lt; (^uintptr(0) &gt;&gt; 63)
)

// scanPercent scans a literal percent character.
func (s *ss) scanPercent() <span class="cov0" title="0">{
        s.SkipSpace()
        s.notEOF()
        if !s.accept("%") </span><span class="cov0" title="0">{
                s.errorString("missing literal %")
        }</span><span class="cov0" title="0">
</span>}

// scanOne scans a single value, deriving the scanner from the type of the argument.
func (s *ss) scanOne(verb rune, arg interface{}) <span class="cov0" title="0">{
        s.buf = s.buf[:0]
        var err error
        // If the parameter has its own Scan method, use that.
        if v, ok := arg.(Scanner); ok </span><span class="cov0" title="0">{
                err = v.Scan(s, verb)
                if err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                err = io.ErrUnexpectedEOF
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">s.error(err)</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">return</span>
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">switch v := arg.(type) </span>{
        <span class="cov0" title="0">case *bool:
                *v = s.scanBool(verb)</span>
        <span class="cov0" title="0">case *complex64:
                *v = complex64(s.scanComplex(verb, 64))</span>
        <span class="cov0" title="0">case *complex128:
                *v = s.scanComplex(verb, 128)</span>
        <span class="cov0" title="0">case *int:
                *v = int(s.scanInt(verb, intBits))</span>
        <span class="cov0" title="0">case *int8:
                *v = int8(s.scanInt(verb, 8))</span>
        <span class="cov0" title="0">case *int16:
                *v = int16(s.scanInt(verb, 16))</span>
        <span class="cov0" title="0">case *int32:
                *v = int32(s.scanInt(verb, 32))</span>
        <span class="cov0" title="0">case *int64:
                *v = s.scanInt(verb, 64)</span>
        <span class="cov0" title="0">case *uint:
                *v = uint(s.scanUint(verb, intBits))</span>
        <span class="cov0" title="0">case *uint8:
                *v = uint8(s.scanUint(verb, 8))</span>
        <span class="cov0" title="0">case *uint16:
                *v = uint16(s.scanUint(verb, 16))</span>
        <span class="cov0" title="0">case *uint32:
                *v = uint32(s.scanUint(verb, 32))</span>
        <span class="cov0" title="0">case *uint64:
                *v = s.scanUint(verb, 64)</span>
        <span class="cov0" title="0">case *uintptr:
                *v = uintptr(s.scanUint(verb, uintptrBits))</span>
        // Floats are tricky because you want to scan in the precision of the result, not
        // scan in high precision and convert, in order to preserve the correct error condition.
        <span class="cov0" title="0">case *float32:
                if s.okVerb(verb, floatVerbs, "float32") </span><span class="cov0" title="0">{
                        s.SkipSpace()
                        s.notEOF()
                        *v = float32(s.convertFloat(s.floatToken(), 32))
                }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">case *float64:
                if s.okVerb(verb, floatVerbs, "float64") </span><span class="cov0" title="0">{
                        s.SkipSpace()
                        s.notEOF()
                        *v = s.convertFloat(s.floatToken(), 64)
                }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">case *string:
                *v = s.convertString(verb)</span>
        <span class="cov0" title="0">case *[]byte:
                // We scan to string and convert so we get a copy of the data.
                // If we scanned to bytes, the slice would point at the buffer.
                *v = []byte(s.convertString(verb))</span>
        <span class="cov0" title="0">default:
                val := reflect.ValueOf(v)
                ptr := val
                if ptr.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                        s.errorString("type not a pointer: " + val.Type().String())
                        return
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">switch v := ptr.Elem(); v.Kind() </span>{
                <span class="cov0" title="0">case reflect.Bool:
                        v.SetBool(s.scanBool(verb))</span>
                <span class="cov0" title="0">case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
                        v.SetInt(s.scanInt(verb, v.Type().Bits()))</span>
                <span class="cov0" title="0">case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
                        v.SetUint(s.scanUint(verb, v.Type().Bits()))</span>
                <span class="cov0" title="0">case reflect.String:
                        v.SetString(s.convertString(verb))</span>
                <span class="cov0" title="0">case reflect.Slice:
                        // For now, can only handle (renamed) []byte.
                        typ := v.Type()
                        if typ.Elem().Kind() != reflect.Uint8 </span><span class="cov0" title="0">{
                                s.errorString("can't scan type: " + val.Type().String())
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">str := s.convertString(verb)
                        v.Set(reflect.MakeSlice(typ, len(str), len(str)))
                        for i := 0; i &lt; len(str); i++ </span><span class="cov0" title="0">{
                                v.Index(i).SetUint(uint64(str[i]))
                        }</span>
                <span class="cov0" title="0">case reflect.Float32, reflect.Float64:
                        s.SkipSpace()
                        s.notEOF()
                        v.SetFloat(s.convertFloat(s.floatToken(), v.Type().Bits()))</span>
                <span class="cov0" title="0">case reflect.Complex64, reflect.Complex128:
                        v.SetComplex(s.scanComplex(verb, v.Type().Bits()))</span>
                <span class="cov0" title="0">default:
                        s.errorString("can't scan type: " + val.Type().String())</span>
                }
        }
}

// errorHandler turns local panics into error returns.
func errorHandler(errp *error) <span class="cov0" title="0">{
        if e := recover(); e != nil </span><span class="cov0" title="0">{
                if se, ok := e.(scanError); ok </span><span class="cov0" title="0">{ // catch local error
                        *errp = se.err
                }</span><span class="cov0" title="0"> else if eof, ok := e.(error); ok &amp;&amp; eof == io.EOF </span><span class="cov0" title="0">{ // out of input
                        *errp = eof
                }</span><span class="cov0" title="0"> else {
                        panic(e)</span>
                }
        }<span class="cov0" title="0">
</span>}

// doScan does the real work for scanning without a format string.
func (s *ss) doScan(a []interface{}) (numProcessed int, err error) <span class="cov0" title="0">{
        defer errorHandler(&amp;err)
        for _, arg := range a </span><span class="cov0" title="0">{
                s.scanOne('v', arg)
                numProcessed++
        }</span>
        // Check for newline (or EOF) if required (Scanln etc.).
        <span class="cov0" title="0">if s.nlIsEnd </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        r := s.getRune()
                        if r == '\n' || r == eof </span><span class="cov0" title="0">{
                                break</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">if !isSpace(r) </span><span class="cov0" title="0">{
                                s.errorString("expected newline")
                                break</span>
                        }<span class="cov0" title="0">
</span>                }
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">return</span>
}

// advance determines whether the next characters in the input match
// those of the format. It returns the number of bytes (sic) consumed
// in the format. All runs of space characters in either input or
// format behave as a single space. Newlines are special, though:
// newlines in the format must match those in the input and vice versa.
// This routine also handles the %% case. If the return value is zero,
// either format starts with a % (with no following %) or the input
// is empty. If it is negative, the input did not match the string.
func (s *ss) advance(format string) (i int) <span class="cov0" title="0">{
        for i &lt; len(format) </span><span class="cov0" title="0">{
                fmtc, w := utf8.DecodeRuneInString(format[i:])

                // Space processing.
                // In the rest of this comment "space" means spaces other than newline.
                // Newline in the format matches input of zero or more spaces and then newline or end-of-input.
                // Spaces in the format before the newline are collapsed into the newline.
                // Spaces in the format after the newline match zero or more spaces after the corresponding input newline.
                // Other spaces in the format match input of one or more spaces or end-of-input.
                if isSpace(fmtc) </span><span class="cov0" title="0">{
                        newlines := 0
                        trailingSpace := false
                        for isSpace(fmtc) &amp;&amp; i &lt; len(format) </span><span class="cov0" title="0">{
                                if fmtc == '\n' </span><span class="cov0" title="0">{
                                        newlines++
                                        trailingSpace = false
                                }</span><span class="cov0" title="0"> else {
                                        trailingSpace = true
                                }</span>
                                <span class="cov0" title="0">i += w
                                fmtc, w = utf8.DecodeRuneInString(format[i:])</span>
                        }
                        <span class="cov0" title="0">for j := 0; j &lt; newlines; j++ </span><span class="cov0" title="0">{
                                inputc := s.getRune()
                                for isSpace(inputc) &amp;&amp; inputc != '\n' </span><span class="cov0" title="0">{
                                        inputc = s.getRune()
                                }</span>
                                <span class="cov0" title="0">if inputc != '\n' &amp;&amp; inputc != eof </span><span class="cov0" title="0">{
                                        s.errorString("newline in format does not match input")
                                }</span><span class="cov0" title="0">
</span>                        }
                        <span class="cov0" title="0">if trailingSpace </span><span class="cov0" title="0">{
                                inputc := s.getRune()
                                if newlines == 0 </span><span class="cov0" title="0">{
                                        // If the trailing space stood alone (did not follow a newline),
                                        // it must find at least one space to consume.
                                        if !isSpace(inputc) &amp;&amp; inputc != eof </span><span class="cov0" title="0">{
                                                s.errorString("expected space in input to match format")
                                        }</span><span class="cov0" title="0">
</span>                                        <span class="cov0" title="0">if inputc == '\n' </span><span class="cov0" title="0">{
                                                s.errorString("newline in input does not match format")
                                        }</span><span class="cov0" title="0">
</span>                                }<span class="cov0" title="0">
</span>                                <span class="cov0" title="0">for isSpace(inputc) &amp;&amp; inputc != '\n' </span><span class="cov0" title="0">{
                                        inputc = s.getRune()
                                }</span>
                                <span class="cov0" title="0">if inputc != eof </span><span class="cov0" title="0">{
                                        s.UnreadRune()
                                }</span><span class="cov0" title="0">
</span>                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">continue</span>
                }<span class="cov0" title="0">
</span>
                // Verbs.
                <span class="cov0" title="0">if fmtc == '%' </span><span class="cov0" title="0">{
                        // % at end of string is an error.
                        if i+w == len(format) </span><span class="cov0" title="0">{
                                s.errorString("missing verb: % at end of format string")
                        }</span><span class="cov0" title="0">
</span>                        // %% acts like a real percent
                        <span class="cov0" title="0">nextc, _ := utf8.DecodeRuneInString(format[i+w:]) // will not match % if string is empty
                        if nextc != '%' </span><span class="cov0" title="0">{
                                return
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">i += w</span> // skip the first %
                }<span class="cov0" title="0">
</span>
                // Literals.
                <span class="cov0" title="0">inputc := s.mustReadRune()
                if fmtc != inputc </span><span class="cov0" title="0">{
                        s.UnreadRune()
                        return -1
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">i += w</span>
        }
        <span class="cov0" title="0">return</span>
}

// doScanf does the real work when scanning with a format string.
// At the moment, it handles only pointers to basic types.
func (s *ss) doScanf(format string, a []interface{}) (numProcessed int, err error) <span class="cov0" title="0">{
        defer errorHandler(&amp;err)
        end := len(format) - 1
        // We process one item per non-trivial format
        for i := 0; i &lt;= end; </span><span class="cov0" title="0">{
                w := s.advance(format[i:])
                if w &gt; 0 </span><span class="cov0" title="0">{
                        i += w
                        continue</span>
                }<span class="cov0" title="0">
</span>                // Either we failed to advance, we have a percent character, or we ran out of input.
                <span class="cov0" title="0">if format[i] != '%' </span><span class="cov0" title="0">{
                        // Can't advance format. Why not?
                        if w &lt; 0 </span><span class="cov0" title="0">{
                                s.errorString("input does not match format")
                        }</span><span class="cov0" title="0">
</span>                        // Otherwise at EOF; "too many operands" error handled below
                        <span class="cov0" title="0">break</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">i++ // % is one byte

                // do we have 20 (width)?
                var widPresent bool
                s.maxWid, widPresent, i = parsenum(format, i, end)
                if !widPresent </span><span class="cov0" title="0">{
                        s.maxWid = hugeWid
                }</span><span class="cov0" title="0">
</span>
                <span class="cov0" title="0">c, w := utf8.DecodeRuneInString(format[i:])
                i += w

                if c != 'c' </span><span class="cov0" title="0">{
                        s.SkipSpace()
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if c == '%' </span><span class="cov0" title="0">{
                        s.scanPercent()
                        continue</span> // Do not consume an argument.
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">s.argLimit = s.limit
                if f := s.count + s.maxWid; f &lt; s.argLimit </span><span class="cov0" title="0">{
                        s.argLimit = f
                }</span><span class="cov0" title="0">
</span>
                <span class="cov0" title="0">if numProcessed &gt;= len(a) </span><span class="cov0" title="0">{ // out of operands
                        s.errorString("too few operands for format '%" + format[i-w:] + "'")
                        break</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">arg := a[numProcessed]

                s.scanOne(c, arg)
                numProcessed++
                s.argLimit = s.limit</span>
        }
        <span class="cov0" title="0">if numProcessed &lt; len(a) </span><span class="cov0" title="0">{
                s.errorString("too many operands")
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris windows

package poll

import "syscall"

// SetsockoptInt wraps the setsockopt network call with an int argument.
func (fd *FD) SetsockoptInt(level, name, arg int) error <span class="cov0" title="0">{
        if err := fd.incref(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">defer fd.decref()
        return syscall.SetsockoptInt(fd.Sysfd, level, name, arg)</span>
}

// SetsockoptInet4Addr wraps the setsockopt network call with an IPv4 address.
func (fd *FD) SetsockoptInet4Addr(level, name int, arg [4]byte) error <span class="cov0" title="0">{
        if err := fd.incref(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">defer fd.decref()
        return syscall.SetsockoptInet4Addr(fd.Sysfd, level, name, arg)</span>
}

// SetsockoptLinger wraps the setsockopt network call with a Linger argument.
func (fd *FD) SetsockoptLinger(level, name int, l *syscall.Linger) error <span class="cov0" title="0">{
        if err := fd.incref(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">defer fd.decref()
        return syscall.SetsockoptLinger(fd.Sysfd, level, name, l)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package math

/*
        Floating-point error function and complementary error function.
*/

// The original C code and the long comment below are
// from FreeBSD's /usr/src/lib/msun/src/s_erf.c and
// came with this notice. The go code is a simplified
// version of the original C.
//
// ====================================================
// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
//
// Developed at SunPro, a Sun Microsystems, Inc. business.
// Permission to use, copy, modify, and distribute this
// software is freely granted, provided that this notice
// is preserved.
// ====================================================
//
//
// double erf(double x)
// double erfc(double x)
//                           x
//                    2      |\
//     erf(x)  =  ---------  | exp(-t*t)dt
//                 sqrt(pi) \|
//                           0
//
//     erfc(x) =  1-erf(x)
//  Note that
//              erf(-x) = -erf(x)
//              erfc(-x) = 2 - erfc(x)
//
// Method:
//      1. For |x| in [0, 0.84375]
//          erf(x)  = x + x*R(x**2)
//          erfc(x) = 1 - erf(x)           if x in [-.84375,0.25]
//                  = 0.5 + ((0.5-x)-x*R)  if x in [0.25,0.84375]
//         where R = P/Q where P is an odd poly of degree 8 and
//         Q is an odd poly of degree 10.
//                                               -57.90
//                      | R - (erf(x)-x)/x | &lt;= 2
//
//
//         Remark. The formula is derived by noting
//          erf(x) = (2/sqrt(pi))*(x - x**3/3 + x**5/10 - x**7/42 + ....)
//         and that
//          2/sqrt(pi) = 1.128379167095512573896158903121545171688
//         is close to one. The interval is chosen because the fix
//         point of erf(x) is near 0.6174 (i.e., erf(x)=x when x is
//         near 0.6174), and by some experiment, 0.84375 is chosen to
//         guarantee the error is less than one ulp for erf.
//
//      2. For |x| in [0.84375,1.25], let s = |x| - 1, and
//         c = 0.84506291151 rounded to single (24 bits)
//              erf(x)  = sign(x) * (c  + P1(s)/Q1(s))
//              erfc(x) = (1-c)  - P1(s)/Q1(s) if x &gt; 0
//                        1+(c+P1(s)/Q1(s))    if x &lt; 0
//              |P1/Q1 - (erf(|x|)-c)| &lt;= 2**-59.06
//         Remark: here we use the taylor series expansion at x=1.
//              erf(1+s) = erf(1) + s*Poly(s)
//                       = 0.845.. + P1(s)/Q1(s)
//         That is, we use rational approximation to approximate
//                      erf(1+s) - (c = (single)0.84506291151)
//         Note that |P1/Q1|&lt; 0.078 for x in [0.84375,1.25]
//         where
//              P1(s) = degree 6 poly in s
//              Q1(s) = degree 6 poly in s
//
//      3. For x in [1.25,1/0.35(~2.857143)],
//              erfc(x) = (1/x)*exp(-x*x-0.5625+R1/S1)
//              erf(x)  = 1 - erfc(x)
//         where
//              R1(z) = degree 7 poly in z, (z=1/x**2)
//              S1(z) = degree 8 poly in z
//
//      4. For x in [1/0.35,28]
//              erfc(x) = (1/x)*exp(-x*x-0.5625+R2/S2) if x &gt; 0
//                      = 2.0 - (1/x)*exp(-x*x-0.5625+R2/S2) if -6&lt;x&lt;0
//                      = 2.0 - tiny            (if x &lt;= -6)
//              erf(x)  = sign(x)*(1.0 - erfc(x)) if x &lt; 6, else
//              erf(x)  = sign(x)*(1.0 - tiny)
//         where
//              R2(z) = degree 6 poly in z, (z=1/x**2)
//              S2(z) = degree 7 poly in z
//
//      Note1:
//         To compute exp(-x*x-0.5625+R/S), let s be a single
//         precision number and s := x; then
//              -x*x = -s*s + (s-x)*(s+x)
//              exp(-x*x-0.5626+R/S) =
//                      exp(-s*s-0.5625)*exp((s-x)*(s+x)+R/S);
//      Note2:
//         Here 4 and 5 make use of the asymptotic series
//                        exp(-x*x)
//              erfc(x) ~ ---------- * ( 1 + Poly(1/x**2) )
//                        x*sqrt(pi)
//         We use rational approximation to approximate
//              g(s)=f(1/x**2) = log(erfc(x)*x) - x*x + 0.5625
//         Here is the error bound for R1/S1 and R2/S2
//              |R1/S1 - f(x)|  &lt; 2**(-62.57)
//              |R2/S2 - f(x)|  &lt; 2**(-61.52)
//
//      5. For inf &gt; x &gt;= 28
//              erf(x)  = sign(x) *(1 - tiny)  (raise inexact)
//              erfc(x) = tiny*tiny (raise underflow) if x &gt; 0
//                      = 2 - tiny if x&lt;0
//
//      7. Special case:
//              erf(0)  = 0, erf(inf)  = 1, erf(-inf) = -1,
//              erfc(0) = 1, erfc(inf) = 0, erfc(-inf) = 2,
//              erfc/erf(NaN) is NaN

const (
        erx = 8.45062911510467529297e-01 // 0x3FEB0AC160000000
        // Coefficients for approximation to  erf in [0, 0.84375]
        efx  = 1.28379167095512586316e-01  // 0x3FC06EBA8214DB69
        efx8 = 1.02703333676410069053e+00  // 0x3FF06EBA8214DB69
        pp0  = 1.28379167095512558561e-01  // 0x3FC06EBA8214DB68
        pp1  = -3.25042107247001499370e-01 // 0xBFD4CD7D691CB913
        pp2  = -2.84817495755985104766e-02 // 0xBF9D2A51DBD7194F
        pp3  = -5.77027029648944159157e-03 // 0xBF77A291236668E4
        pp4  = -2.37630166566501626084e-05 // 0xBEF8EAD6120016AC
        qq1  = 3.97917223959155352819e-01  // 0x3FD97779CDDADC09
        qq2  = 6.50222499887672944485e-02  // 0x3FB0A54C5536CEBA
        qq3  = 5.08130628187576562776e-03  // 0x3F74D022C4D36B0F
        qq4  = 1.32494738004321644526e-04  // 0x3F215DC9221C1A10
        qq5  = -3.96022827877536812320e-06 // 0xBED09C4342A26120
        // Coefficients for approximation to  erf  in [0.84375, 1.25]
        pa0 = -2.36211856075265944077e-03 // 0xBF6359B8BEF77538
        pa1 = 4.14856118683748331666e-01  // 0x3FDA8D00AD92B34D
        pa2 = -3.72207876035701323847e-01 // 0xBFD7D240FBB8C3F1
        pa3 = 3.18346619901161753674e-01  // 0x3FD45FCA805120E4
        pa4 = -1.10894694282396677476e-01 // 0xBFBC63983D3E28EC
        pa5 = 3.54783043256182359371e-02  // 0x3FA22A36599795EB
        pa6 = -2.16637559486879084300e-03 // 0xBF61BF380A96073F
        qa1 = 1.06420880400844228286e-01  // 0x3FBB3E6618EEE323
        qa2 = 5.40397917702171048937e-01  // 0x3FE14AF092EB6F33
        qa3 = 7.18286544141962662868e-02  // 0x3FB2635CD99FE9A7
        qa4 = 1.26171219808761642112e-01  // 0x3FC02660E763351F
        qa5 = 1.36370839120290507362e-02  // 0x3F8BEDC26B51DD1C
        qa6 = 1.19844998467991074170e-02  // 0x3F888B545735151D
        // Coefficients for approximation to  erfc in [1.25, 1/0.35]
        ra0 = -9.86494403484714822705e-03 // 0xBF843412600D6435
        ra1 = -6.93858572707181764372e-01 // 0xBFE63416E4BA7360
        ra2 = -1.05586262253232909814e+01 // 0xC0251E0441B0E726
        ra3 = -6.23753324503260060396e+01 // 0xC04F300AE4CBA38D
        ra4 = -1.62396669462573470355e+02 // 0xC0644CB184282266
        ra5 = -1.84605092906711035994e+02 // 0xC067135CEBCCABB2
        ra6 = -8.12874355063065934246e+01 // 0xC054526557E4D2F2
        ra7 = -9.81432934416914548592e+00 // 0xC023A0EFC69AC25C
        sa1 = 1.96512716674392571292e+01  // 0x4033A6B9BD707687
        sa2 = 1.37657754143519042600e+02  // 0x4061350C526AE721
        sa3 = 4.34565877475229228821e+02  // 0x407B290DD58A1A71
        sa4 = 6.45387271733267880336e+02  // 0x40842B1921EC2868
        sa5 = 4.29008140027567833386e+02  // 0x407AD02157700314
        sa6 = 1.08635005541779435134e+02  // 0x405B28A3EE48AE2C
        sa7 = 6.57024977031928170135e+00  // 0x401A47EF8E484A93
        sa8 = -6.04244152148580987438e-02 // 0xBFAEEFF2EE749A62
        // Coefficients for approximation to  erfc in [1/.35, 28]
        rb0 = -9.86494292470009928597e-03 // 0xBF84341239E86F4A
        rb1 = -7.99283237680523006574e-01 // 0xBFE993BA70C285DE
        rb2 = -1.77579549177547519889e+01 // 0xC031C209555F995A
        rb3 = -1.60636384855821916062e+02 // 0xC064145D43C5ED98
        rb4 = -6.37566443368389627722e+02 // 0xC083EC881375F228
        rb5 = -1.02509513161107724954e+03 // 0xC09004616A2E5992
        rb6 = -4.83519191608651397019e+02 // 0xC07E384E9BDC383F
        sb1 = 3.03380607434824582924e+01  // 0x403E568B261D5190
        sb2 = 3.25792512996573918826e+02  // 0x40745CAE221B9F0A
        sb3 = 1.53672958608443695994e+03  // 0x409802EB189D5118
        sb4 = 3.19985821950859553908e+03  // 0x40A8FFB7688C246A
        sb5 = 2.55305040643316442583e+03  // 0x40A3F219CEDF3BE6
        sb6 = 4.74528541206955367215e+02  // 0x407DA874E79FE763
        sb7 = -2.24409524465858183362e+01 // 0xC03670E242712D62
)

// Erf returns the error function of x.
//
// Special cases are:
//        Erf(+Inf) = 1
//        Erf(-Inf) = -1
//        Erf(NaN) = NaN
func Erf(x float64) float64

func erf(x float64) float64 <span class="cov0" title="0">{
        const (
                VeryTiny = 2.848094538889218e-306 // 0x0080000000000000
                Small    = 1.0 / (1 &lt;&lt; 28)        // 2**-28
        )
        // special cases
        switch </span>{
        <span class="cov0" title="0">case IsNaN(x):
                return NaN()</span>
        <span class="cov0" title="0">case IsInf(x, 1):
                return 1</span>
        <span class="cov0" title="0">case IsInf(x, -1):
                return -1</span>
        }
        <span class="cov0" title="0">sign := false
        if x &lt; 0 </span><span class="cov0" title="0">{
                x = -x
                sign = true
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if x &lt; 0.84375 </span><span class="cov0" title="0">{ // |x| &lt; 0.84375
                var temp float64
                if x &lt; Small </span><span class="cov0" title="0">{ // |x| &lt; 2**-28
                        if x &lt; VeryTiny </span><span class="cov0" title="0">{
                                temp = 0.125 * (8.0*x + efx8*x) // avoid underflow
                        }</span><span class="cov0" title="0"> else {
                                temp = x + efx*x
                        }</span>
                }<span class="cov0" title="0"> else {
                        z := x * x
                        r := pp0 + z*(pp1+z*(pp2+z*(pp3+z*pp4)))
                        s := 1 + z*(qq1+z*(qq2+z*(qq3+z*(qq4+z*qq5))))
                        y := r / s
                        temp = x + x*y
                }</span>
                <span class="cov0" title="0">if sign </span><span class="cov0" title="0">{
                        return -temp
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return temp</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if x &lt; 1.25 </span><span class="cov0" title="0">{ // 0.84375 &lt;= |x| &lt; 1.25
                s := x - 1
                P := pa0 + s*(pa1+s*(pa2+s*(pa3+s*(pa4+s*(pa5+s*pa6)))))
                Q := 1 + s*(qa1+s*(qa2+s*(qa3+s*(qa4+s*(qa5+s*qa6)))))
                if sign </span><span class="cov0" title="0">{
                        return -erx - P/Q
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return erx + P/Q</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if x &gt;= 6 </span><span class="cov0" title="0">{ // inf &gt; |x| &gt;= 6
                if sign </span><span class="cov0" title="0">{
                        return -1
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return 1</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">s := 1 / (x * x)
        var R, S float64
        if x &lt; 1/0.35 </span><span class="cov0" title="0">{ // |x| &lt; 1 / 0.35  ~ 2.857143
                R = ra0 + s*(ra1+s*(ra2+s*(ra3+s*(ra4+s*(ra5+s*(ra6+s*ra7))))))
                S = 1 + s*(sa1+s*(sa2+s*(sa3+s*(sa4+s*(sa5+s*(sa6+s*(sa7+s*sa8)))))))
        }</span><span class="cov0" title="0"> else { // |x| &gt;= 1 / 0.35  ~ 2.857143
                R = rb0 + s*(rb1+s*(rb2+s*(rb3+s*(rb4+s*(rb5+s*rb6)))))
                S = 1 + s*(sb1+s*(sb2+s*(sb3+s*(sb4+s*(sb5+s*(sb6+s*sb7))))))
        }</span>
        <span class="cov0" title="0">z := Float64frombits(Float64bits(x) &amp; 0xffffffff00000000) // pseudo-single (20-bit) precision x
        r := Exp(-z*z-0.5625) * Exp((z-x)*(z+x)+R/S)
        if sign </span><span class="cov0" title="0">{
                return r/x - 1
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return 1 - r/x</span>
}

// Erfc returns the complementary error function of x.
//
// Special cases are:
//        Erfc(+Inf) = 0
//        Erfc(-Inf) = 2
//        Erfc(NaN) = NaN
func Erfc(x float64) float64

func erfc(x float64) float64 <span class="cov0" title="0">{
        const Tiny = 1.0 / (1 &lt;&lt; 56) // 2**-56
        // special cases
        switch </span>{
        <span class="cov0" title="0">case IsNaN(x):
                return NaN()</span>
        <span class="cov0" title="0">case IsInf(x, 1):
                return 0</span>
        <span class="cov0" title="0">case IsInf(x, -1):
                return 2</span>
        }
        <span class="cov0" title="0">sign := false
        if x &lt; 0 </span><span class="cov0" title="0">{
                x = -x
                sign = true
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if x &lt; 0.84375 </span><span class="cov0" title="0">{ // |x| &lt; 0.84375
                var temp float64
                if x &lt; Tiny </span><span class="cov0" title="0">{ // |x| &lt; 2**-56
                        temp = x
                }</span><span class="cov0" title="0"> else {
                        z := x * x
                        r := pp0 + z*(pp1+z*(pp2+z*(pp3+z*pp4)))
                        s := 1 + z*(qq1+z*(qq2+z*(qq3+z*(qq4+z*qq5))))
                        y := r / s
                        if x &lt; 0.25 </span><span class="cov0" title="0">{ // |x| &lt; 1/4
                                temp = x + x*y
                        }</span><span class="cov0" title="0"> else {
                                temp = 0.5 + (x*y + (x - 0.5))
                        }</span>
                }
                <span class="cov0" title="0">if sign </span><span class="cov0" title="0">{
                        return 1 + temp
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return 1 - temp</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if x &lt; 1.25 </span><span class="cov0" title="0">{ // 0.84375 &lt;= |x| &lt; 1.25
                s := x - 1
                P := pa0 + s*(pa1+s*(pa2+s*(pa3+s*(pa4+s*(pa5+s*pa6)))))
                Q := 1 + s*(qa1+s*(qa2+s*(qa3+s*(qa4+s*(qa5+s*qa6)))))
                if sign </span><span class="cov0" title="0">{
                        return 1 + erx + P/Q
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return 1 - erx - P/Q</span>

        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if x &lt; 28 </span><span class="cov0" title="0">{ // |x| &lt; 28
                s := 1 / (x * x)
                var R, S float64
                if x &lt; 1/0.35 </span><span class="cov8" title="1">{ // |x| &lt; 1 / 0.35 ~ 2.857143
                        R = ra0 + s*(ra1+s*(ra2+s*(ra3+s*(ra4+s*(ra5+s*(ra6+s*ra7))))))
                        S = 1 + s*(sa1+s*(sa2+s*(sa3+s*(sa4+s*(sa5+s*(sa6+s*(sa7+s*sa8)))))))
                }</span><span class="cov0" title="0"> else { // |x| &gt;= 1 / 0.35 ~ 2.857143
                        if sign &amp;&amp; x &gt; 6 </span><span class="cov0" title="0">{
                                return 2 // x &lt; -6
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">R = rb0 + s*(rb1+s*(rb2+s*(rb3+s*(rb4+s*(rb5+s*rb6)))))
                        S = 1 + s*(sb1+s*(sb2+s*(sb3+s*(sb4+s*(sb5+s*(sb6+s*sb7))))))</span>
                }
                <span class="cov0" title="0">z := Float64frombits(Float64bits(x) &amp; 0xffffffff00000000) // pseudo-single (20-bit) precision x
                r := Exp(-z*z-0.5625) * Exp((z-x)*(z+x)+R/S)
                if sign </span><span class="cov0" title="0">{
                        return 2 - r/x
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return r / x</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if sign </span><span class="cov0" title="0">{
                return 2
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return 0</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package math

import "math/bits"

func zero(x uint64) uint64 <span class="cov0" title="0">{
        if x == 0 </span><span class="cov0" title="0">{
                return 1
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return 0</span>
        // branchless:
        // return ((x&gt;&gt;1 | x&amp;1) - 1) &gt;&gt; 63
}

func nonzero(x uint64) uint64 <span class="cov0" title="0">{
        if x != 0 </span><span class="cov0" title="0">{
                return 1
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return 0</span>
        // branchless:
        // return 1 - ((x&gt;&gt;1|x&amp;1)-1)&gt;&gt;63
}

func shl(u1, u2 uint64, n uint) (r1, r2 uint64) <span class="cov0" title="0">{
        r1 = u1&lt;&lt;n | u2&gt;&gt;(64-n) | u2&lt;&lt;(n-64)
        r2 = u2 &lt;&lt; n
        return
}</span>

func shr(u1, u2 uint64, n uint) (r1, r2 uint64) <span class="cov0" title="0">{
        r2 = u2&gt;&gt;n | u1&lt;&lt;(64-n) | u1&gt;&gt;(n-64)
        r1 = u1 &gt;&gt; n
        return
}</span>

// shrcompress compresses the bottom n+1 bits of the two-word
// value into a single bit. the result is equal to the value
// shifted to the right by n, except the result's 0th bit is
// set to the bitwise OR of the bottom n+1 bits.
func shrcompress(u1, u2 uint64, n uint) (r1, r2 uint64) <span class="cov0" title="0">{
        // TODO: Performance here is really sensitive to the
        // order/placement of these branches. n == 0 is common
        // enough to be in the fast path. Perhaps more measurement
        // needs to be done to find the optimal order/placement?
        switch </span>{
        <span class="cov0" title="0">case n == 0:
                return u1, u2</span>
        <span class="cov0" title="0">case n == 64:
                return 0, u1 | nonzero(u2)</span>
        <span class="cov0" title="0">case n &gt;= 128:
                return 0, nonzero(u1 | u2)</span>
        <span class="cov0" title="0">case n &lt; 64:
                r1, r2 = shr(u1, u2, n)
                r2 |= nonzero(u2 &amp; (1&lt;&lt;n - 1))</span>
        <span class="cov0" title="0">case n &lt; 128:
                r1, r2 = shr(u1, u2, n)
                r2 |= nonzero(u1&amp;(1&lt;&lt;(n-64)-1) | u2)</span>
        }
        <span class="cov0" title="0">return</span>
}

func lz(u1, u2 uint64) (l int32) <span class="cov0" title="0">{
        l = int32(bits.LeadingZeros64(u1))
        if l == 64 </span><span class="cov0" title="0">{
                l += int32(bits.LeadingZeros64(u2))
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return l</span>
}

// split splits b into sign, biased exponent, and mantissa.
// It adds the implicit 1 bit to the mantissa for normal values,
// and normalizes subnormal values.
func split(b uint64) (sign uint32, exp int32, mantissa uint64) <span class="cov0" title="0">{
        sign = uint32(b &gt;&gt; 63)
        exp = int32(b&gt;&gt;52) &amp; mask
        mantissa = b &amp; fracMask

        if exp == 0 </span><span class="cov0" title="0">{
                // Normalize value if subnormal.
                shift := uint(bits.LeadingZeros64(mantissa) - 11)
                mantissa &lt;&lt;= shift
                exp = 1 - int32(shift)
        }</span><span class="cov0" title="0"> else {
                // Add implicit 1 bit
                mantissa |= 1 &lt;&lt; 52
        }</span>
        <span class="cov0" title="0">return</span>
}

// FMA returns x * y + z, computed with only one rounding.
// (That is, FMA returns the fused multiply-add of x, y, and z.)
func FMA(x, y, z float64) float64 <span class="cov0" title="0">{
        bx, by, bz := Float64bits(x), Float64bits(y), Float64bits(z)

        // Inf or NaN or zero involved. At most one rounding will occur.
        if x == 0.0 || y == 0.0 || z == 0.0 || bx&amp;uvinf == uvinf || by&amp;uvinf == uvinf </span><span class="cov0" title="0">{
                return x*y + z
        }</span><span class="cov0" title="0">
</span>        // Handle non-finite z separately. Evaluating x*y+z where
        // x and y are finite, but z is infinite, should always result in z.
        <span class="cov0" title="0">if bz&amp;uvinf == uvinf </span><span class="cov0" title="0">{
                return z
        }</span><span class="cov0" title="0">
</span>
        // Inputs are (sub)normal.
        // Split x, y, z into sign, exponent, mantissa.
        <span class="cov0" title="0">xs, xe, xm := split(bx)
        ys, ye, ym := split(by)
        zs, ze, zm := split(bz)

        // Compute product p = x*y as sign, exponent, two-word mantissa.
        // Start with exponent. "is normal" bit isn't subtracted yet.
        pe := xe + ye - bias + 1

        // pm1:pm2 is the double-word mantissa for the product p.
        // Shift left to leave top bit in product. Effectively
        // shifts the 106-bit product to the left by 21.
        pm1, pm2 := bits.Mul64(xm&lt;&lt;10, ym&lt;&lt;11)
        zm1, zm2 := zm&lt;&lt;10, uint64(0)
        ps := xs ^ ys // product sign

        // normalize to 62nd bit
        is62zero := uint((^pm1 &gt;&gt; 62) &amp; 1)
        pm1, pm2 = shl(pm1, pm2, is62zero)
        pe -= int32(is62zero)

        // Swap addition operands so |p| &gt;= |z|
        if pe &lt; ze || (pe == ze &amp;&amp; (pm1 &lt; zm1 || (pm1 == zm1 &amp;&amp; pm2 &lt; zm2))) </span><span class="cov0" title="0">{
                ps, pe, pm1, pm2, zs, ze, zm1, zm2 = zs, ze, zm1, zm2, ps, pe, pm1, pm2
        }</span><span class="cov0" title="0">
</span>
        // Align significands
        <span class="cov0" title="0">zm1, zm2 = shrcompress(zm1, zm2, uint(pe-ze))

        // Compute resulting significands, normalizing if necessary.
        var m, c uint64
        if ps == zs </span><span class="cov0" title="0">{
                // Adding (pm1:pm2) + (zm1:zm2)
                pm2, c = bits.Add64(pm2, zm2, 0)
                pm1, _ = bits.Add64(pm1, zm1, c)
                pe -= int32(^pm1 &gt;&gt; 63)
                pm1, m = shrcompress(pm1, pm2, uint(64+pm1&gt;&gt;63))
        }</span><span class="cov0" title="0"> else {
                // Subtracting (pm1:pm2) - (zm1:zm2)
                // TODO: should we special-case cancellation?
                pm2, c = bits.Sub64(pm2, zm2, 0)
                pm1, _ = bits.Sub64(pm1, zm1, c)
                nz := lz(pm1, pm2)
                pe -= nz
                m, pm2 = shl(pm1, pm2, uint(nz-1))
                m |= nonzero(pm2)
        }</span>

        // Round and break ties to even
        <span class="cov0" title="0">if pe &gt; 1022+bias || pe == 1022+bias &amp;&amp; (m+1&lt;&lt;9)&gt;&gt;63 == 1 </span><span class="cov0" title="0">{
                // rounded value overflows exponent range
                return Float64frombits(uint64(ps)&lt;&lt;63 | uvinf)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if pe &lt; 0 </span><span class="cov0" title="0">{
                n := uint(-pe)
                m = m&gt;&gt;n | nonzero(m&amp;(1&lt;&lt;n-1))
                pe = 0
        }</span><span class="cov0" title="0">
</span>        <span class="cov8" title="1">m = ((m + 1&lt;&lt;9) &gt;&gt; 10) &amp; ^zero((m&amp;(1&lt;&lt;10-1))^1&lt;&lt;9)
        pe &amp;= -int32(nonzero(m))
        return Float64frombits(uint64(ps)&lt;&lt;63 + uint64(pe)&lt;&lt;52 + m)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package math

/*
        Bessel function of the first and second kinds of order one.
*/

// The original C code and the long comment below are
// from FreeBSD's /usr/src/lib/msun/src/e_j1.c and
// came with this notice. The go code is a simplified
// version of the original C.
//
// ====================================================
// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
//
// Developed at SunPro, a Sun Microsystems, Inc. business.
// Permission to use, copy, modify, and distribute this
// software is freely granted, provided that this notice
// is preserved.
// ====================================================
//
// __ieee754_j1(x), __ieee754_y1(x)
// Bessel function of the first and second kinds of order one.
// Method -- j1(x):
//      1. For tiny x, we use j1(x) = x/2 - x**3/16 + x**5/384 - ...
//      2. Reduce x to |x| since j1(x)=-j1(-x),  and
//         for x in (0,2)
//              j1(x) = x/2 + x*z*R0/S0,  where z = x*x;
//         (precision:  |j1/x - 1/2 - R0/S0 |&lt;2**-61.51 )
//         for x in (2,inf)
//              j1(x) = sqrt(2/(pi*x))*(p1(x)*cos(x1)-q1(x)*sin(x1))
//              y1(x) = sqrt(2/(pi*x))*(p1(x)*sin(x1)+q1(x)*cos(x1))
//         where x1 = x-3*pi/4. It is better to compute sin(x1),cos(x1)
//         as follow:
//              cos(x1) =  cos(x)cos(3pi/4)+sin(x)sin(3pi/4)
//                      =  1/sqrt(2) * (sin(x) - cos(x))
//              sin(x1) =  sin(x)cos(3pi/4)-cos(x)sin(3pi/4)
//                      = -1/sqrt(2) * (sin(x) + cos(x))
//         (To avoid cancellation, use
//              sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
//         to compute the worse one.)
//
//      3 Special cases
//              j1(nan)= nan
//              j1(0) = 0
//              j1(inf) = 0
//
// Method -- y1(x):
//      1. screen out x&lt;=0 cases: y1(0)=-inf, y1(x&lt;0)=NaN
//      2. For x&lt;2.
//         Since
//              y1(x) = 2/pi*(j1(x)*(ln(x/2)+Euler)-1/x-x/2+5/64*x**3-...)
//         therefore y1(x)-2/pi*j1(x)*ln(x)-1/x is an odd function.
//         We use the following function to approximate y1,
//              y1(x) = x*U(z)/V(z) + (2/pi)*(j1(x)*ln(x)-1/x), z= x**2
//         where for x in [0,2] (abs err less than 2**-65.89)
//              U(z) = U0[0] + U0[1]*z + ... + U0[4]*z**4
//              V(z) = 1  + v0[0]*z + ... + v0[4]*z**5
//         Note: For tiny x, 1/x dominate y1 and hence
//              y1(tiny) = -2/pi/tiny, (choose tiny&lt;2**-54)
//      3. For x&gt;=2.
//               y1(x) = sqrt(2/(pi*x))*(p1(x)*sin(x1)+q1(x)*cos(x1))
//         where x1 = x-3*pi/4. It is better to compute sin(x1),cos(x1)
//         by method mentioned above.

// J1 returns the order-one Bessel function of the first kind.
//
// Special cases are:
//        J1(±Inf) = 0
//        J1(NaN) = NaN
func J1(x float64) float64 <span class="cov0" title="0">{
        const (
                TwoM27 = 1.0 / (1 &lt;&lt; 27) // 2**-27 0x3e40000000000000
                Two129 = 1 &lt;&lt; 129        // 2**129 0x4800000000000000
                // R0/S0 on [0, 2]
                R00 = -6.25000000000000000000e-02 // 0xBFB0000000000000
                R01 = 1.40705666955189706048e-03  // 0x3F570D9F98472C61
                R02 = -1.59955631084035597520e-05 // 0xBEF0C5C6BA169668
                R03 = 4.96727999609584448412e-08  // 0x3E6AAAFA46CA0BD9
                S01 = 1.91537599538363460805e-02  // 0x3F939D0B12637E53
                S02 = 1.85946785588630915560e-04  // 0x3F285F56B9CDF664
                S03 = 1.17718464042623683263e-06  // 0x3EB3BFF8333F8498
                S04 = 5.04636257076217042715e-09  // 0x3E35AC88C97DFF2C
                S05 = 1.23542274426137913908e-11  // 0x3DAB2ACFCFB97ED8
        )
        // special cases
        switch </span>{
        <span class="cov0" title="0">case IsNaN(x):
                return x</span>
        <span class="cov0" title="0">case IsInf(x, 0) || x == 0:
                return 0</span>
        }

        <span class="cov0" title="0">sign := false
        if x &lt; 0 </span><span class="cov0" title="0">{
                x = -x
                sign = true
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if x &gt;= 2 </span><span class="cov0" title="0">{
                s, c := Sincos(x)
                ss := -s - c
                cc := s - c

                // make sure x+x does not overflow
                if x &lt; MaxFloat64/2 </span><span class="cov0" title="0">{
                        z := Cos(x + x)
                        if s*c &gt; 0 </span><span class="cov0" title="0">{
                                cc = z / ss
                        }</span><span class="cov0" title="0"> else {
                                ss = z / cc
                        }</span>
                }<span class="cov0" title="0">
</span>
                // j1(x) = 1/sqrt(pi) * (P(1,x)*cc - Q(1,x)*ss) / sqrt(x)
                // y1(x) = 1/sqrt(pi) * (P(1,x)*ss + Q(1,x)*cc) / sqrt(x)

                <span class="cov0" title="0">var z float64
                if x &gt; Two129 </span><span class="cov0" title="0">{
                        z = (1 / SqrtPi) * cc / Sqrt(x)
                }</span><span class="cov0" title="0"> else {
                        u := pone(x)
                        v := qone(x)
                        z = (1 / SqrtPi) * (u*cc - v*ss) / Sqrt(x)
                }</span>
                <span class="cov0" title="0">if sign </span><span class="cov0" title="0">{
                        return -z
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return z</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if x &lt; TwoM27 </span><span class="cov0" title="0">{ // |x|&lt;2**-27
                return 0.5 * x // inexact if x!=0 necessary
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">z := x * x
        r := z * (R00 + z*(R01+z*(R02+z*R03)))
        s := 1.0 + z*(S01+z*(S02+z*(S03+z*(S04+z*S05))))
        r *= x
        z = 0.5*x + r/s
        if sign </span><span class="cov0" title="0">{
                return -z
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return z</span>
}

// Y1 returns the order-one Bessel function of the second kind.
//
// Special cases are:
//        Y1(+Inf) = 0
//        Y1(0) = -Inf
//        Y1(x &lt; 0) = NaN
//        Y1(NaN) = NaN
func Y1(x float64) float64 <span class="cov0" title="0">{
        const (
                TwoM54 = 1.0 / (1 &lt;&lt; 54)             // 2**-54 0x3c90000000000000
                Two129 = 1 &lt;&lt; 129                    // 2**129 0x4800000000000000
                U00    = -1.96057090646238940668e-01 // 0xBFC91866143CBC8A
                U01    = 5.04438716639811282616e-02  // 0x3FA9D3C776292CD1
                U02    = -1.91256895875763547298e-03 // 0xBF5F55E54844F50F
                U03    = 2.35252600561610495928e-05  // 0x3EF8AB038FA6B88E
                U04    = -9.19099158039878874504e-08 // 0xBE78AC00569105B8
                V00    = 1.99167318236649903973e-02  // 0x3F94650D3F4DA9F0
                V01    = 2.02552581025135171496e-04  // 0x3F2A8C896C257764
                V02    = 1.35608801097516229404e-06  // 0x3EB6C05A894E8CA6
                V03    = 6.22741452364621501295e-09  // 0x3E3ABF1D5BA69A86
                V04    = 1.66559246207992079114e-11  // 0x3DB25039DACA772A
        )
        // special cases
        switch </span>{
        <span class="cov0" title="0">case x &lt; 0 || IsNaN(x):
                return NaN()</span>
        <span class="cov0" title="0">case IsInf(x, 1):
                return 0</span>
        <span class="cov0" title="0">case x == 0:
                return Inf(-1)</span>
        }

        <span class="cov0" title="0">if x &gt;= 2 </span><span class="cov0" title="0">{
                s, c := Sincos(x)
                ss := -s - c
                cc := s - c

                // make sure x+x does not overflow
                if x &lt; MaxFloat64/2 </span><span class="cov0" title="0">{
                        z := Cos(x + x)
                        if s*c &gt; 0 </span><span class="cov0" title="0">{
                                cc = z / ss
                        }</span><span class="cov0" title="0"> else {
                                ss = z / cc
                        }</span>
                }<span class="cov0" title="0">
</span>                // y1(x) = sqrt(2/(pi*x))*(p1(x)*sin(x0)+q1(x)*cos(x0))
                // where x0 = x-3pi/4
                //     Better formula:
                //         cos(x0) = cos(x)cos(3pi/4)+sin(x)sin(3pi/4)
                //                 =  1/sqrt(2) * (sin(x) - cos(x))
                //         sin(x0) = sin(x)cos(3pi/4)-cos(x)sin(3pi/4)
                //                 = -1/sqrt(2) * (cos(x) + sin(x))
                // To avoid cancellation, use
                //     sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
                // to compute the worse one.

                <span class="cov0" title="0">var z float64
                if x &gt; Two129 </span><span class="cov0" title="0">{
                        z = (1 / SqrtPi) * ss / Sqrt(x)
                }</span><span class="cov0" title="0"> else {
                        u := pone(x)
                        v := qone(x)
                        z = (1 / SqrtPi) * (u*ss + v*cc) / Sqrt(x)
                }</span>
                <span class="cov8" title="1">return z</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if x &lt;= TwoM54 </span><span class="cov0" title="0">{ // x &lt; 2**-54
                return -(2 / Pi) / x
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">z := x * x
        u := U00 + z*(U01+z*(U02+z*(U03+z*U04)))
        v := 1 + z*(V00+z*(V01+z*(V02+z*(V03+z*V04))))
        return x*(u/v) + (2/Pi)*(J1(x)*Log(x)-1/x)</span>
}

// For x &gt;= 8, the asymptotic expansions of pone is
//      1 + 15/128 s**2 - 4725/2**15 s**4 - ..., where s = 1/x.
// We approximate pone by
//      pone(x) = 1 + (R/S)
// where R = pr0 + pr1*s**2 + pr2*s**4 + ... + pr5*s**10
//       S = 1 + ps0*s**2 + ... + ps4*s**10
// and
//      | pone(x)-1-R/S | &lt;= 2**(-60.06)

// for x in [inf, 8]=1/[0,0.125]
var p1R8 = [6]float64{
        0.00000000000000000000e+00, // 0x0000000000000000
        1.17187499999988647970e-01, // 0x3FBDFFFFFFFFFCCE
        1.32394806593073575129e+01, // 0x402A7A9D357F7FCE
        4.12051854307378562225e+02, // 0x4079C0D4652EA590
        3.87474538913960532227e+03, // 0x40AE457DA3A532CC
        7.91447954031891731574e+03, // 0x40BEEA7AC32782DD
}
var p1S8 = [5]float64{
        1.14207370375678408436e+02, // 0x405C8D458E656CAC
        3.65093083420853463394e+03, // 0x40AC85DC964D274F
        3.69562060269033463555e+04, // 0x40E20B8697C5BB7F
        9.76027935934950801311e+04, // 0x40F7D42CB28F17BB
        3.08042720627888811578e+04, // 0x40DE1511697A0B2D
}

// for x in [8,4.5454] = 1/[0.125,0.22001]
var p1R5 = [6]float64{
        1.31990519556243522749e-11, // 0x3DAD0667DAE1CA7D
        1.17187493190614097638e-01, // 0x3FBDFFFFE2C10043
        6.80275127868432871736e+00, // 0x401B36046E6315E3
        1.08308182990189109773e+02, // 0x405B13B9452602ED
        5.17636139533199752805e+02, // 0x40802D16D052D649
        5.28715201363337541807e+02, // 0x408085B8BB7E0CB7
}
var p1S5 = [5]float64{
        5.92805987221131331921e+01, // 0x404DA3EAA8AF633D
        9.91401418733614377743e+02, // 0x408EFB361B066701
        5.35326695291487976647e+03, // 0x40B4E9445706B6FB
        7.84469031749551231769e+03, // 0x40BEA4B0B8A5BB15
        1.50404688810361062679e+03, // 0x40978030036F5E51
}

// for x in[4.5453,2.8571] = 1/[0.2199,0.35001]
var p1R3 = [6]float64{
        3.02503916137373618024e-09, // 0x3E29FC21A7AD9EDD
        1.17186865567253592491e-01, // 0x3FBDFFF55B21D17B
        3.93297750033315640650e+00, // 0x400F76BCE85EAD8A
        3.51194035591636932736e+01, // 0x40418F489DA6D129
        9.10550110750781271918e+01, // 0x4056C3854D2C1837
        4.85590685197364919645e+01, // 0x4048478F8EA83EE5
}
var p1S3 = [5]float64{
        3.47913095001251519989e+01, // 0x40416549A134069C
        3.36762458747825746741e+02, // 0x40750C3307F1A75F
        1.04687139975775130551e+03, // 0x40905B7C5037D523
        8.90811346398256432622e+02, // 0x408BD67DA32E31E9
        1.03787932439639277504e+02, // 0x4059F26D7C2EED53
}

// for x in [2.8570,2] = 1/[0.3499,0.5]
var p1R2 = [6]float64{
        1.07710830106873743082e-07, // 0x3E7CE9D4F65544F4
        1.17176219462683348094e-01, // 0x3FBDFF42BE760D83
        2.36851496667608785174e+00, // 0x4002F2B7F98FAEC0
        1.22426109148261232917e+01, // 0x40287C377F71A964
        1.76939711271687727390e+01, // 0x4031B1A8177F8EE2
        5.07352312588818499250e+00, // 0x40144B49A574C1FE
}
var p1S2 = [5]float64{
        2.14364859363821409488e+01, // 0x40356FBD8AD5ECDC
        1.25290227168402751090e+02, // 0x405F529314F92CD5
        2.32276469057162813669e+02, // 0x406D08D8D5A2DBD9
        1.17679373287147100768e+02, // 0x405D6B7ADA1884A9
        8.36463893371618283368e+00, // 0x4020BAB1F44E5192
}

func pone(x float64) float64 <span class="cov0" title="0">{
        var p *[6]float64
        var q *[5]float64
        if x &gt;= 8 </span><span class="cov0" title="0">{
                p = &amp;p1R8
                q = &amp;p1S8
        }</span><span class="cov0" title="0"> else if x &gt;= 4.5454 </span><span class="cov0" title="0">{
                p = &amp;p1R5
                q = &amp;p1S5
        }</span><span class="cov0" title="0"> else if x &gt;= 2.8571 </span><span class="cov0" title="0">{
                p = &amp;p1R3
                q = &amp;p1S3
        }</span><span class="cov0" title="0"> else if x &gt;= 2 </span><span class="cov0" title="0">{
                p = &amp;p1R2
                q = &amp;p1S2
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">z := 1 / (x * x)
        r := p[0] + z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))))
        s := 1.0 + z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*q[4]))))
        return 1 + r/s</span>
}

// For x &gt;= 8, the asymptotic expansions of qone is
//      3/8 s - 105/1024 s**3 - ..., where s = 1/x.
// We approximate qone by
//      qone(x) = s*(0.375 + (R/S))
// where R = qr1*s**2 + qr2*s**4 + ... + qr5*s**10
//       S = 1 + qs1*s**2 + ... + qs6*s**12
// and
//      | qone(x)/s -0.375-R/S | &lt;= 2**(-61.13)

// for x in [inf, 8] = 1/[0,0.125]
var q1R8 = [6]float64{
        0.00000000000000000000e+00,  // 0x0000000000000000
        -1.02539062499992714161e-01, // 0xBFBA3FFFFFFFFDF3
        -1.62717534544589987888e+01, // 0xC0304591A26779F7
        -7.59601722513950107896e+02, // 0xC087BCD053E4B576
        -1.18498066702429587167e+04, // 0xC0C724E740F87415
        -4.84385124285750353010e+04, // 0xC0E7A6D065D09C6A
}
var q1S8 = [6]float64{
        1.61395369700722909556e+02,  // 0x40642CA6DE5BCDE5
        7.82538599923348465381e+03,  // 0x40BE9162D0D88419
        1.33875336287249578163e+05,  // 0x4100579AB0B75E98
        7.19657723683240939863e+05,  // 0x4125F65372869C19
        6.66601232617776375264e+05,  // 0x412457D27719AD5C
        -2.94490264303834643215e+05, // 0xC111F9690EA5AA18
}

// for x in [8,4.5454] = 1/[0.125,0.22001]
var q1R5 = [6]float64{
        -2.08979931141764104297e-11, // 0xBDB6FA431AA1A098
        -1.02539050241375426231e-01, // 0xBFBA3FFFCB597FEF
        -8.05644828123936029840e+00, // 0xC0201CE6CA03AD4B
        -1.83669607474888380239e+02, // 0xC066F56D6CA7B9B0
        -1.37319376065508163265e+03, // 0xC09574C66931734F
        -2.61244440453215656817e+03, // 0xC0A468E388FDA79D
}
var q1S5 = [6]float64{
        8.12765501384335777857e+01,  // 0x405451B2FF5A11B2
        1.99179873460485964642e+03,  // 0x409F1F31E77BF839
        1.74684851924908907677e+04,  // 0x40D10F1F0D64CE29
        4.98514270910352279316e+04,  // 0x40E8576DAABAD197
        2.79480751638918118260e+04,  // 0x40DB4B04CF7C364B
        -4.71918354795128470869e+03, // 0xC0B26F2EFCFFA004
}

// for x in [4.5454,2.8571] = 1/[0.2199,0.35001] ???
var q1R3 = [6]float64{
        -5.07831226461766561369e-09, // 0xBE35CFA9D38FC84F
        -1.02537829820837089745e-01, // 0xBFBA3FEB51AEED54
        -4.61011581139473403113e+00, // 0xC01270C23302D9FF
        -5.78472216562783643212e+01, // 0xC04CEC71C25D16DA
        -2.28244540737631695038e+02, // 0xC06C87D34718D55F
        -2.19210128478909325622e+02, // 0xC06B66B95F5C1BF6
}
var q1S3 = [6]float64{
        4.76651550323729509273e+01,  // 0x4047D523CCD367E4
        6.73865112676699709482e+02,  // 0x40850EEBC031EE3E
        3.38015286679526343505e+03,  // 0x40AA684E448E7C9A
        5.54772909720722782367e+03,  // 0x40B5ABBAA61D54A6
        1.90311919338810798763e+03,  // 0x409DBC7A0DD4DF4B
        -1.35201191444307340817e+02, // 0xC060E670290A311F
}

// for x in [2.8570,2] = 1/[0.3499,0.5]
var q1R2 = [6]float64{
        -1.78381727510958865572e-07, // 0xBE87F12644C626D2
        -1.02517042607985553460e-01, // 0xBFBA3E8E9148B010
        -2.75220568278187460720e+00, // 0xC006048469BB4EDA
        -1.96636162643703720221e+01, // 0xC033A9E2C168907F
        -4.23253133372830490089e+01, // 0xC04529A3DE104AAA
        -2.13719211703704061733e+01, // 0xC0355F3639CF6E52
}
var q1S2 = [6]float64{
        2.95333629060523854548e+01,  // 0x403D888A78AE64FF
        2.52981549982190529136e+02,  // 0x406F9F68DB821CBA
        7.57502834868645436472e+02,  // 0x4087AC05CE49A0F7
        7.39393205320467245656e+02,  // 0x40871B2548D4C029
        1.55949003336666123687e+02,  // 0x40637E5E3C3ED8D4
        -4.95949898822628210127e+00, // 0xC013D686E71BE86B
}

func qone(x float64) float64 <span class="cov0" title="0">{
        var p, q *[6]float64
        if x &gt;= 8 </span><span class="cov0" title="0">{
                p = &amp;q1R8
                q = &amp;q1S8
        }</span><span class="cov0" title="0"> else if x &gt;= 4.5454 </span><span class="cov0" title="0">{
                p = &amp;q1R5
                q = &amp;q1S5
        }</span><span class="cov0" title="0"> else if x &gt;= 2.8571 </span><span class="cov0" title="0">{
                p = &amp;q1R3
                q = &amp;q1S3
        }</span><span class="cov0" title="0"> else if x &gt;= 2 </span><span class="cov0" title="0">{
                p = &amp;q1R2
                q = &amp;q1S2
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">z := 1 / (x * x)
        r := p[0] + z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))))
        s := 1 + z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*(q[4]+z*q[5])))))
        return (0.375 + r/s) / x</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package math

// Ldexp is the inverse of Frexp.
// It returns frac × 2**exp.
//
// Special cases are:
//        Ldexp(±0, exp) = ±0
//        Ldexp(±Inf, exp) = ±Inf
//        Ldexp(NaN, exp) = NaN
func Ldexp(frac float64, exp int) float64

func ldexp(frac float64, exp int) float64 <span class="cov8" title="1">{
        // special cases
        switch </span>{
        <span class="cov0" title="0">case frac == 0:
                return frac</span> // correctly return -0
        <span class="cov0" title="0">case IsInf(frac, 0) || IsNaN(frac):
                return frac</span>
        }
        <span class="cov0" title="0">frac, e := normalize(frac)
        exp += e
        x := Float64bits(frac)
        exp += int(x&gt;&gt;shift)&amp;mask - bias
        if exp &lt; -1075 </span><span class="cov0" title="0">{
                return Copysign(0, frac) // underflow
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if exp &gt; 1023 </span><span class="cov0" title="0">{ // overflow
                if frac &lt; 0 </span><span class="cov0" title="0">{
                        return Inf(-1)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return Inf(1)</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">var m float64 = 1
        if exp &lt; -1022 </span><span class="cov0" title="0">{ // denormal
                exp += 53
                m = 1.0 / (1 &lt;&lt; 53) // 2**-53
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">x &amp;^= mask &lt;&lt; shift
        x |= uint64(exp+bias) &lt;&lt; shift
        return m * Float64frombits(x)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package math

/*
        Floating-point logarithm.
*/

// The original C code, the long comment, and the constants
// below are from FreeBSD's /usr/src/lib/msun/src/e_log.c
// and came with this notice. The go code is a simpler
// version of the original C.
//
// ====================================================
// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
//
// Developed at SunPro, a Sun Microsystems, Inc. business.
// Permission to use, copy, modify, and distribute this
// software is freely granted, provided that this notice
// is preserved.
// ====================================================
//
// __ieee754_log(x)
// Return the logarithm of x
//
// Method :
//   1. Argument Reduction: find k and f such that
//                        x = 2**k * (1+f),
//           where  sqrt(2)/2 &lt; 1+f &lt; sqrt(2) .
//
//   2. Approximation of log(1+f).
//        Let s = f/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)
//                 = 2s + 2/3 s**3 + 2/5 s**5 + .....,
//                      = 2s + s*R
//      We use a special Reme algorithm on [0,0.1716] to generate
//        a polynomial of degree 14 to approximate R.  The maximum error
//        of this polynomial approximation is bounded by 2**-58.45. In
//        other words,
//                        2      4      6      8      10      12      14
//            R(z) ~ L1*s +L2*s +L3*s +L4*s +L5*s  +L6*s  +L7*s
//        (the values of L1 to L7 are listed in the program) and
//            |      2          14          |     -58.45
//            | L1*s +...+L7*s    -  R(z) | &lt;= 2
//            |                             |
//        Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f/2.
//        In order to guarantee error in log below 1ulp, we compute log by
//                log(1+f) = f - s*(f - R)                (if f is not too large)
//                log(1+f) = f - (hfsq - s*(hfsq+R)).        (better accuracy)
//
//        3. Finally,  log(x) = k*Ln2 + log(1+f).
//                            = k*Ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*Ln2_lo)))
//           Here Ln2 is split into two floating point number:
//                        Ln2_hi + Ln2_lo,
//           where n*Ln2_hi is always exact for |n| &lt; 2000.
//
// Special cases:
//        log(x) is NaN with signal if x &lt; 0 (including -INF) ;
//        log(+INF) is +INF; log(0) is -INF with signal;
//        log(NaN) is that NaN with no signal.
//
// Accuracy:
//        according to an error analysis, the error is always less than
//        1 ulp (unit in the last place).
//
// Constants:
// The hexadecimal values are the intended ones for the following
// constants. The decimal values may be used, provided that the
// compiler will convert from decimal to binary accurately enough
// to produce the hexadecimal values shown.

// Log returns the natural logarithm of x.
//
// Special cases are:
//        Log(+Inf) = +Inf
//        Log(0) = -Inf
//        Log(x &lt; 0) = NaN
//        Log(NaN) = NaN
func Log(x float64) float64

func log(x float64) float64 <span class="cov0" title="0">{
        const (
                Ln2Hi = 6.93147180369123816490e-01 /* 3fe62e42 fee00000 */
                Ln2Lo = 1.90821492927058770002e-10 /* 3dea39ef 35793c76 */
                L1    = 6.666666666666735130e-01   /* 3FE55555 55555593 */
                L2    = 3.999999999940941908e-01   /* 3FD99999 9997FA04 */
                L3    = 2.857142874366239149e-01   /* 3FD24924 94229359 */
                L4    = 2.222219843214978396e-01   /* 3FCC71C5 1D8E78AF */
                L5    = 1.818357216161805012e-01   /* 3FC74664 96CB03DE */
                L6    = 1.531383769920937332e-01   /* 3FC39A09 D078C69F */
                L7    = 1.479819860511658591e-01   /* 3FC2F112 DF3E5244 */
        )

        // special cases
        switch </span>{
        <span class="cov0" title="0">case IsNaN(x) || IsInf(x, 1):
                return x</span>
        <span class="cov0" title="0">case x &lt; 0:
                return NaN()</span>
        <span class="cov0" title="0">case x == 0:
                return Inf(-1)</span>
        }

        // reduce
        <span class="cov0" title="0">f1, ki := Frexp(x)
        if f1 &lt; Sqrt2/2 </span><span class="cov0" title="0">{
                f1 *= 2
                ki--
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">f := f1 - 1
        k := float64(ki)

        // compute
        s := f / (2 + f)
        s2 := s * s
        s4 := s2 * s2
        t1 := s2 * (L1 + s4*(L3+s4*(L5+s4*L7)))
        t2 := s4 * (L2 + s4*(L4+s4*L6))
        R := t1 + t2
        hfsq := 0.5 * f * f
        return k*Ln2Hi - ((hfsq - (s*(hfsq+R) + k*Ln2Lo)) - f)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package math

// The original C code and the comment below are from
// FreeBSD's /usr/src/lib/msun/src/e_remainder.c and came
// with this notice. The go code is a simplified version of
// the original C.
//
// ====================================================
// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
//
// Developed at SunPro, a Sun Microsystems, Inc. business.
// Permission to use, copy, modify, and distribute this
// software is freely granted, provided that this notice
// is preserved.
// ====================================================
//
// __ieee754_remainder(x,y)
// Return :
//      returns  x REM y  =  x - [x/y]*y  as if in infinite
//      precision arithmetic, where [x/y] is the (infinite bit)
//      integer nearest x/y (in half way cases, choose the even one).
// Method :
//      Based on Mod() returning  x - [x/y]chopped * y  exactly.

// Remainder returns the IEEE 754 floating-point remainder of x/y.
//
// Special cases are:
//        Remainder(±Inf, y) = NaN
//        Remainder(NaN, y) = NaN
//        Remainder(x, 0) = NaN
//        Remainder(x, ±Inf) = x
//        Remainder(x, NaN) = NaN
func Remainder(x, y float64) float64

func remainder(x, y float64) float64 <span class="cov0" title="0">{
        const (
                Tiny    = 4.45014771701440276618e-308 // 0x0020000000000000
                HalfMax = MaxFloat64 / 2
        )
        // special cases
        switch </span>{
        <span class="cov0" title="0">case IsNaN(x) || IsNaN(y) || IsInf(x, 0) || y == 0:
                return NaN()</span>
        <span class="cov0" title="0">case IsInf(y, 0):
                return x</span>
        }
        <span class="cov0" title="0">sign := false
        if x &lt; 0 </span><span class="cov0" title="0">{
                x = -x
                sign = true
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if y &lt; 0 </span><span class="cov0" title="0">{
                y = -y
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if x == y </span><span class="cov0" title="0">{
                if sign </span><span class="cov0" title="0">{
                        zero := 0.0
                        return -zero
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return 0</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if y &lt;= HalfMax </span><span class="cov0" title="0">{
                x = Mod(x, y+y) // now x &lt; 2y
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if y &lt; Tiny </span><span class="cov0" title="0">{
                if x+x &gt; y </span><span class="cov0" title="0">{
                        x -= y
                        if x+x &gt;= y </span><span class="cov0" title="0">{
                                x -= y
                        }</span><span class="cov0" title="0">
</span>                }<span class="cov0" title="0">
</span>        }<span class="cov0" title="0"> else {
                yHalf := 0.5 * y
                if x &gt; yHalf </span><span class="cov0" title="0">{
                        x -= y
                        if x &gt;= yHalf </span><span class="cov0" title="0">{
                                x -= y
                        }</span><span class="cov0" title="0">
</span>                }<span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">if sign </span><span class="cov0" title="0">{
                x = -x
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return x</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package math

/*
        Floating-point sine and cosine.
*/

// The original C code, the long comment, and the constants
// below were from http://netlib.sandia.gov/cephes/cmath/sin.c,
// available from http://www.netlib.org/cephes/cmath.tgz.
// The go code is a simplified version of the original C.
//
//      sin.c
//
//      Circular sine
//
// SYNOPSIS:
//
// double x, y, sin();
// y = sin( x );
//
// DESCRIPTION:
//
// Range reduction is into intervals of pi/4.  The reduction error is nearly
// eliminated by contriving an extended precision modular arithmetic.
//
// Two polynomial approximating functions are employed.
// Between 0 and pi/4 the sine is approximated by
//      x  +  x**3 P(x**2).
// Between pi/4 and pi/2 the cosine is represented as
//      1  -  x**2 Q(x**2).
//
// ACCURACY:
//
//                      Relative error:
// arithmetic   domain      # trials      peak         rms
//    DEC       0, 10       150000       3.0e-17     7.8e-18
//    IEEE -1.07e9,+1.07e9  130000       2.1e-16     5.4e-17
//
// Partial loss of accuracy begins to occur at x = 2**30 = 1.074e9.  The loss
// is not gradual, but jumps suddenly to about 1 part in 10e7.  Results may
// be meaningless for x &gt; 2**49 = 5.6e14.
//
//      cos.c
//
//      Circular cosine
//
// SYNOPSIS:
//
// double x, y, cos();
// y = cos( x );
//
// DESCRIPTION:
//
// Range reduction is into intervals of pi/4.  The reduction error is nearly
// eliminated by contriving an extended precision modular arithmetic.
//
// Two polynomial approximating functions are employed.
// Between 0 and pi/4 the cosine is approximated by
//      1  -  x**2 Q(x**2).
// Between pi/4 and pi/2 the sine is represented as
//      x  +  x**3 P(x**2).
//
// ACCURACY:
//
//                      Relative error:
// arithmetic   domain      # trials      peak         rms
//    IEEE -1.07e9,+1.07e9  130000       2.1e-16     5.4e-17
//    DEC        0,+1.07e9   17000       3.0e-17     7.2e-18
//
// Cephes Math Library Release 2.8:  June, 2000
// Copyright 1984, 1987, 1989, 1992, 2000 by Stephen L. Moshier
//
// The readme file at http://netlib.sandia.gov/cephes/ says:
//    Some software in this archive may be from the book _Methods and
// Programs for Mathematical Functions_ (Prentice-Hall or Simon &amp; Schuster
// International, 1989) or from the Cephes Mathematical Library, a
// commercial product. In either event, it is copyrighted by the author.
// What you see here may be used freely but it comes with no support or
// guarantee.
//
//   The two known misprints in the book are repaired here in the
// source listings for the gamma function and the incomplete beta
// integral.
//
//   Stephen L. Moshier
//   moshier@na-net.ornl.gov

// sin coefficients
var _sin = [...]float64{
        1.58962301576546568060e-10, // 0x3de5d8fd1fd19ccd
        -2.50507477628578072866e-8, // 0xbe5ae5e5a9291f5d
        2.75573136213857245213e-6,  // 0x3ec71de3567d48a1
        -1.98412698295895385996e-4, // 0xbf2a01a019bfdf03
        8.33333333332211858878e-3,  // 0x3f8111111110f7d0
        -1.66666666666666307295e-1, // 0xbfc5555555555548
}

// cos coefficients
var _cos = [...]float64{
        -1.13585365213876817300e-11, // 0xbda8fa49a0861a9b
        2.08757008419747316778e-9,   // 0x3e21ee9d7b4e3f05
        -2.75573141792967388112e-7,  // 0xbe927e4f7eac4bc6
        2.48015872888517045348e-5,   // 0x3efa01a019c844f5
        -1.38888888888730564116e-3,  // 0xbf56c16c16c14f91
        4.16666666666665929218e-2,   // 0x3fa555555555554b
}

// Cos returns the cosine of the radian argument x.
//
// Special cases are:
//        Cos(±Inf) = NaN
//        Cos(NaN) = NaN
func Cos(x float64) float64

func cos(x float64) float64 <span class="cov0" title="0">{
        const (
                PI4A = 7.85398125648498535156e-1  // 0x3fe921fb40000000, Pi/4 split into three parts
                PI4B = 3.77489470793079817668e-8  // 0x3e64442d00000000,
                PI4C = 2.69515142907905952645e-15 // 0x3ce8469898cc5170,
        )
        // special cases
        switch </span>{
        <span class="cov0" title="0">case IsNaN(x) || IsInf(x, 0):
                return NaN()</span>
        }

        // make argument positive
        <span class="cov0" title="0">sign := false
        x = Abs(x)

        var j uint64
        var y, z float64
        if x &gt;= reduceThreshold </span><span class="cov0" title="0">{
                j, z = trigReduce(x)
        }</span><span class="cov0" title="0"> else {
                j = uint64(x * (4 / Pi)) // integer part of x/(Pi/4), as integer for tests on the phase angle
                y = float64(j)           // integer part of x/(Pi/4), as float

                // map zeros to origin
                if j&amp;1 == 1 </span><span class="cov0" title="0">{
                        j++
                        y++
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">j &amp;= 7                               // octant modulo 2Pi radians (360 degrees)
                z = ((x - y*PI4A) - y*PI4B) - y*PI4C</span> // Extended precision modular arithmetic
        }

        <span class="cov0" title="0">if j &gt; 3 </span><span class="cov0" title="0">{
                j -= 4
                sign = !sign
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if j &gt; 1 </span><span class="cov0" title="0">{
                sign = !sign
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">zz := z * z
        if j == 1 || j == 2 </span><span class="cov0" title="0">{
                y = z + z*zz*((((((_sin[0]*zz)+_sin[1])*zz+_sin[2])*zz+_sin[3])*zz+_sin[4])*zz+_sin[5])
        }</span><span class="cov0" title="0"> else {
                y = 1.0 - 0.5*zz + zz*zz*((((((_cos[0]*zz)+_cos[1])*zz+_cos[2])*zz+_cos[3])*zz+_cos[4])*zz+_cos[5])
        }</span>
        <span class="cov0" title="0">if sign </span><span class="cov0" title="0">{
                y = -y
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return y</span>
}

// Sin returns the sine of the radian argument x.
//
// Special cases are:
//        Sin(±0) = ±0
//        Sin(±Inf) = NaN
//        Sin(NaN) = NaN
func Sin(x float64) float64

func sin(x float64) float64 <span class="cov0" title="0">{
        const (
                PI4A = 7.85398125648498535156e-1  // 0x3fe921fb40000000, Pi/4 split into three parts
                PI4B = 3.77489470793079817668e-8  // 0x3e64442d00000000,
                PI4C = 2.69515142907905952645e-15 // 0x3ce8469898cc5170,
        )
        // special cases
        switch </span>{
        <span class="cov0" title="0">case x == 0 || IsNaN(x):
                return x</span> // return ±0 || NaN()
        <span class="cov0" title="0">case IsInf(x, 0):
                return NaN()</span>
        }

        // make argument positive but save the sign
        <span class="cov0" title="0">sign := false
        if x &lt; 0 </span><span class="cov0" title="0">{
                x = -x
                sign = true
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">var j uint64
        var y, z float64
        if x &gt;= reduceThreshold </span><span class="cov0" title="0">{
                j, z = trigReduce(x)
        }</span><span class="cov0" title="0"> else {
                j = uint64(x * (4 / Pi)) // integer part of x/(Pi/4), as integer for tests on the phase angle
                y = float64(j)           // integer part of x/(Pi/4), as float

                // map zeros to origin
                if j&amp;1 == 1 </span><span class="cov0" title="0">{
                        j++
                        y++
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">j &amp;= 7                               // octant modulo 2Pi radians (360 degrees)
                z = ((x - y*PI4A) - y*PI4B) - y*PI4C</span> // Extended precision modular arithmetic
        }
        // reflect in x axis
        <span class="cov0" title="0">if j &gt; 3 </span><span class="cov0" title="0">{
                sign = !sign
                j -= 4
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">zz := z * z
        if j == 1 || j == 2 </span><span class="cov0" title="0">{
                y = 1.0 - 0.5*zz + zz*zz*((((((_cos[0]*zz)+_cos[1])*zz+_cos[2])*zz+_cos[3])*zz+_cos[4])*zz+_cos[5])
        }</span><span class="cov0" title="0"> else {
                y = z + z*zz*((((((_sin[0]*zz)+_sin[1])*zz+_sin[2])*zz+_sin[3])*zz+_sin[4])*zz+_sin[5])
        }</span>
        <span class="cov0" title="0">if sign </span><span class="cov0" title="0">{
                y = -y
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return y</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package url parses URLs and implements query escaping.
package url

// See RFC 3986. This package generally follows RFC 3986, except where
// it deviates for compatibility reasons. When sending changes, first
// search old issues for history on decisions. Unit tests should also
// contain references to issue numbers with details.

import (
        "errors"
        "fmt"
        "sort"
        "strconv"
        "strings"
)

// Error reports an error and the operation and URL that caused it.
type Error struct {
        Op  string
        URL string
        Err error
}

func (e *Error) Unwrap() error <span class="cov0" title="0">{ return e.Err }</span>
func (e *Error) Error() string <span class="cov0" title="0">{ return fmt.Sprintf("%s %q: %s", e.Op, e.URL, e.Err) }</span>

func (e *Error) Timeout() bool <span class="cov0" title="0">{
        t, ok := e.Err.(interface {
                Timeout() bool
        })
        return ok &amp;&amp; t.Timeout()
}</span>

func (e *Error) Temporary() bool <span class="cov0" title="0">{
        t, ok := e.Err.(interface {
                Temporary() bool
        })
        return ok &amp;&amp; t.Temporary()
}</span>

const upperhex = "0123456789ABCDEF"

func ishex(c byte) bool <span class="cov8" title="1">{
        switch </span>{
        <span class="cov8" title="1">case '0' &lt;= c &amp;&amp; c &lt;= '9':
                return true</span>
        <span class="cov8" title="1">case 'a' &lt;= c &amp;&amp; c &lt;= 'f':
                return true</span>
        <span class="cov8" title="1">case 'A' &lt;= c &amp;&amp; c &lt;= 'F':
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

func unhex(c byte) byte <span class="cov8" title="1">{
        switch </span>{
        <span class="cov8" title="1">case '0' &lt;= c &amp;&amp; c &lt;= '9':
                return c - '0'</span>
        <span class="cov8" title="1">case 'a' &lt;= c &amp;&amp; c &lt;= 'f':
                return c - 'a' + 10</span>
        <span class="cov8" title="1">case 'A' &lt;= c &amp;&amp; c &lt;= 'F':
                return c - 'A' + 10</span>
        }
        <span class="cov0" title="0">return 0</span>
}

type encoding int

const (
        encodePath encoding = 1 + iota
        encodePathSegment
        encodeHost
        encodeZone
        encodeUserPassword
        encodeQueryComponent
        encodeFragment
)

type EscapeError string

func (e EscapeError) Error() string <span class="cov0" title="0">{
        return "invalid URL escape " + strconv.Quote(string(e))
}</span>

type InvalidHostError string

func (e InvalidHostError) Error() string <span class="cov0" title="0">{
        return "invalid character " + strconv.Quote(string(e)) + " in host name"
}</span>

// Return true if the specified character should be escaped when
// appearing in a URL string, according to RFC 3986.
//
// Please be informed that for now shouldEscape does not check all
// reserved characters correctly. See golang.org/issue/5684.
func shouldEscape(c byte, mode encoding) bool <span class="cov8" title="1">{
        // §2.3 Unreserved characters (alphanum)
        if 'a' &lt;= c &amp;&amp; c &lt;= 'z' || 'A' &lt;= c &amp;&amp; c &lt;= 'Z' || '0' &lt;= c &amp;&amp; c &lt;= '9' </span><span class="cov8" title="1">{
                return false
        }</span><span class="cov8" title="1">
</span>
        <span class="cov8" title="1">if mode == encodeHost || mode == encodeZone </span><span class="cov8" title="1">{
                // §3.2.2 Host allows
                //        sub-delims = "!" / "$" / "&amp;" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
                // as part of reg-name.
                // We add : because we include :port as part of host.
                // We add [ ] because we include [ipv6]:port as part of host.
                // We add &lt; &gt; because they're the only characters left that
                // we could possibly allow, and Parse will reject them if we
                // escape them (because hosts can't use %-encoding for
                // ASCII bytes).
                switch c </span>{
                <span class="cov8" title="1">case '!', '$', '&amp;', '\'', '(', ')', '*', '+', ',', ';', '=', ':', '[', ']', '&lt;', '&gt;', '"':
                        return false</span>
                }
        }<span class="cov8" title="1">
</span>
        <span class="cov8" title="1">switch c </span>{
        <span class="cov8" title="1">case '-', '_', '.', '~': // §2.3 Unreserved characters (mark)
                return false</span>

        <span class="cov8" title="1">case '$', '&amp;', '+', ',', '/', ':', ';', '=', '?', '@': // §2.2 Reserved characters (reserved)
                // Different sections of the URL allow a few of
                // the reserved characters to appear unescaped.
                switch mode </span>{
                <span class="cov8" title="1">case encodePath: // §3.3
                        // The RFC allows : @ &amp; = + $ but saves / ; , for assigning
                        // meaning to individual path segments. This package
                        // only manipulates the path as a whole, so we allow those
                        // last three as well. That leaves only ? to escape.
                        return c == '?'</span>

                <span class="cov0" title="0">case encodePathSegment: // §3.3
                        // The RFC allows : @ &amp; = + $ but saves / ; , for assigning
                        // meaning to individual path segments.
                        return c == '/' || c == ';' || c == ',' || c == '?'</span>

                <span class="cov0" title="0">case encodeUserPassword: // §3.2.1
                        // The RFC allows ';', ':', '&amp;', '=', '+', '$', and ',' in
                        // userinfo, so we must escape only '@', '/', and '?'.
                        // The parsing of userinfo treats ':' as special so we must escape
                        // that too.
                        return c == '@' || c == '/' || c == '?' || c == ':'</span>

                <span class="cov0" title="0">case encodeQueryComponent: // §3.4
                        // The RFC reserves (so we must escape) everything.
                        return true</span>

                <span class="cov8" title="1">case encodeFragment: // §4.1
                        // The RFC text is silent but the grammar allows
                        // everything, so escape nothing.
                        return false</span>
                }
        }

        <span class="cov8" title="1">if mode == encodeFragment </span><span class="cov8" title="1">{
                // RFC 3986 §2.2 allows not escaping sub-delims. A subset of sub-delims are
                // included in reserved from RFC 2396 §2.2. The remaining sub-delims do not
                // need to be escaped. To minimize potential breakage, we apply two restrictions:
                // (1) we always escape sub-delims outside of the fragment, and (2) we always
                // escape single quote to avoid breaking callers that had previously assumed that
                // single quotes would be escaped. See issue #19917.
                switch c </span>{
                <span class="cov8" title="1">case '!', '(', ')', '*':
                        return false</span>
                }
        }<span class="cov8" title="1">
</span>
        // Everything else must be escaped.
        <span class="cov8" title="1">return true</span>
}

// QueryUnescape does the inverse transformation of QueryEscape,
// converting each 3-byte encoded substring of the form "%AB" into the
// hex-decoded byte 0xAB.
// It returns an error if any % is not followed by two hexadecimal
// digits.
func QueryUnescape(s string) (string, error) <span class="cov0" title="0">{
        return unescape(s, encodeQueryComponent)
}</span>

// PathUnescape does the inverse transformation of PathEscape,
// converting each 3-byte encoded substring of the form "%AB" into the
// hex-decoded byte 0xAB. It returns an error if any % is not followed
// by two hexadecimal digits.
//
// PathUnescape is identical to QueryUnescape except that it does not
// unescape '+' to ' ' (space).
func PathUnescape(s string) (string, error) <span class="cov0" title="0">{
        return unescape(s, encodePathSegment)
}</span>

// unescape unescapes a string; the mode specifies
// which section of the URL string is being unescaped.
func unescape(s string, mode encoding) (string, error) <span class="cov8" title="1">{
        // Count %, check that they're well-formed.
        n := 0
        hasPlus := false
        for i := 0; i &lt; len(s); </span><span class="cov8" title="1">{
                switch s[i] </span>{
                <span class="cov8" title="1">case '%':
                        n++
                        if i+2 &gt;= len(s) || !ishex(s[i+1]) || !ishex(s[i+2]) </span><span class="cov8" title="1">{
                                s = s[i:]
                                if len(s) &gt; 3 </span><span class="cov8" title="1">{
                                        s = s[:3]
                                }</span><span class="cov8" title="1">
</span>                                <span class="cov8" title="1">return "", EscapeError(s)</span>
                        }<span class="cov8" title="1">
</span>                        // Per https://tools.ietf.org/html/rfc3986#page-21
                        // in the host component %-encoding can only be used
                        // for non-ASCII bytes.
                        // But https://tools.ietf.org/html/rfc6874#section-2
                        // introduces %25 being allowed to escape a percent sign
                        // in IPv6 scoped-address literals. Yay.
                        <span class="cov8" title="1">if mode == encodeHost &amp;&amp; unhex(s[i+1]) &lt; 8 &amp;&amp; s[i:i+3] != "%25" </span><span class="cov0" title="0">{
                                return "", EscapeError(s[i : i+3])
                        }</span><span class="cov8" title="1">
</span>                        <span class="cov8" title="1">if mode == encodeZone </span><span class="cov0" title="0">{
                                // RFC 6874 says basically "anything goes" for zone identifiers
                                // and that even non-ASCII can be redundantly escaped,
                                // but it seems prudent to restrict %-escaped bytes here to those
                                // that are valid host name bytes in their unescaped form.
                                // That is, you can use escaping in the zone identifier but not
                                // to introduce bytes you couldn't just write directly.
                                // But Windows puts spaces here! Yay.
                                v := unhex(s[i+1])&lt;&lt;4 | unhex(s[i+2])
                                if s[i:i+3] != "%25" &amp;&amp; v != ' ' &amp;&amp; shouldEscape(v, encodeHost) </span><span class="cov0" title="0">{
                                        return "", EscapeError(s[i : i+3])
                                }</span><span class="cov0" title="0">
</span>                        }<span class="cov8" title="1">
</span>                        <span class="cov8" title="1">i += 3</span>
                <span class="cov8" title="1">case '+':
                        hasPlus = mode == encodeQueryComponent
                        i++</span>
                <span class="cov8" title="1">default:
                        if (mode == encodeHost || mode == encodeZone) &amp;&amp; s[i] &lt; 0x80 &amp;&amp; shouldEscape(s[i], mode) </span><span class="cov8" title="1">{
                                return "", InvalidHostError(s[i : i+1])
                        }</span><span class="cov8" title="1">
</span>                        <span class="cov8" title="1">i++</span>
                }
        }

        <span class="cov8" title="1">if n == 0 &amp;&amp; !hasPlus </span><span class="cov8" title="1">{
                return s, nil
        }</span><span class="cov8" title="1">
</span>
        <span class="cov8" title="1">var t strings.Builder
        t.Grow(len(s) - 2*n)
        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                switch s[i] </span>{
                <span class="cov8" title="1">case '%':
                        t.WriteByte(unhex(s[i+1])&lt;&lt;4 | unhex(s[i+2]))
                        i += 2</span>
                <span class="cov8" title="1">case '+':
                        if mode == encodeQueryComponent </span><span class="cov0" title="0">{
                                t.WriteByte(' ')
                        }</span><span class="cov8" title="1"> else {
                                t.WriteByte('+')
                        }</span>
                <span class="cov8" title="1">default:
                        t.WriteByte(s[i])</span>
                }
        }
        <span class="cov8" title="1">return t.String(), nil</span>
}

// QueryEscape escapes the string so it can be safely placed
// inside a URL query.
func QueryEscape(s string) string <span class="cov0" title="0">{
        return escape(s, encodeQueryComponent)
}</span>

// PathEscape escapes the string so it can be safely placed inside a URL path segment,
// replacing special characters (including /) with %XX sequences as needed.
func PathEscape(s string) string <span class="cov0" title="0">{
        return escape(s, encodePathSegment)
}</span>

func escape(s string, mode encoding) string <span class="cov8" title="1">{
        spaceCount, hexCount := 0, 0
        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                c := s[i]
                if shouldEscape(c, mode) </span><span class="cov8" title="1">{
                        if c == ' ' &amp;&amp; mode == encodeQueryComponent </span><span class="cov0" title="0">{
                                spaceCount++
                        }</span><span class="cov8" title="1"> else {
                                hexCount++
                        }</span>
                }<span class="cov8" title="1">
</span>        }

        <span class="cov8" title="1">if spaceCount == 0 &amp;&amp; hexCount == 0 </span><span class="cov8" title="1">{
                return s
        }</span><span class="cov8" title="1">
</span>
        <span class="cov8" title="1">var buf [64]byte
        var t []byte

        required := len(s) + 2*hexCount
        if required &lt;= len(buf) </span><span class="cov8" title="1">{
                t = buf[:required]
        }</span><span class="cov8" title="1"> else {
                t = make([]byte, required)
        }</span>

        <span class="cov8" title="1">if hexCount == 0 </span><span class="cov0" title="0">{
                copy(t, s)
                for i := 0; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                        if s[i] == ' ' </span><span class="cov0" title="0">{
                                t[i] = '+'
                        }</span><span class="cov0" title="0">
</span>                }
                <span class="cov0" title="0">return string(t)</span>
        }<span class="cov8" title="1">
</span>
        <span class="cov8" title="1">j := 0
        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                switch c := s[i]; </span>{
                <span class="cov0" title="0">case c == ' ' &amp;&amp; mode == encodeQueryComponent:
                        t[j] = '+'
                        j++</span>
                <span class="cov8" title="1">case shouldEscape(c, mode):
                        t[j] = '%'
                        t[j+1] = upperhex[c&gt;&gt;4]
                        t[j+2] = upperhex[c&amp;15]
                        j += 3</span>
                <span class="cov8" title="1">default:
                        t[j] = s[i]
                        j++</span>
                }
        }
        <span class="cov8" title="1">return string(t)</span>
}

// A URL represents a parsed URL (technically, a URI reference).
//
// The general form represented is:
//
//        [scheme:][//[userinfo@]host][/]path[?query][#fragment]
//
// URLs that do not start with a slash after the scheme are interpreted as:
//
//        scheme:opaque[?query][#fragment]
//
// Note that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.
// A consequence is that it is impossible to tell which slashes in the Path were
// slashes in the raw URL and which were %2f. This distinction is rarely important,
// but when it is, the code should use RawPath, an optional field which only gets
// set if the default encoding is different from Path.
//
// URL's String method uses the EscapedPath method to obtain the path. See the
// EscapedPath method for more details.
type URL struct {
        Scheme      string
        Opaque      string    // encoded opaque data
        User        *Userinfo // username and password information
        Host        string    // host or host:port
        Path        string    // path (relative paths may omit leading slash)
        RawPath     string    // encoded path hint (see EscapedPath method)
        ForceQuery  bool      // append a query ('?') even if RawQuery is empty
        RawQuery    string    // encoded query values, without '?'
        Fragment    string    // fragment for references, without '#'
        RawFragment string    // encoded fragment hint (see EscapedFragment method)
}

// User returns a Userinfo containing the provided username
// and no password set.
func User(username string) *Userinfo <span class="cov8" title="1">{
        return &amp;Userinfo{username, "", false}
}</span>

// UserPassword returns a Userinfo containing the provided username
// and password.
//
// This functionality should only be used with legacy web sites.
// RFC 2396 warns that interpreting Userinfo this way
// ``is NOT RECOMMENDED, because the passing of authentication
// information in clear text (such as URI) has proven to be a
// security risk in almost every case where it has been used.''
func UserPassword(username, password string) *Userinfo <span class="cov0" title="0">{
        return &amp;Userinfo{username, password, true}
}</span>

// The Userinfo type is an immutable encapsulation of username and
// password details for a URL. An existing Userinfo value is guaranteed
// to have a username set (potentially empty, as allowed by RFC 2396),
// and optionally a password.
type Userinfo struct {
        username    string
        password    string
        passwordSet bool
}

// Username returns the username.
func (u *Userinfo) Username() string <span class="cov0" title="0">{
        if u == nil </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return u.username</span>
}

// Password returns the password in case it is set, and whether it is set.
func (u *Userinfo) Password() (string, bool) <span class="cov0" title="0">{
        if u == nil </span><span class="cov0" title="0">{
                return "", false
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return u.password, u.passwordSet</span>
}

// String returns the encoded userinfo information in the standard form
// of "username[:password]".
func (u *Userinfo) String() string <span class="cov0" title="0">{
        if u == nil </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">s := escape(u.username, encodeUserPassword)
        if u.passwordSet </span><span class="cov0" title="0">{
                s += ":" + escape(u.password, encodeUserPassword)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return s</span>
}

// Maybe rawurl is of the form scheme:path.
// (Scheme must be [a-zA-Z][a-zA-Z0-9+-.]*)
// If so, return scheme, path; else return "", rawurl.
func getscheme(rawurl string) (scheme, path string, err error) <span class="cov8" title="1">{
        for i := 0; i &lt; len(rawurl); i++ </span><span class="cov8" title="1">{
                c := rawurl[i]
                switch </span>{
                <span class="cov8" title="1">case 'a' &lt;= c &amp;&amp; c &lt;= 'z' || 'A' &lt;= c &amp;&amp; c &lt;= 'Z':</span>
                // do nothing
                <span class="cov8" title="1">case '0' &lt;= c &amp;&amp; c &lt;= '9' || c == '+' || c == '-' || c == '.':
                        if i == 0 </span><span class="cov8" title="1">{
                                return "", rawurl, nil
                        }</span><span class="cov8" title="1">
</span>                <span class="cov8" title="1">case c == ':':
                        if i == 0 </span><span class="cov8" title="1">{
                                return "", "", errors.New("missing protocol scheme")
                        }</span><span class="cov8" title="1">
</span>                        <span class="cov8" title="1">return rawurl[:i], rawurl[i+1:], nil</span>
                <span class="cov8" title="1">default:
                        // we have encountered an invalid character,
                        // so there is no valid scheme
                        return "", rawurl, nil</span>
                }
        }
        <span class="cov8" title="1">return "", rawurl, nil</span>
}

// split slices s into two substrings separated by the first occurrence of
// sep. If cutc is true then sep is excluded from the second substring.
// If sep does not occur in s then s and the empty string is returned.
func split(s string, sep byte, cutc bool) (string, string) <span class="cov8" title="1">{
        i := strings.IndexByte(s, sep)
        if i &lt; 0 </span><span class="cov8" title="1">{
                return s, ""
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">if cutc </span><span class="cov8" title="1">{
                return s[:i], s[i+1:]
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">return s[:i], s[i:]</span>
}

// Parse parses rawurl into a URL structure.
//
// The rawurl may be relative (a path, without a host) or absolute
// (starting with a scheme). Trying to parse a hostname and path
// without a scheme is invalid but may not necessarily return an
// error, due to parsing ambiguities.
func Parse(rawurl string) (*URL, error) <span class="cov8" title="1">{
        // Cut off #frag
        u, frag := split(rawurl, '#', true)
        url, err := parse(u, false)
        if err != nil </span><span class="cov8" title="1">{
                return nil, &amp;Error{"parse", u, err}
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">if frag == "" </span><span class="cov8" title="1">{
                return url, nil
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">if err = url.setFragment(frag); err != nil </span><span class="cov8" title="1">{
                return nil, &amp;Error{"parse", rawurl, err}
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">return url, nil</span>
}

// ParseRequestURI parses rawurl into a URL structure. It assumes that
// rawurl was received in an HTTP request, so the rawurl is interpreted
// only as an absolute URI or an absolute path.
// The string rawurl is assumed not to have a #fragment suffix.
// (Web browsers strip #fragment before sending the URL to a web server.)
func ParseRequestURI(rawurl string) (*URL, error) <span class="cov0" title="0">{
        url, err := parse(rawurl, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;Error{"parse", rawurl, err}
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return url, nil</span>
}

// parse parses a URL from a string in one of two contexts. If
// viaRequest is true, the URL is assumed to have arrived via an HTTP request,
// in which case only absolute URLs or path-absolute relative URLs are allowed.
// If viaRequest is false, all forms of relative URLs are allowed.
func parse(rawurl string, viaRequest bool) (*URL, error) <span class="cov8" title="1">{
        var rest string
        var err error

        if stringContainsCTLByte(rawurl) </span><span class="cov8" title="1">{
                return nil, errors.New("net/url: invalid control character in URL")
        }</span><span class="cov8" title="1">
</span>
        <span class="cov8" title="1">if rawurl == "" &amp;&amp; viaRequest </span><span class="cov0" title="0">{
                return nil, errors.New("empty url")
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">url := new(URL)

        if rawurl == "*" </span><span class="cov8" title="1">{
                url.Path = "*"
                return url, nil
        }</span><span class="cov8" title="1">
</span>
        // Split off possible leading "http:", "mailto:", etc.
        // Cannot contain escaped characters.
        <span class="cov8" title="1">if url.Scheme, rest, err = getscheme(rawurl); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">url.Scheme = strings.ToLower(url.Scheme)

        if strings.HasSuffix(rest, "?") &amp;&amp; strings.Count(rest, "?") == 1 </span><span class="cov8" title="1">{
                url.ForceQuery = true
                rest = rest[:len(rest)-1]
        }</span><span class="cov8" title="1"> else {
                rest, url.RawQuery = split(rest, '?', true)
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(rest, "/") </span><span class="cov8" title="1">{
                if url.Scheme != "" </span><span class="cov8" title="1">{
                        // We consider rootless paths per RFC 3986 as opaque.
                        url.Opaque = rest
                        return url, nil
                }</span><span class="cov8" title="1">
</span>                <span class="cov8" title="1">if viaRequest </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid URI for request")
                }</span><span class="cov8" title="1">
</span>
                // Avoid confusion with malformed schemes, like cache_object:foo/bar.
                // See golang.org/issue/16822.
                //
                // RFC 3986, §3.3:
                // In addition, a URI reference (Section 4.1) may be a relative-path reference,
                // in which case the first path segment cannot contain a colon (":") character.
                <span class="cov8" title="1">colon := strings.Index(rest, ":")
                slash := strings.Index(rest, "/")
                if colon &gt;= 0 &amp;&amp; (slash &lt; 0 || colon &lt; slash) </span><span class="cov8" title="1">{
                        // First path segment has colon. Not allowed in relative URL.
                        return nil, errors.New("first path segment in URL cannot contain colon")
                }</span><span class="cov8" title="1">
</span>        }<span class="cov8" title="1">
</span>
        <span class="cov8" title="1">if (url.Scheme != "" || !viaRequest &amp;&amp; !strings.HasPrefix(rest, "///")) &amp;&amp; strings.HasPrefix(rest, "//") </span><span class="cov8" title="1">{
                var authority string
                authority, rest = split(rest[2:], '/', false)
                url.User, url.Host, err = parseAuthority(authority)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span><span class="cov8" title="1">
</span>        }<span class="cov8" title="1">
</span>        // Set Path and, optionally, RawPath.
        // RawPath is a hint of the encoding of Path. We don't want to set it if
        // the default escaping of Path is equivalent, to help make sure that people
        // don't rely on it in general.
        <span class="cov8" title="1">if err := url.setPath(rest); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">return url, nil</span>
}

func parseAuthority(authority string) (user *Userinfo, host string, err error) <span class="cov8" title="1">{
        i := strings.LastIndex(authority, "@")
        if i &lt; 0 </span><span class="cov8" title="1">{
                host, err = parseHost(authority)
        }</span><span class="cov8" title="1"> else {
                host, err = parseHost(authority[i+1:])
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, "", err
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">if i &lt; 0 </span><span class="cov8" title="1">{
                return nil, host, nil
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">userinfo := authority[:i]
        if !validUserinfo(userinfo) </span><span class="cov8" title="1">{
                return nil, "", errors.New("net/url: invalid userinfo")
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">if !strings.Contains(userinfo, ":") </span><span class="cov8" title="1">{
                if userinfo, err = unescape(userinfo, encodeUserPassword); err != nil </span><span class="cov8" title="1">{
                        return nil, "", err
                }</span><span class="cov8" title="1">
</span>                <span class="cov8" title="1">user = User(userinfo)</span>
        }<span class="cov0" title="0"> else {
                username, password := split(userinfo, ':', true)
                if username, err = unescape(username, encodeUserPassword); err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if password, err = unescape(password, encodeUserPassword); err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">user = UserPassword(username, password)</span>
        }
        <span class="cov8" title="1">return user, host, nil</span>
}

// parseHost parses host as an authority without user
// information. That is, as host[:port].
func parseHost(host string) (string, error) <span class="cov8" title="1">{
        if strings.HasPrefix(host, "[") </span><span class="cov0" title="0">{
                // Parse an IP-Literal in RFC 3986 and RFC 6874.
                // E.g., "[fe80::1]", "[fe80::1%25en0]", "[fe80::1]:80".
                i := strings.LastIndex(host, "]")
                if i &lt; 0 </span><span class="cov0" title="0">{
                        return "", errors.New("missing ']' in host")
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">colonPort := host[i+1:]
                if !validOptionalPort(colonPort) </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("invalid port %q after host", colonPort)
                }</span><span class="cov0" title="0">
</span>
                // RFC 6874 defines that %25 (%-encoded percent) introduces
                // the zone identifier, and the zone identifier can use basically
                // any %-encoding it likes. That's different from the host, which
                // can only %-encode non-ASCII bytes.
                // We do impose some restrictions on the zone, to avoid stupidity
                // like newlines.
                <span class="cov0" title="0">zone := strings.Index(host[:i], "%25")
                if zone &gt;= 0 </span><span class="cov0" title="0">{
                        host1, err := unescape(host[:zone], encodeHost)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">host2, err := unescape(host[zone:i], encodeZone)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">host3, err := unescape(host[i:], encodeHost)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">return host1 + host2 + host3, nil</span>
                }<span class="cov0" title="0">
</span>        }<span class="cov8" title="1"> else if i := strings.LastIndex(host, ":"); i != -1 </span><span class="cov8" title="1">{
                colonPort := host[i:]
                if !validOptionalPort(colonPort) </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("invalid port %q after host", colonPort)
                }</span><span class="cov8" title="1">
</span>        }<span class="cov8" title="1">
</span>
        <span class="cov8" title="1">var err error
        if host, err = unescape(host, encodeHost); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">return host, nil</span>
}

// setPath sets the Path and RawPath fields of the URL based on the provided
// escaped path p. It maintains the invariant that RawPath is only specified
// when it differs from the default encoding of the path.
// For example:
// - setPath("/foo/bar")   will set Path="/foo/bar" and RawPath=""
// - setPath("/foo%2fbar") will set Path="/foo/bar" and RawPath="/foo%2fbar"
// setPath will return an error only if the provided path contains an invalid
// escaping.
func (u *URL) setPath(p string) error <span class="cov8" title="1">{
        path, err := unescape(p, encodePath)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">u.Path = path
        if escp := escape(path, encodePath); p == escp </span><span class="cov8" title="1">{
                // Default encoding is fine.
                u.RawPath = ""
        }</span><span class="cov8" title="1"> else {
                u.RawPath = p
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// EscapedPath returns the escaped form of u.Path.
// In general there are multiple possible escaped forms of any path.
// EscapedPath returns u.RawPath when it is a valid escaping of u.Path.
// Otherwise EscapedPath ignores u.RawPath and computes an escaped
// form on its own.
// The String and RequestURI methods use EscapedPath to construct
// their results.
// In general, code should call EscapedPath instead of
// reading u.RawPath directly.
func (u *URL) EscapedPath() string <span class="cov8" title="1">{
        if u.RawPath != "" &amp;&amp; validEncoded(u.RawPath, encodePath) </span><span class="cov0" title="0">{
                p, err := unescape(u.RawPath, encodePath)
                if err == nil &amp;&amp; p == u.Path </span><span class="cov0" title="0">{
                        return u.RawPath
                }</span><span class="cov0" title="0">
</span>        }<span class="cov8" title="1">
</span>        <span class="cov8" title="1">if u.Path == "*" </span><span class="cov0" title="0">{
                return "*" // don't escape (Issue 11202)
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">return escape(u.Path, encodePath)</span>
}

// validEncoded reports whether s is a valid encoded path or fragment,
// according to mode.
// It must not contain any bytes that require escaping during encoding.
func validEncoded(s string, mode encoding) bool <span class="cov0" title="0">{
        for i := 0; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                // RFC 3986, Appendix A.
                // pchar = unreserved / pct-encoded / sub-delims / ":" / "@".
                // shouldEscape is not quite compliant with the RFC,
                // so we check the sub-delims ourselves and let
                // shouldEscape handle the others.
                switch s[i] </span>{
                <span class="cov0" title="0">case '!', '$', '&amp;', '\'', '(', ')', '*', '+', ',', ';', '=', ':', '@':</span>
                        // ok
                <span class="cov0" title="0">case '[', ']':</span>
                        // ok - not specified in RFC 3986 but left alone by modern browsers
                <span class="cov0" title="0">case '%':</span>
                        // ok - percent encoded, will decode
                <span class="cov0" title="0">default:
                        if shouldEscape(s[i], mode) </span><span class="cov0" title="0">{
                                return false
                        }</span><span class="cov0" title="0">
</span>                }
        }
        <span class="cov0" title="0">return true</span>
}

// setFragment is like setPath but for Fragment/RawFragment.
func (u *URL) setFragment(f string) error <span class="cov8" title="1">{
        frag, err := unescape(f, encodeFragment)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">u.Fragment = frag
        if escf := escape(frag, encodeFragment); f == escf </span><span class="cov8" title="1">{
                // Default encoding is fine.
                u.RawFragment = ""
        }</span><span class="cov8" title="1"> else {
                u.RawFragment = f
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// EscapedFragment returns the escaped form of u.Fragment.
// In general there are multiple possible escaped forms of any fragment.
// EscapedFragment returns u.RawFragment when it is a valid escaping of u.Fragment.
// Otherwise EscapedFragment ignores u.RawFragment and computes an escaped
// form on its own.
// The String method uses EscapedFragment to construct its result.
// In general, code should call EscapedFragment instead of
// reading u.RawFragment directly.
func (u *URL) EscapedFragment() string <span class="cov0" title="0">{
        if u.RawFragment != "" &amp;&amp; validEncoded(u.RawFragment, encodeFragment) </span><span class="cov0" title="0">{
                f, err := unescape(u.RawFragment, encodeFragment)
                if err == nil &amp;&amp; f == u.Fragment </span><span class="cov0" title="0">{
                        return u.RawFragment
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">return escape(u.Fragment, encodeFragment)</span>
}

// validOptionalPort reports whether port is either an empty string
// or matches /^:\d*$/
func validOptionalPort(port string) bool <span class="cov8" title="1">{
        if port == "" </span><span class="cov0" title="0">{
                return true
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">if port[0] != ':' </span><span class="cov0" title="0">{
                return false
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">for _, b := range port[1:] </span><span class="cov8" title="1">{
                if b &lt; '0' || b &gt; '9' </span><span class="cov8" title="1">{
                        return false
                }</span><span class="cov8" title="1">
</span>        }
        <span class="cov8" title="1">return true</span>
}

// String reassembles the URL into a valid URL string.
// The general form of the result is one of:
//
//        scheme:opaque?query#fragment
//        scheme://userinfo@host/path?query#fragment
//
// If u.Opaque is non-empty, String uses the first form;
// otherwise it uses the second form.
// Any non-ASCII characters in host are escaped.
// To obtain the path, String uses u.EscapedPath().
//
// In the second form, the following rules apply:
//        - if u.Scheme is empty, scheme: is omitted.
//        - if u.User is nil, userinfo@ is omitted.
//        - if u.Host is empty, host/ is omitted.
//        - if u.Scheme and u.Host are empty and u.User is nil,
//           the entire scheme://userinfo@host/ is omitted.
//        - if u.Host is non-empty and u.Path begins with a /,
//           the form host/path does not add its own /.
//        - if u.RawQuery is empty, ?query is omitted.
//        - if u.Fragment is empty, #fragment is omitted.
func (u *URL) String() string <span class="cov8" title="1">{
        var buf strings.Builder
        if u.Scheme != "" </span><span class="cov0" title="0">{
                buf.WriteString(u.Scheme)
                buf.WriteByte(':')
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">if u.Opaque != "" </span><span class="cov0" title="0">{
                buf.WriteString(u.Opaque)
        }</span><span class="cov8" title="1"> else {
                if u.Scheme != "" || u.Host != "" || u.User != nil </span><span class="cov0" title="0">{
                        if u.Host != "" || u.Path != "" || u.User != nil </span><span class="cov0" title="0">{
                                buf.WriteString("//")
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">if ui := u.User; ui != nil </span><span class="cov0" title="0">{
                                buf.WriteString(ui.String())
                                buf.WriteByte('@')
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">if h := u.Host; h != "" </span><span class="cov0" title="0">{
                                buf.WriteString(escape(h, encodeHost))
                        }</span><span class="cov0" title="0">
</span>                }<span class="cov8" title="1">
</span>                <span class="cov8" title="1">path := u.EscapedPath()
                if path != "" &amp;&amp; path[0] != '/' &amp;&amp; u.Host != "" </span><span class="cov0" title="0">{
                        buf.WriteByte('/')
                }</span><span class="cov8" title="1">
</span>                <span class="cov8" title="1">if buf.Len() == 0 </span><span class="cov8" title="1">{
                        // RFC 3986 §4.2
                        // A path segment that contains a colon character (e.g., "this:that")
                        // cannot be used as the first segment of a relative-path reference, as
                        // it would be mistaken for a scheme name. Such a segment must be
                        // preceded by a dot-segment (e.g., "./this:that") to make a relative-
                        // path reference.
                        if i := strings.IndexByte(path, ':'); i &gt; -1 &amp;&amp; strings.IndexByte(path[:i], '/') == -1 </span><span class="cov0" title="0">{
                                buf.WriteString("./")
                        }</span><span class="cov8" title="1">
</span>                }<span class="cov0" title="0">
</span>                <span class="cov8" title="1">buf.WriteString(path)</span>
        }
        <span class="cov8" title="1">if u.ForceQuery || u.RawQuery != "" </span><span class="cov8" title="1">{
                buf.WriteByte('?')
                buf.WriteString(u.RawQuery)
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">if u.Fragment != "" </span><span class="cov0" title="0">{
                buf.WriteByte('#')
                buf.WriteString(u.EscapedFragment())
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">return buf.String()</span>
}

// Redacted is like String but replaces any password with "xxxxx".
// Only the password in u.URL is redacted.
func (u *URL) Redacted() string <span class="cov0" title="0">{
        if u == nil </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">ru := *u
        if _, has := ru.User.Password(); has </span><span class="cov0" title="0">{
                ru.User = UserPassword(ru.User.Username(), "xxxxx")
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return ru.String()</span>
}

// Values maps a string key to a list of values.
// It is typically used for query parameters and form values.
// Unlike in the http.Header map, the keys in a Values map
// are case-sensitive.
type Values map[string][]string

// Get gets the first value associated with the given key.
// If there are no values associated with the key, Get returns
// the empty string. To access multiple values, use the map
// directly.
func (v Values) Get(key string) string <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">vs := v[key]
        if len(vs) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return vs[0]</span>
}

// Set sets the key to value. It replaces any existing
// values.
func (v Values) Set(key, value string) <span class="cov0" title="0">{
        v[key] = []string{value}
}</span>

// Add adds the value to key. It appends to any existing
// values associated with key.
func (v Values) Add(key, value string) <span class="cov0" title="0">{
        v[key] = append(v[key], value)
}</span>

// Del deletes the values associated with key.
func (v Values) Del(key string) <span class="cov0" title="0">{
        delete(v, key)
}</span>

// ParseQuery parses the URL-encoded query string and returns
// a map listing the values specified for each key.
// ParseQuery always returns a non-nil map containing all the
// valid query parameters found; err describes the first decoding error
// encountered, if any.
//
// Query is expected to be a list of key=value settings separated by
// ampersands or semicolons. A setting without an equals sign is
// interpreted as a key set to an empty value.
func ParseQuery(query string) (Values, error) <span class="cov0" title="0">{
        m := make(Values)
        err := parseQuery(m, query)
        return m, err
}</span>

func parseQuery(m Values, query string) (err error) <span class="cov0" title="0">{
        for query != "" </span><span class="cov0" title="0">{
                key := query
                if i := strings.IndexAny(key, "&amp;;"); i &gt;= 0 </span><span class="cov0" title="0">{
                        key, query = key[:i], key[i+1:]
                }</span><span class="cov0" title="0"> else {
                        query = ""
                }</span>
                <span class="cov0" title="0">if key == "" </span><span class="cov0" title="0">{
                        continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">value := ""
                if i := strings.Index(key, "="); i &gt;= 0 </span><span class="cov0" title="0">{
                        key, value = key[:i], key[i+1:]
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">key, err1 := QueryUnescape(key)
                if err1 != nil </span><span class="cov0" title="0">{
                        if err == nil </span><span class="cov0" title="0">{
                                err = err1
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">value, err1 = QueryUnescape(value)
                if err1 != nil </span><span class="cov0" title="0">{
                        if err == nil </span><span class="cov0" title="0">{
                                err = err1
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">m[key] = append(m[key], value)</span>
        }
        <span class="cov0" title="0">return err</span>
}

// Encode encodes the values into ``URL encoded'' form
// ("bar=baz&amp;foo=quux") sorted by key.
func (v Values) Encode() string <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">var buf strings.Builder
        keys := make([]string, 0, len(v))
        for k := range v </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)
        for _, k := range keys </span><span class="cov0" title="0">{
                vs := v[k]
                keyEscaped := QueryEscape(k)
                for _, v := range vs </span><span class="cov0" title="0">{
                        if buf.Len() &gt; 0 </span><span class="cov0" title="0">{
                                buf.WriteByte('&amp;')
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">buf.WriteString(keyEscaped)
                        buf.WriteByte('=')
                        buf.WriteString(QueryEscape(v))</span>
                }
        }
        <span class="cov0" title="0">return buf.String()</span>
}

// resolvePath applies special path segments from refs and applies
// them to base, per RFC 3986.
func resolvePath(base, ref string) string <span class="cov0" title="0">{
        var full string
        if ref == "" </span><span class="cov0" title="0">{
                full = base
        }</span><span class="cov0" title="0"> else if ref[0] != '/' </span><span class="cov0" title="0">{
                i := strings.LastIndex(base, "/")
                full = base[:i+1] + ref
        }</span><span class="cov0" title="0"> else {
                full = ref
        }</span>
        <span class="cov0" title="0">if full == "" </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">src := strings.Split(full, "/")
        dst := make([]string, 0, len(src))
        for _, elem := range src </span><span class="cov0" title="0">{
                switch elem </span>{
                <span class="cov0" title="0">case ".":</span>
                        // drop
                <span class="cov0" title="0">case "..":
                        if len(dst) &gt; 0 </span><span class="cov0" title="0">{
                                dst = dst[:len(dst)-1]
                        }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">default:
                        dst = append(dst, elem)</span>
                }
        }
        <span class="cov0" title="0">if last := src[len(src)-1]; last == "." || last == ".." </span><span class="cov0" title="0">{
                // Add final slash to the joined path.
                dst = append(dst, "")
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return "/" + strings.TrimPrefix(strings.Join(dst, "/"), "/")</span>
}

// IsAbs reports whether the URL is absolute.
// Absolute means that it has a non-empty scheme.
func (u *URL) IsAbs() bool <span class="cov0" title="0">{
        return u.Scheme != ""
}</span>

// Parse parses a URL in the context of the receiver. The provided URL
// may be relative or absolute. Parse returns nil, err on parse
// failure, otherwise its return value is the same as ResolveReference.
func (u *URL) Parse(ref string) (*URL, error) <span class="cov0" title="0">{
        refurl, err := Parse(ref)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return u.ResolveReference(refurl), nil</span>
}

// ResolveReference resolves a URI reference to an absolute URI from
// an absolute base URI u, per RFC 3986 Section 5.2. The URI reference
// may be relative or absolute. ResolveReference always returns a new
// URL instance, even if the returned URL is identical to either the
// base or reference. If ref is an absolute URL, then ResolveReference
// ignores base and returns a copy of ref.
func (u *URL) ResolveReference(ref *URL) *URL <span class="cov0" title="0">{
        url := *ref
        if ref.Scheme == "" </span><span class="cov0" title="0">{
                url.Scheme = u.Scheme
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if ref.Scheme != "" || ref.Host != "" || ref.User != nil </span><span class="cov0" title="0">{
                // The "absoluteURI" or "net_path" cases.
                // We can ignore the error from setPath since we know we provided a
                // validly-escaped path.
                url.setPath(resolvePath(ref.EscapedPath(), ""))
                return &amp;url
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if ref.Opaque != "" </span><span class="cov0" title="0">{
                url.User = nil
                url.Host = ""
                url.Path = ""
                return &amp;url
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if ref.Path == "" &amp;&amp; ref.RawQuery == "" </span><span class="cov0" title="0">{
                url.RawQuery = u.RawQuery
                if ref.Fragment == "" </span><span class="cov0" title="0">{
                        url.Fragment = u.Fragment
                        url.RawFragment = u.RawFragment
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>        // The "abs_path" or "rel_path" cases.
        <span class="cov0" title="0">url.Host = u.Host
        url.User = u.User
        url.setPath(resolvePath(u.EscapedPath(), ref.EscapedPath()))
        return &amp;url</span>
}

// Query parses RawQuery and returns the corresponding values.
// It silently discards malformed value pairs.
// To check errors use ParseQuery.
func (u *URL) Query() Values <span class="cov0" title="0">{
        v, _ := ParseQuery(u.RawQuery)
        return v
}</span>

// RequestURI returns the encoded path?query or opaque?query
// string that would be used in an HTTP request for u.
func (u *URL) RequestURI() string <span class="cov0" title="0">{
        result := u.Opaque
        if result == "" </span><span class="cov0" title="0">{
                result = u.EscapedPath()
                if result == "" </span><span class="cov0" title="0">{
                        result = "/"
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0"> else {
                if strings.HasPrefix(result, "//") </span><span class="cov0" title="0">{
                        result = u.Scheme + ":" + result
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">if u.ForceQuery || u.RawQuery != "" </span><span class="cov0" title="0">{
                result += "?" + u.RawQuery
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return result</span>
}

// Hostname returns u.Host, stripping any valid port number if present.
//
// If the result is enclosed in square brackets, as literal IPv6 addresses are,
// the square brackets are removed from the result.
func (u *URL) Hostname() string <span class="cov0" title="0">{
        host, _ := splitHostPort(u.Host)
        return host
}</span>

// Port returns the port part of u.Host, without the leading colon.
//
// If u.Host doesn't contain a valid numeric port, Port returns an empty string.
func (u *URL) Port() string <span class="cov0" title="0">{
        _, port := splitHostPort(u.Host)
        return port
}</span>

// splitHostPort separates host and port. If the port is not valid, it returns
// the entire input as host, and it doesn't check the validity of the host.
// Unlike net.SplitHostPort, but per RFC 3986, it requires ports to be numeric.
func splitHostPort(hostport string) (host, port string) <span class="cov0" title="0">{
        host = hostport

        colon := strings.LastIndexByte(host, ':')
        if colon != -1 &amp;&amp; validOptionalPort(host[colon:]) </span><span class="cov0" title="0">{
                host, port = host[:colon], host[colon+1:]
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if strings.HasPrefix(host, "[") &amp;&amp; strings.HasSuffix(host, "]") </span><span class="cov0" title="0">{
                host = host[1 : len(host)-1]
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">return</span>
}

// Marshaling interface implementations.
// Would like to implement MarshalText/UnmarshalText but that will change the JSON representation of URLs.

func (u *URL) MarshalBinary() (text []byte, err error) <span class="cov0" title="0">{
        return []byte(u.String()), nil
}</span>

func (u *URL) UnmarshalBinary(text []byte) error <span class="cov0" title="0">{
        u1, err := Parse(string(text))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">*u = *u1
        return nil</span>
}

// validUserinfo reports whether s is a valid userinfo string per RFC 3986
// Section 3.2.1:
//     userinfo    = *( unreserved / pct-encoded / sub-delims / ":" )
//     unreserved  = ALPHA / DIGIT / "-" / "." / "_" / "~"
//     sub-delims  = "!" / "$" / "&amp;" / "'" / "(" / ")"
//                   / "*" / "+" / "," / ";" / "="
//
// It doesn't validate pct-encoded. The caller does that via func unescape.
func validUserinfo(s string) bool <span class="cov8" title="1">{
        for _, r := range s </span><span class="cov8" title="1">{
                if 'A' &lt;= r &amp;&amp; r &lt;= 'Z' </span><span class="cov8" title="1">{
                        continue</span>
                }<span class="cov8" title="1">
</span>                <span class="cov8" title="1">if 'a' &lt;= r &amp;&amp; r &lt;= 'z' </span><span class="cov0" title="0">{
                        continue</span>
                }<span class="cov8" title="1">
</span>                <span class="cov8" title="1">if '0' &lt;= r &amp;&amp; r &lt;= '9' </span><span class="cov0" title="0">{
                        continue</span>
                }<span class="cov8" title="1">
</span>                <span class="cov8" title="1">switch r </span>{
                <span class="cov8" title="1">case '-', '.', '_', ':', '~', '!', '$', '&amp;', '\'',
                        '(', ')', '*', '+', ',', ';', '=', '%', '@':
                        continue</span>
                <span class="cov8" title="1">default:
                        return false</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

// stringContainsCTLByte reports whether s contains any ASCII control character.
func stringContainsCTLByte(s string) bool <span class="cov8" title="1">{
        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                b := s[i]
                if b &lt; ' ' || b == 0x7f </span><span class="cov8" title="1">{
                        return true
                }</span><span class="cov8" title="1">
</span>        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build aix darwin dragonfly freebsd js,wasm linux netbsd openbsd solaris windows

package os

import (
        "internal/syscall/execenv"
        "runtime"
        "syscall"
)

// The only signal values guaranteed to be present in the os package on all
// systems are os.Interrupt (send the process an interrupt) and os.Kill (force
// the process to exit). On Windows, sending os.Interrupt to a process with
// os.Process.Signal is not implemented; it will return an error instead of
// sending a signal.
var (
        Interrupt Signal = syscall.SIGINT
        Kill      Signal = syscall.SIGKILL
)

func startProcess(name string, argv []string, attr *ProcAttr) (p *Process, err error) <span class="cov0" title="0">{
        // If there is no SysProcAttr (ie. no Chroot or changed
        // UID/GID), double-check existence of the directory we want
        // to chdir into. We can make the error clearer this way.
        if attr != nil &amp;&amp; attr.Sys == nil &amp;&amp; attr.Dir != "" </span><span class="cov0" title="0">{
                if _, err := Stat(attr.Dir); err != nil </span><span class="cov0" title="0">{
                        pe := err.(*PathError)
                        pe.Op = "chdir"
                        return nil, pe
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">sysattr := &amp;syscall.ProcAttr{
                Dir: attr.Dir,
                Env: attr.Env,
                Sys: attr.Sys,
        }
        if sysattr.Env == nil </span><span class="cov0" title="0">{
                sysattr.Env, err = execenv.Default(sysattr.Sys)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">sysattr.Files = make([]uintptr, 0, len(attr.Files))
        for _, f := range attr.Files </span><span class="cov0" title="0">{
                sysattr.Files = append(sysattr.Files, f.Fd())
        }</span>

        <span class="cov0" title="0">pid, h, e := syscall.StartProcess(name, argv, sysattr)

        // Make sure we don't run the finalizers of attr.Files.
        runtime.KeepAlive(attr)

        if e != nil </span><span class="cov0" title="0">{
                return nil, &amp;PathError{"fork/exec", name, e}
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">return newProcess(pid, h), nil</span>
}

func (p *Process) kill() error <span class="cov0" title="0">{
        return p.Signal(Kill)
}</span>

// ProcessState stores information about a process, as reported by Wait.
type ProcessState struct {
        pid    int                // The process's id.
        status syscall.WaitStatus // System-dependent status info.
        rusage *syscall.Rusage
}

// Pid returns the process id of the exited process.
func (p *ProcessState) Pid() int <span class="cov0" title="0">{
        return p.pid
}</span>

func (p *ProcessState) exited() bool <span class="cov0" title="0">{
        return p.status.Exited()
}</span>

func (p *ProcessState) success() bool <span class="cov0" title="0">{
        return p.status.ExitStatus() == 0
}</span>

func (p *ProcessState) sys() interface{} <span class="cov0" title="0">{
        return p.status
}</span>

func (p *ProcessState) sysUsage() interface{} <span class="cov0" title="0">{
        return p.rusage
}</span>

func (p *ProcessState) String() string <span class="cov0" title="0">{
        if p == nil </span><span class="cov0" title="0">{
                return "&lt;nil&gt;"
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">status := p.Sys().(syscall.WaitStatus)
        res := ""
        switch </span>{
        <span class="cov0" title="0">case status.Exited():
                res = "exit status " + itoa(status.ExitStatus())</span>
        <span class="cov0" title="0">case status.Signaled():
                res = "signal: " + status.Signal().String()</span>
        <span class="cov0" title="0">case status.Stopped():
                res = "stop signal: " + status.StopSignal().String()
                if status.StopSignal() == syscall.SIGTRAP &amp;&amp; status.TrapCause() != 0 </span><span class="cov0" title="0">{
                        res += " (trap " + itoa(status.TrapCause()) + ")"
                }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">case status.Continued():
                res = "continued"</span>
        }
        <span class="cov0" title="0">if status.CoreDump() </span><span class="cov0" title="0">{
                res += " (core dumped)"
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return res</span>
}

// ExitCode returns the exit code of the exited process, or -1
// if the process hasn't exited or was terminated by a signal.
func (p *ProcessState) ExitCode() int <span class="cov0" title="0">{
        // return -1 if the process hasn't started.
        if p == nil </span><span class="cov0" title="0">{
                return -1
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return p.status.ExitStatus()</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build aix darwin dragonfly freebsd js,wasm linux netbsd openbsd solaris

package os

import (
        "internal/poll"
        "internal/syscall/unix"
        "io"
        "runtime"
        "syscall"
)

// fixLongPath is a noop on non-Windows platforms.
func fixLongPath(path string) string <span class="cov0" title="0">{
        return path
}</span>

func rename(oldname, newname string) error <span class="cov0" title="0">{
        fi, err := Lstat(newname)
        if err == nil &amp;&amp; fi.IsDir() </span><span class="cov0" title="0">{
                // There are two independent errors this function can return:
                // one for a bad oldname, and one for a bad newname.
                // At this point we've determined the newname is bad.
                // But just in case oldname is also bad, prioritize returning
                // the oldname error because that's what we did historically.
                // However, if the old name and new name are not the same, yet
                // they refer to the same file, it implies a case-only
                // rename on a case-insensitive filesystem, which is ok.
                if ofi, err := Lstat(oldname); err != nil </span><span class="cov0" title="0">{
                        if pe, ok := err.(*PathError); ok </span><span class="cov0" title="0">{
                                err = pe.Err
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">return &amp;LinkError{"rename", oldname, newname, err}</span>
                }<span class="cov0" title="0"> else if newname == oldname || !SameFile(fi, ofi) </span><span class="cov0" title="0">{
                        return &amp;LinkError{"rename", oldname, newname, syscall.EEXIST}
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">err = syscall.Rename(oldname, newname)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;LinkError{"rename", oldname, newname, err}
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return nil</span>
}

// file is the real representation of *File.
// The extra level of indirection ensures that no clients of os
// can overwrite this data, which could cause the finalizer
// to close the wrong file descriptor.
type file struct {
        pfd         poll.FD
        name        string
        dirinfo     *dirInfo // nil unless directory being read
        nonblock    bool     // whether we set nonblocking mode
        stdoutOrErr bool     // whether this is stdout or stderr
        appendMode  bool     // whether file is opened for appending
}

// Fd returns the integer Unix file descriptor referencing the open file.
// The file descriptor is valid only until f.Close is called or f is garbage collected.
// On Unix systems this will cause the SetDeadline methods to stop working.
func (f *File) Fd() uintptr <span class="cov0" title="0">{
        if f == nil </span><span class="cov0" title="0">{
                return ^(uintptr(0))
        }</span><span class="cov0" title="0">
</span>
        // If we put the file descriptor into nonblocking mode,
        // then set it to blocking mode before we return it,
        // because historically we have always returned a descriptor
        // opened in blocking mode. The File will continue to work,
        // but any blocking operation will tie up a thread.
        <span class="cov0" title="0">if f.nonblock </span><span class="cov0" title="0">{
                f.pfd.SetBlocking()
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">return uintptr(f.pfd.Sysfd)</span>
}

// NewFile returns a new File with the given file descriptor and
// name. The returned value will be nil if fd is not a valid file
// descriptor. On Unix systems, if the file descriptor is in
// non-blocking mode, NewFile will attempt to return a pollable File
// (one for which the SetDeadline methods work).
func NewFile(fd uintptr, name string) *File <span class="cov0" title="0">{
        kind := kindNewFile
        if nb, err := unix.IsNonblock(int(fd)); err == nil &amp;&amp; nb </span><span class="cov0" title="0">{
                kind = kindNonBlock
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return newFile(fd, name, kind)</span>
}

// newFileKind describes the kind of file to newFile.
type newFileKind int

const (
        kindNewFile newFileKind = iota
        kindOpenFile
        kindPipe
        kindNonBlock
)

// newFile is like NewFile, but if called from OpenFile or Pipe
// (as passed in the kind parameter) it tries to add the file to
// the runtime poller.
func newFile(fd uintptr, name string, kind newFileKind) *File <span class="cov0" title="0">{
        fdi := int(fd)
        if fdi &lt; 0 </span><span class="cov0" title="0">{
                return nil
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">f := &amp;File{&amp;file{
                pfd: poll.FD{
                        Sysfd:         fdi,
                        IsStream:      true,
                        ZeroReadIsEOF: true,
                },
                name:        name,
                stdoutOrErr: fdi == 1 || fdi == 2,
        }}

        pollable := kind == kindOpenFile || kind == kindPipe || kind == kindNonBlock

        // If the caller passed a non-blocking filedes (kindNonBlock),
        // we assume they know what they are doing so we allow it to be
        // used with kqueue.
        if kind == kindOpenFile </span><span class="cov0" title="0">{
                switch runtime.GOOS </span>{
                <span class="cov0" title="0">case "darwin", "dragonfly", "freebsd", "netbsd", "openbsd":
                        var st syscall.Stat_t
                        err := syscall.Fstat(fdi, &amp;st)
                        typ := st.Mode &amp; syscall.S_IFMT
                        // Don't try to use kqueue with regular files on *BSDs.
                        // On FreeBSD a regular file is always
                        // reported as ready for writing.
                        // On Dragonfly, NetBSD and OpenBSD the fd is signaled
                        // only once as ready (both read and write).
                        // Issue 19093.
                        // Also don't add directories to the netpoller.
                        if err == nil &amp;&amp; (typ == syscall.S_IFREG || typ == syscall.S_IFDIR) </span><span class="cov0" title="0">{
                                pollable = false
                        }</span><span class="cov0" title="0">
</span>
                        // In addition to the behavior described above for regular files,
                        // on Darwin, kqueue does not work properly with fifos:
                        // closing the last writer does not cause a kqueue event
                        // for any readers. See issue #24164.
                        <span class="cov0" title="0">if runtime.GOOS == "darwin" &amp;&amp; typ == syscall.S_IFIFO </span><span class="cov0" title="0">{
                                pollable = false
                        }</span><span class="cov0" title="0">
</span>                }
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if err := f.pfd.Init("file", pollable); err != nil </span><span class="cov0" title="0">{
                // An error here indicates a failure to register
                // with the netpoll system. That can happen for
                // a file descriptor that is not supported by
                // epoll/kqueue; for example, disk files on
                // GNU/Linux systems. We assume that any real error
                // will show up in later I/O.
        }</span><span class="cov0" title="0"> else if pollable </span><span class="cov0" title="0">{
                // We successfully registered with netpoll, so put
                // the file into nonblocking mode.
                if err := syscall.SetNonblock(fdi, true); err == nil </span><span class="cov0" title="0">{
                        f.nonblock = true
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">runtime.SetFinalizer(f.file, (*file).close)
        return f</span>
}

// epipecheck raises SIGPIPE if we get an EPIPE error on standard
// output or standard error. See the SIGPIPE docs in os/signal, and
// issue 11845.
func epipecheck(file *File, e error) <span class="cov0" title="0">{
        if e == syscall.EPIPE &amp;&amp; file.stdoutOrErr </span><span class="cov0" title="0">{
                sigpipe()
        }</span><span class="cov0" title="0">
</span>}

// DevNull is the name of the operating system's ``null device.''
// On Unix-like systems, it is "/dev/null"; on Windows, "NUL".
const DevNull = "/dev/null"

// openFileNolog is the Unix implementation of OpenFile.
// Changes here should be reflected in openFdAt, if relevant.
func openFileNolog(name string, flag int, perm FileMode) (*File, error) <span class="cov0" title="0">{
        setSticky := false
        if !supportsCreateWithStickyBit &amp;&amp; flag&amp;O_CREATE != 0 &amp;&amp; perm&amp;ModeSticky != 0 </span><span class="cov0" title="0">{
                if _, err := Stat(name); IsNotExist(err) </span><span class="cov0" title="0">{
                        setSticky = true
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">var r int
        for </span><span class="cov0" title="0">{
                var e error
                r, e = syscall.Open(name, flag|syscall.O_CLOEXEC, syscallMode(perm))
                if e == nil </span><span class="cov0" title="0">{
                        break</span>
                }<span class="cov0" title="0">
</span>
                // We have to check EINTR here, per issues 11180 and 39237.
                <span class="cov0" title="0">if e == syscall.EINTR </span><span class="cov0" title="0">{
                        continue</span>
                }<span class="cov0" title="0">
</span>
                <span class="cov0" title="0">return nil, &amp;PathError{"open", name, e}</span>
        }

        // open(2) itself won't handle the sticky bit on *BSD and Solaris
        <span class="cov0" title="0">if setSticky </span><span class="cov0" title="0">{
                setStickyBit(name)
        }</span><span class="cov0" title="0">
</span>
        // There's a race here with fork/exec, which we are
        // content to live with. See ../syscall/exec_unix.go.
        <span class="cov0" title="0">if !supportsCloseOnExec </span><span class="cov0" title="0">{
                syscall.CloseOnExec(r)
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">return newFile(uintptr(r), name, kindOpenFile), nil</span>
}

func (file *file) close() error <span class="cov0" title="0">{
        if file == nil </span><span class="cov0" title="0">{
                return syscall.EINVAL
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if file.dirinfo != nil </span><span class="cov0" title="0">{
                file.dirinfo.close()
        }</span><span class="cov0" title="0">
</span>        <span class="cov8" title="1">var err error
        if e := file.pfd.Close(); e != nil </span><span class="cov0" title="0">{
                if e == poll.ErrFileClosing </span><span class="cov0" title="0">{
                        e = ErrClosed
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">err = &amp;PathError{"close", file.name, e}</span>
        }<span class="cov0" title="0">
</span>
        // no need for a finalizer anymore
        <span class="cov0" title="0">runtime.SetFinalizer(file, nil)
        return err</span>
}

// seek sets the offset for the next Read or Write on file to offset, interpreted
// according to whence: 0 means relative to the origin of the file, 1 means
// relative to the current offset, and 2 means relative to the end.
// It returns the new offset and an error, if any.
func (f *File) seek(offset int64, whence int) (ret int64, err error) <span class="cov0" title="0">{
        if f.dirinfo != nil </span><span class="cov0" title="0">{
                // Free cached dirinfo, so we allocate a new one if we
                // access this file as a directory again. See #35767 and #37161.
                f.dirinfo.close()
                f.dirinfo = nil
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">ret, err = f.pfd.Seek(offset, whence)
        runtime.KeepAlive(f)
        return ret, err</span>
}

// Truncate changes the size of the named file.
// If the file is a symbolic link, it changes the size of the link's target.
// If there is an error, it will be of type *PathError.
func Truncate(name string, size int64) error <span class="cov0" title="0">{
        if e := syscall.Truncate(name, size); e != nil </span><span class="cov0" title="0">{
                return &amp;PathError{"truncate", name, e}
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return nil</span>
}

// Remove removes the named file or (empty) directory.
// If there is an error, it will be of type *PathError.
func Remove(name string) error <span class="cov0" title="0">{
        // System call interface forces us to know
        // whether name is a file or directory.
        // Try both: it is cheaper on average than
        // doing a Stat plus the right one.
        e := syscall.Unlink(name)
        if e == nil </span><span class="cov0" title="0">{
                return nil
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">e1 := syscall.Rmdir(name)
        if e1 == nil </span><span class="cov0" title="0">{
                return nil
        }</span><span class="cov0" title="0">
</span>
        // Both failed: figure out which error to return.
        // OS X and Linux differ on whether unlink(dir)
        // returns EISDIR, so can't use that. However,
        // both agree that rmdir(file) returns ENOTDIR,
        // so we can use that to decide which error is real.
        // Rmdir might also return ENOTDIR if given a bad
        // file path, like /etc/passwd/foo, but in that case,
        // both errors will be ENOTDIR, so it's okay to
        // use the error from unlink.
        <span class="cov0" title="0">if e1 != syscall.ENOTDIR </span><span class="cov0" title="0">{
                e = e1
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return &amp;PathError{"remove", name, e}</span>
}

func tempDir() string <span class="cov0" title="0">{
        dir := Getenv("TMPDIR")
        if dir == "" </span><span class="cov0" title="0">{
                if runtime.GOOS == "android" </span><span class="cov0" title="0">{
                        dir = "/data/local/tmp"
                }</span><span class="cov0" title="0"> else {
                        dir = "/tmp"
                }</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">return dir</span>
}

// Link creates newname as a hard link to the oldname file.
// If there is an error, it will be of type *LinkError.
func Link(oldname, newname string) error <span class="cov0" title="0">{
        e := syscall.Link(oldname, newname)
        if e != nil </span><span class="cov0" title="0">{
                return &amp;LinkError{"link", oldname, newname, e}
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return nil</span>
}

// Symlink creates newname as a symbolic link to oldname.
// If there is an error, it will be of type *LinkError.
func Symlink(oldname, newname string) error <span class="cov0" title="0">{
        e := syscall.Symlink(oldname, newname)
        if e != nil </span><span class="cov0" title="0">{
                return &amp;LinkError{"symlink", oldname, newname, e}
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return nil</span>
}

func (f *File) readdir(n int) (fi []FileInfo, err error) <span class="cov0" title="0">{
        dirname := f.name
        if dirname == "" </span><span class="cov0" title="0">{
                dirname = "."
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">names, err := f.Readdirnames(n)
        fi = make([]FileInfo, 0, len(names))
        for _, filename := range names </span><span class="cov0" title="0">{
                fip, lerr := lstat(dirname + "/" + filename)
                if IsNotExist(lerr) </span><span class="cov0" title="0">{
                        // File disappeared between readdir + stat.
                        // Just treat it as if it didn't exist.
                        continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">if lerr != nil </span><span class="cov0" title="0">{
                        return fi, lerr
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">fi = append(fi, fip)</span>
        }
        <span class="cov0" title="0">if len(fi) == 0 &amp;&amp; err == nil &amp;&amp; n &gt; 0 </span><span class="cov0" title="0">{
                // Per File.Readdir, the slice must be non-empty or err
                // must be non-nil if n &gt; 0.
                err = io.EOF
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return fi, err</span>
}

// Readlink returns the destination of the named symbolic link.
// If there is an error, it will be of type *PathError.
func Readlink(name string) (string, error) <span class="cov0" title="0">{
        for len := 128; ; len *= 2 </span><span class="cov0" title="0">{
                b := make([]byte, len)
                n, e := fixCount(syscall.Readlink(name, b))
                // buffer too small
                if runtime.GOOS == "aix" &amp;&amp; e == syscall.ERANGE </span><span class="cov0" title="0">{
                        continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">if e != nil </span><span class="cov0" title="0">{
                        return "", &amp;PathError{"readlink", name, e}
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if n &lt; len </span><span class="cov0" title="0">{
                        return string(b[0:n]), nil
                }</span><span class="cov0" title="0">
</span>        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris

package os

import (
        "internal/syscall/unix"
        "io"
        "syscall"
)

func removeAll(path string) error <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                // fail silently to retain compatibility with previous behavior
                // of RemoveAll. See issue 28830.
                return nil
        }</span><span class="cov0" title="0">
</span>
        // The rmdir system call does not permit removing ".",
        // so we don't permit it either.
        <span class="cov0" title="0">if endsWithDot(path) </span><span class="cov0" title="0">{
                return &amp;PathError{"RemoveAll", path, syscall.EINVAL}
        }</span><span class="cov0" title="0">
</span>
        // Simple case: if Remove works, we're done.
        <span class="cov0" title="0">err := Remove(path)
        if err == nil || IsNotExist(err) </span><span class="cov0" title="0">{
                return nil
        }</span><span class="cov0" title="0">
</span>
        // RemoveAll recurses by deleting the path base from
        // its parent directory
        <span class="cov0" title="0">parentDir, base := splitPath(path)

        parent, err := Open(parentDir)
        if IsNotExist(err) </span><span class="cov0" title="0">{
                // If parent does not exist, base cannot exist. Fail silently
                return nil
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">defer parent.Close()

        if err := removeAllFrom(parent, base); err != nil </span><span class="cov0" title="0">{
                if pathErr, ok := err.(*PathError); ok </span><span class="cov0" title="0">{
                        pathErr.Path = parentDir + string(PathSeparator) + pathErr.Path
                        err = pathErr
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return err</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">return nil</span>
}

func removeAllFrom(parent *File, base string) error <span class="cov0" title="0">{
        parentFd := int(parent.Fd())
        // Simple case: if Unlink (aka remove) works, we're done.
        err := unix.Unlinkat(parentFd, base, 0)
        if err == nil || IsNotExist(err) </span><span class="cov0" title="0">{
                return nil
        }</span><span class="cov0" title="0">
</span>
        // EISDIR means that we have a directory, and we need to
        // remove its contents.
        // EPERM or EACCES means that we don't have write permission on
        // the parent directory, but this entry might still be a directory
        // whose contents need to be removed.
        // Otherwise just return the error.
        <span class="cov0" title="0">if err != syscall.EISDIR &amp;&amp; err != syscall.EPERM &amp;&amp; err != syscall.EACCES </span><span class="cov0" title="0">{
                return &amp;PathError{"unlinkat", base, err}
        }</span><span class="cov0" title="0">
</span>
        // Is this a directory we need to recurse into?
        <span class="cov0" title="0">var statInfo syscall.Stat_t
        statErr := unix.Fstatat(parentFd, base, &amp;statInfo, unix.AT_SYMLINK_NOFOLLOW)
        if statErr != nil </span><span class="cov0" title="0">{
                if IsNotExist(statErr) </span><span class="cov0" title="0">{
                        return nil
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return &amp;PathError{"fstatat", base, statErr}</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if statInfo.Mode&amp;syscall.S_IFMT != syscall.S_IFDIR </span><span class="cov0" title="0">{
                // Not a directory; return the error from the unix.Unlinkat.
                return &amp;PathError{"unlinkat", base, err}
        }</span><span class="cov0" title="0">
</span>
        // Remove the directory's entries.
        <span class="cov0" title="0">var recurseErr error
        for </span><span class="cov0" title="0">{
                const reqSize = 1024
                var respSize int

                // Open the directory to recurse into
                file, err := openFdAt(parentFd, base)
                if err != nil </span><span class="cov0" title="0">{
                        if IsNotExist(err) </span><span class="cov8" title="1">{
                                return nil
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">recurseErr = &amp;PathError{"openfdat", base, err}
                        break</span>
                }<span class="cov0" title="0">
</span>
                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        numErr := 0

                        names, readErr := file.Readdirnames(reqSize)
                        // Errors other than EOF should stop us from continuing.
                        if readErr != nil &amp;&amp; readErr != io.EOF </span><span class="cov0" title="0">{
                                file.Close()
                                if IsNotExist(readErr) </span><span class="cov0" title="0">{
                                        return nil
                                }</span><span class="cov0" title="0">
</span>                                <span class="cov0" title="0">return &amp;PathError{"readdirnames", base, readErr}</span>
                        }<span class="cov0" title="0">
</span>
                        <span class="cov0" title="0">respSize = len(names)
                        for _, name := range names </span><span class="cov0" title="0">{
                                err := removeAllFrom(file, name)
                                if err != nil </span><span class="cov0" title="0">{
                                        if pathErr, ok := err.(*PathError); ok </span><span class="cov0" title="0">{
                                                pathErr.Path = base + string(PathSeparator) + pathErr.Path
                                        }</span><span class="cov0" title="0">
</span>                                        <span class="cov0" title="0">numErr++
                                        if recurseErr == nil </span><span class="cov0" title="0">{
                                                recurseErr = err
                                        }</span><span class="cov0" title="0">
</span>                                }<span class="cov0" title="0">
</span>                        }

                        // If we can delete any entry, break to start new iteration.
                        // Otherwise, we discard current names, get next entries and try deleting them.
                        <span class="cov0" title="0">if numErr != reqSize </span><span class="cov0" title="0">{
                                break</span>
                        }<span class="cov0" title="0">
</span>                }

                // Removing files from the directory may have caused
                // the OS to reshuffle it. Simply calling Readdirnames
                // again may skip some entries. The only reliable way
                // to avoid this is to close and re-open the
                // directory. See issue 20841.
                <span class="cov0" title="0">file.Close()

                // Finish when the end of the directory is reached
                if respSize &lt; reqSize </span><span class="cov0" title="0">{
                        break</span>
                }<span class="cov0" title="0">
</span>        }

        // Remove the directory itself.
        <span class="cov0" title="0">unlinkError := unix.Unlinkat(parentFd, base, unix.AT_REMOVEDIR)
        if unlinkError == nil || IsNotExist(unlinkError) </span><span class="cov8" title="1">{
                return nil
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if recurseErr != nil </span><span class="cov0" title="0">{
                return recurseErr
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return &amp;PathError{"unlinkat", base, unlinkError}</span>
}

// openFdAt opens path relative to the directory in fd.
// Other than that this should act like openFileNolog.
// This acts like openFileNolog rather than OpenFile because
// we are going to (try to) remove the file.
// The contents of this file are not relevant for test caching.
func openFdAt(dirfd int, name string) (*File, error) <span class="cov0" title="0">{
        var r int
        for </span><span class="cov0" title="0">{
                var e error
                r, e = unix.Openat(dirfd, name, O_RDONLY|syscall.O_CLOEXEC, 0)
                if e == nil </span><span class="cov0" title="0">{
                        break</span>
                }<span class="cov0" title="0">
</span>
                // See comment in openFileNolog.
                <span class="cov0" title="0">if e == syscall.EINTR </span><span class="cov0" title="0">{
                        continue</span>
                }<span class="cov0" title="0">
</span>
                <span class="cov0" title="0">return nil, e</span>
        }

        <span class="cov0" title="0">if !supportsCloseOnExec </span><span class="cov0" title="0">{
                syscall.CloseOnExec(r)
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">return newFile(uintptr(r), name, kindOpenFile), nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package os

import (
        "syscall"
        "time"
)

func fillFileStatFromSys(fs *fileStat, name string) <span class="cov0" title="0">{
        fs.name = basename(name)
        fs.size = fs.sys.Size
        fs.modTime = timespecToTime(fs.sys.Mtim)
        fs.mode = FileMode(fs.sys.Mode &amp; 0777)
        switch fs.sys.Mode &amp; syscall.S_IFMT </span>{
        <span class="cov0" title="0">case syscall.S_IFBLK:
                fs.mode |= ModeDevice</span>
        <span class="cov0" title="0">case syscall.S_IFCHR:
                fs.mode |= ModeDevice | ModeCharDevice</span>
        <span class="cov0" title="0">case syscall.S_IFDIR:
                fs.mode |= ModeDir</span>
        <span class="cov0" title="0">case syscall.S_IFIFO:
                fs.mode |= ModeNamedPipe</span>
        <span class="cov0" title="0">case syscall.S_IFLNK:
                fs.mode |= ModeSymlink</span>
        <span class="cov0" title="0">case syscall.S_IFREG:</span>
                // nothing to do
        <span class="cov0" title="0">case syscall.S_IFSOCK:
                fs.mode |= ModeSocket</span>
        }
        <span class="cov0" title="0">if fs.sys.Mode&amp;syscall.S_ISGID != 0 </span><span class="cov0" title="0">{
                fs.mode |= ModeSetgid
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if fs.sys.Mode&amp;syscall.S_ISUID != 0 </span><span class="cov0" title="0">{
                fs.mode |= ModeSetuid
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if fs.sys.Mode&amp;syscall.S_ISVTX != 0 </span><span class="cov0" title="0">{
                fs.mode |= ModeSticky
        }</span><span class="cov0" title="0">
</span>}

func timespecToTime(ts syscall.Timespec) time.Time <span class="cov0" title="0">{
        return time.Unix(int64(ts.Sec), int64(ts.Nsec))
}</span>

// For testing.
func atime(fi FileInfo) time.Time <span class="cov0" title="0">{
        return timespecToTime(fi.Sys().(*syscall.Stat_t).Atim)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package reflect implements run-time reflection, allowing a program to
// manipulate objects with arbitrary types. The typical use is to take a value
// with static type interface{} and extract its dynamic type information by
// calling TypeOf, which returns a Type.
//
// A call to ValueOf returns a Value representing the run-time data.
// Zero takes a Type and returns a Value representing a zero value
// for that type.
//
// See "The Laws of Reflection" for an introduction to reflection in Go:
// https://golang.org/doc/articles/laws_of_reflection.html
package reflect

import (
        "internal/unsafeheader"
        "strconv"
        "sync"
        "unicode"
        "unicode/utf8"
        "unsafe"
)

// Type is the representation of a Go type.
//
// Not all methods apply to all kinds of types. Restrictions,
// if any, are noted in the documentation for each method.
// Use the Kind method to find out the kind of type before
// calling kind-specific methods. Calling a method
// inappropriate to the kind of type causes a run-time panic.
//
// Type values are comparable, such as with the == operator,
// so they can be used as map keys.
// Two Type values are equal if they represent identical types.
type Type interface {
        // Methods applicable to all types.

        // Align returns the alignment in bytes of a value of
        // this type when allocated in memory.
        Align() int

        // FieldAlign returns the alignment in bytes of a value of
        // this type when used as a field in a struct.
        FieldAlign() int

        // Method returns the i'th method in the type's method set.
        // It panics if i is not in the range [0, NumMethod()).
        //
        // For a non-interface type T or *T, the returned Method's Type and Func
        // fields describe a function whose first argument is the receiver.
        //
        // For an interface type, the returned Method's Type field gives the
        // method signature, without a receiver, and the Func field is nil.
        //
        // Only exported methods are accessible and they are sorted in
        // lexicographic order.
        Method(int) Method

        // MethodByName returns the method with that name in the type's
        // method set and a boolean indicating if the method was found.
        //
        // For a non-interface type T or *T, the returned Method's Type and Func
        // fields describe a function whose first argument is the receiver.
        //
        // For an interface type, the returned Method's Type field gives the
        // method signature, without a receiver, and the Func field is nil.
        MethodByName(string) (Method, bool)

        // NumMethod returns the number of exported methods in the type's method set.
        NumMethod() int

        // Name returns the type's name within its package for a defined type.
        // For other (non-defined) types it returns the empty string.
        Name() string

        // PkgPath returns a defined type's package path, that is, the import path
        // that uniquely identifies the package, such as "encoding/base64".
        // If the type was predeclared (string, error) or not defined (*T, struct{},
        // []int, or A where A is an alias for a non-defined type), the package path
        // will be the empty string.
        PkgPath() string

        // Size returns the number of bytes needed to store
        // a value of the given type; it is analogous to unsafe.Sizeof.
        Size() uintptr

        // String returns a string representation of the type.
        // The string representation may use shortened package names
        // (e.g., base64 instead of "encoding/base64") and is not
        // guaranteed to be unique among types. To test for type identity,
        // compare the Types directly.
        String() string

        // Kind returns the specific kind of this type.
        Kind() Kind

        // Implements reports whether the type implements the interface type u.
        Implements(u Type) bool

        // AssignableTo reports whether a value of the type is assignable to type u.
        AssignableTo(u Type) bool

        // ConvertibleTo reports whether a value of the type is convertible to type u.
        ConvertibleTo(u Type) bool

        // Comparable reports whether values of this type are comparable.
        Comparable() bool

        // Methods applicable only to some types, depending on Kind.
        // The methods allowed for each kind are:
        //
        //        Int*, Uint*, Float*, Complex*: Bits
        //        Array: Elem, Len
        //        Chan: ChanDir, Elem
        //        Func: In, NumIn, Out, NumOut, IsVariadic.
        //        Map: Key, Elem
        //        Ptr: Elem
        //        Slice: Elem
        //        Struct: Field, FieldByIndex, FieldByName, FieldByNameFunc, NumField

        // Bits returns the size of the type in bits.
        // It panics if the type's Kind is not one of the
        // sized or unsized Int, Uint, Float, or Complex kinds.
        Bits() int

        // ChanDir returns a channel type's direction.
        // It panics if the type's Kind is not Chan.
        ChanDir() ChanDir

        // IsVariadic reports whether a function type's final input parameter
        // is a "..." parameter. If so, t.In(t.NumIn() - 1) returns the parameter's
        // implicit actual type []T.
        //
        // For concreteness, if t represents func(x int, y ... float64), then
        //
        //        t.NumIn() == 2
        //        t.In(0) is the reflect.Type for "int"
        //        t.In(1) is the reflect.Type for "[]float64"
        //        t.IsVariadic() == true
        //
        // IsVariadic panics if the type's Kind is not Func.
        IsVariadic() bool

        // Elem returns a type's element type.
        // It panics if the type's Kind is not Array, Chan, Map, Ptr, or Slice.
        Elem() Type

        // Field returns a struct type's i'th field.
        // It panics if the type's Kind is not Struct.
        // It panics if i is not in the range [0, NumField()).
        Field(i int) StructField

        // FieldByIndex returns the nested field corresponding
        // to the index sequence. It is equivalent to calling Field
        // successively for each index i.
        // It panics if the type's Kind is not Struct.
        FieldByIndex(index []int) StructField

        // FieldByName returns the struct field with the given name
        // and a boolean indicating if the field was found.
        FieldByName(name string) (StructField, bool)

        // FieldByNameFunc returns the struct field with a name
        // that satisfies the match function and a boolean indicating if
        // the field was found.
        //
        // FieldByNameFunc considers the fields in the struct itself
        // and then the fields in any embedded structs, in breadth first order,
        // stopping at the shallowest nesting depth containing one or more
        // fields satisfying the match function. If multiple fields at that depth
        // satisfy the match function, they cancel each other
        // and FieldByNameFunc returns no match.
        // This behavior mirrors Go's handling of name lookup in
        // structs containing embedded fields.
        FieldByNameFunc(match func(string) bool) (StructField, bool)

        // In returns the type of a function type's i'th input parameter.
        // It panics if the type's Kind is not Func.
        // It panics if i is not in the range [0, NumIn()).
        In(i int) Type

        // Key returns a map type's key type.
        // It panics if the type's Kind is not Map.
        Key() Type

        // Len returns an array type's length.
        // It panics if the type's Kind is not Array.
        Len() int

        // NumField returns a struct type's field count.
        // It panics if the type's Kind is not Struct.
        NumField() int

        // NumIn returns a function type's input parameter count.
        // It panics if the type's Kind is not Func.
        NumIn() int

        // NumOut returns a function type's output parameter count.
        // It panics if the type's Kind is not Func.
        NumOut() int

        // Out returns the type of a function type's i'th output parameter.
        // It panics if the type's Kind is not Func.
        // It panics if i is not in the range [0, NumOut()).
        Out(i int) Type

        common() *rtype
        uncommon() *uncommonType
}

// BUG(rsc): FieldByName and related functions consider struct field names to be equal
// if the names are equal, even if they are unexported names originating
// in different packages. The practical effect of this is that the result of
// t.FieldByName("x") is not well defined if the struct type t contains
// multiple fields named x (embedded from different packages).
// FieldByName may return one of the fields named x or may report that there are none.
// See https://golang.org/issue/4876 for more details.

/*
 * These data structures are known to the compiler (../../cmd/internal/gc/reflect.go).
 * A few are known to ../runtime/type.go to convey to debuggers.
 * They are also known to ../runtime/type.go.
 */

// A Kind represents the specific kind of type that a Type represents.
// The zero Kind is not a valid kind.
type Kind uint

const (
        Invalid Kind = iota
        Bool
        Int
        Int8
        Int16
        Int32
        Int64
        Uint
        Uint8
        Uint16
        Uint32
        Uint64
        Uintptr
        Float32
        Float64
        Complex64
        Complex128
        Array
        Chan
        Func
        Interface
        Map
        Ptr
        Slice
        String
        Struct
        UnsafePointer
)

// tflag is used by an rtype to signal what extra type information is
// available in the memory directly following the rtype value.
//
// tflag values must be kept in sync with copies in:
//        cmd/compile/internal/gc/reflect.go
//        cmd/link/internal/ld/decodesym.go
//        runtime/type.go
type tflag uint8

const (
        // tflagUncommon means that there is a pointer, *uncommonType,
        // just beyond the outer type structure.
        //
        // For example, if t.Kind() == Struct and t.tflag&amp;tflagUncommon != 0,
        // then t has uncommonType data and it can be accessed as:
        //
        //        type tUncommon struct {
        //                structType
        //                u uncommonType
        //        }
        //        u := &amp;(*tUncommon)(unsafe.Pointer(t)).u
        tflagUncommon tflag = 1 &lt;&lt; 0

        // tflagExtraStar means the name in the str field has an
        // extraneous '*' prefix. This is because for most types T in
        // a program, the type *T also exists and reusing the str data
        // saves binary size.
        tflagExtraStar tflag = 1 &lt;&lt; 1

        // tflagNamed means the type has a name.
        tflagNamed tflag = 1 &lt;&lt; 2

        // tflagRegularMemory means that equal and hash functions can treat
        // this type as a single region of t.size bytes.
        tflagRegularMemory tflag = 1 &lt;&lt; 3
)

// rtype is the common implementation of most values.
// It is embedded in other struct types.
//
// rtype must be kept in sync with ../runtime/type.go:/^type._type.
type rtype struct {
        size       uintptr
        ptrdata    uintptr // number of bytes in the type that can contain pointers
        hash       uint32  // hash of type; avoids computation in hash tables
        tflag      tflag   // extra type information flags
        align      uint8   // alignment of variable with this type
        fieldAlign uint8   // alignment of struct field with this type
        kind       uint8   // enumeration for C
        // function for comparing objects of this type
        // (ptr to object A, ptr to object B) -&gt; ==?
        equal     func(unsafe.Pointer, unsafe.Pointer) bool
        gcdata    *byte   // garbage collection data
        str       nameOff // string form
        ptrToThis typeOff // type for pointer to this type, may be zero
}

// Method on non-interface type
type method struct {
        name nameOff // name of method
        mtyp typeOff // method type (without receiver)
        ifn  textOff // fn used in interface call (one-word receiver)
        tfn  textOff // fn used for normal method call
}

// uncommonType is present only for defined types or types with methods
// (if T is a defined type, the uncommonTypes for T and *T have methods).
// Using a pointer to this struct reduces the overall size required
// to describe a non-defined type with no methods.
type uncommonType struct {
        pkgPath nameOff // import path; empty for built-in types like int, string
        mcount  uint16  // number of methods
        xcount  uint16  // number of exported methods
        moff    uint32  // offset from this uncommontype to [mcount]method
        _       uint32  // unused
}

// ChanDir represents a channel type's direction.
type ChanDir int

const (
        RecvDir ChanDir             = 1 &lt;&lt; iota // &lt;-chan
        SendDir                                 // chan&lt;-
        BothDir = RecvDir | SendDir             // chan
)

// arrayType represents a fixed array type.
type arrayType struct {
        rtype
        elem  *rtype // array element type
        slice *rtype // slice type
        len   uintptr
}

// chanType represents a channel type.
type chanType struct {
        rtype
        elem *rtype  // channel element type
        dir  uintptr // channel direction (ChanDir)
}

// funcType represents a function type.
//
// A *rtype for each in and out parameter is stored in an array that
// directly follows the funcType (and possibly its uncommonType). So
// a function type with one method, one input, and one output is:
//
//        struct {
//                funcType
//                uncommonType
//                [2]*rtype    // [0] is in, [1] is out
//        }
type funcType struct {
        rtype
        inCount  uint16
        outCount uint16 // top bit is set if last input parameter is ...
}

// imethod represents a method on an interface type
type imethod struct {
        name nameOff // name of method
        typ  typeOff // .(*FuncType) underneath
}

// interfaceType represents an interface type.
type interfaceType struct {
        rtype
        pkgPath name      // import path
        methods []imethod // sorted by hash
}

// mapType represents a map type.
type mapType struct {
        rtype
        key    *rtype // map key type
        elem   *rtype // map element (value) type
        bucket *rtype // internal bucket structure
        // function for hashing keys (ptr to key, seed) -&gt; hash
        hasher     func(unsafe.Pointer, uintptr) uintptr
        keysize    uint8  // size of key slot
        valuesize  uint8  // size of value slot
        bucketsize uint16 // size of bucket
        flags      uint32
}

// ptrType represents a pointer type.
type ptrType struct {
        rtype
        elem *rtype // pointer element (pointed at) type
}

// sliceType represents a slice type.
type sliceType struct {
        rtype
        elem *rtype // slice element type
}

// Struct field
type structField struct {
        name        name    // name is always non-empty
        typ         *rtype  // type of field
        offsetEmbed uintptr // byte offset of field&lt;&lt;1 | isEmbedded
}

func (f *structField) offset() uintptr <span class="cov0" title="0">{
        return f.offsetEmbed &gt;&gt; 1
}</span>

func (f *structField) embedded() bool <span class="cov0" title="0">{
        return f.offsetEmbed&amp;1 != 0
}</span>

// structType represents a struct type.
type structType struct {
        rtype
        pkgPath name
        fields  []structField // sorted by offset
}

// name is an encoded type name with optional extra data.
//
// The first byte is a bit field containing:
//
//        1&lt;&lt;0 the name is exported
//        1&lt;&lt;1 tag data follows the name
//        1&lt;&lt;2 pkgPath nameOff follows the name and tag
//
// The next two bytes are the data length:
//
//         l := uint16(data[1])&lt;&lt;8 | uint16(data[2])
//
// Bytes [3:3+l] are the string data.
//
// If tag data follows then bytes 3+l and 3+l+1 are the tag length,
// with the data following.
//
// If the import path follows, then 4 bytes at the end of
// the data form a nameOff. The import path is only set for concrete
// methods that are defined in a different package than their type.
//
// If a name starts with "*", then the exported bit represents
// whether the pointed to type is exported.
type name struct {
        bytes *byte
}

func (n name) data(off int, whySafe string) *byte <span class="cov0" title="0">{
        return (*byte)(add(unsafe.Pointer(n.bytes), uintptr(off), whySafe))
}</span>

func (n name) isExported() bool <span class="cov0" title="0">{
        return (*n.bytes)&amp;(1&lt;&lt;0) != 0
}</span>

func (n name) nameLen() int <span class="cov0" title="0">{
        return int(uint16(*n.data(1, "name len field"))&lt;&lt;8 | uint16(*n.data(2, "name len field")))
}</span>

func (n name) tagLen() int <span class="cov0" title="0">{
        if *n.data(0, "name flag field")&amp;(1&lt;&lt;1) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">off := 3 + n.nameLen()
        return int(uint16(*n.data(off, "name taglen field"))&lt;&lt;8 | uint16(*n.data(off+1, "name taglen field")))</span>
}

func (n name) name() (s string) <span class="cov0" title="0">{
        if n.bytes == nil </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">b := (*[4]byte)(unsafe.Pointer(n.bytes))

        hdr := (*unsafeheader.String)(unsafe.Pointer(&amp;s))
        hdr.Data = unsafe.Pointer(&amp;b[3])
        hdr.Len = int(b[1])&lt;&lt;8 | int(b[2])
        return s</span>
}

func (n name) tag() (s string) <span class="cov0" title="0">{
        tl := n.tagLen()
        if tl == 0 </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">nl := n.nameLen()
        hdr := (*unsafeheader.String)(unsafe.Pointer(&amp;s))
        hdr.Data = unsafe.Pointer(n.data(3+nl+2, "non-empty string"))
        hdr.Len = tl
        return s</span>
}

func (n name) pkgPath() string <span class="cov0" title="0">{
        if n.bytes == nil || *n.data(0, "name flag field")&amp;(1&lt;&lt;2) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">off := 3 + n.nameLen()
        if tl := n.tagLen(); tl &gt; 0 </span><span class="cov0" title="0">{
                off += 2 + tl
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">var nameOff int32
        // Note that this field may not be aligned in memory,
        // so we cannot use a direct int32 assignment here.
        copy((*[4]byte)(unsafe.Pointer(&amp;nameOff))[:], (*[4]byte)(unsafe.Pointer(n.data(off, "name offset field")))[:])
        pkgPathName := name{(*byte)(resolveTypeOff(unsafe.Pointer(n.bytes), nameOff))}
        return pkgPathName.name()</span>
}

func newName(n, tag string, exported bool) name <span class="cov0" title="0">{
        if len(n) &gt; 1&lt;&lt;16-1 </span><span class="cov0" title="0">{
                panic("reflect.nameFrom: name too long: " + n)</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if len(tag) &gt; 1&lt;&lt;16-1 </span><span class="cov0" title="0">{
                panic("reflect.nameFrom: tag too long: " + tag)</span>
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">var bits byte
        l := 1 + 2 + len(n)
        if exported </span><span class="cov0" title="0">{
                bits |= 1 &lt;&lt; 0
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if len(tag) &gt; 0 </span><span class="cov0" title="0">{
                l += 2 + len(tag)
                bits |= 1 &lt;&lt; 1
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">b := make([]byte, l)
        b[0] = bits
        b[1] = uint8(len(n) &gt;&gt; 8)
        b[2] = uint8(len(n))
        copy(b[3:], n)
        if len(tag) &gt; 0 </span><span class="cov0" title="0">{
                tb := b[3+len(n):]
                tb[0] = uint8(len(tag) &gt;&gt; 8)
                tb[1] = uint8(len(tag))
                copy(tb[2:], tag)
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">return name{bytes: &amp;b[0]}</span>
}

/*
 * The compiler knows the exact layout of all the data structures above.
 * The compiler does not know about the data structures and methods below.
 */

// Method represents a single method.
type Method struct {
        // Name is the method name.
        // PkgPath is the package path that qualifies a lower case (unexported)
        // method name. It is empty for upper case (exported) method names.
        // The combination of PkgPath and Name uniquely identifies a method
        // in a method set.
        // See https://golang.org/ref/spec#Uniqueness_of_identifiers
        Name    string
        PkgPath string

        Type  Type  // method type
        Func  Value // func with receiver as first argument
        Index int   // index for Type.Method
}

const (
        kindDirectIface = 1 &lt;&lt; 5
        kindGCProg      = 1 &lt;&lt; 6 // Type.gc points to GC program
        kindMask        = (1 &lt;&lt; 5) - 1
)

// String returns the name of k.
func (k Kind) String() string <span class="cov0" title="0">{
        if int(k) &lt; len(kindNames) </span><span class="cov0" title="0">{
                return kindNames[k]
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return "kind" + strconv.Itoa(int(k))</span>
}

var kindNames = []string{
        Invalid:       "invalid",
        Bool:          "bool",
        Int:           "int",
        Int8:          "int8",
        Int16:         "int16",
        Int32:         "int32",
        Int64:         "int64",
        Uint:          "uint",
        Uint8:         "uint8",
        Uint16:        "uint16",
        Uint32:        "uint32",
        Uint64:        "uint64",
        Uintptr:       "uintptr",
        Float32:       "float32",
        Float64:       "float64",
        Complex64:     "complex64",
        Complex128:    "complex128",
        Array:         "array",
        Chan:          "chan",
        Func:          "func",
        Interface:     "interface",
        Map:           "map",
        Ptr:           "ptr",
        Slice:         "slice",
        String:        "string",
        Struct:        "struct",
        UnsafePointer: "unsafe.Pointer",
}

func (t *uncommonType) methods() []method <span class="cov0" title="0">{
        if t.mcount == 0 </span><span class="cov0" title="0">{
                return nil
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return (*[1 &lt;&lt; 16]method)(add(unsafe.Pointer(t), uintptr(t.moff), "t.mcount &gt; 0"))[:t.mcount:t.mcount]</span>
}

func (t *uncommonType) exportedMethods() []method <span class="cov0" title="0">{
        if t.xcount == 0 </span><span class="cov0" title="0">{
                return nil
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return (*[1 &lt;&lt; 16]method)(add(unsafe.Pointer(t), uintptr(t.moff), "t.xcount &gt; 0"))[:t.xcount:t.xcount]</span>
}

// resolveNameOff resolves a name offset from a base pointer.
// The (*rtype).nameOff method is a convenience wrapper for this function.
// Implemented in the runtime package.
func resolveNameOff(ptrInModule unsafe.Pointer, off int32) unsafe.Pointer

// resolveTypeOff resolves an *rtype offset from a base type.
// The (*rtype).typeOff method is a convenience wrapper for this function.
// Implemented in the runtime package.
func resolveTypeOff(rtype unsafe.Pointer, off int32) unsafe.Pointer

// resolveTextOff resolves a function pointer offset from a base type.
// The (*rtype).textOff method is a convenience wrapper for this function.
// Implemented in the runtime package.
func resolveTextOff(rtype unsafe.Pointer, off int32) unsafe.Pointer

// addReflectOff adds a pointer to the reflection lookup map in the runtime.
// It returns a new ID that can be used as a typeOff or textOff, and will
// be resolved correctly. Implemented in the runtime package.
func addReflectOff(ptr unsafe.Pointer) int32

// resolveReflectName adds a name to the reflection lookup map in the runtime.
// It returns a new nameOff that can be used to refer to the pointer.
func resolveReflectName(n name) nameOff <span class="cov0" title="0">{
        return nameOff(addReflectOff(unsafe.Pointer(n.bytes)))
}</span>

// resolveReflectType adds a *rtype to the reflection lookup map in the runtime.
// It returns a new typeOff that can be used to refer to the pointer.
func resolveReflectType(t *rtype) typeOff <span class="cov0" title="0">{
        return typeOff(addReflectOff(unsafe.Pointer(t)))
}</span>

// resolveReflectText adds a function pointer to the reflection lookup map in
// the runtime. It returns a new textOff that can be used to refer to the
// pointer.
func resolveReflectText(ptr unsafe.Pointer) textOff <span class="cov0" title="0">{
        return textOff(addReflectOff(ptr))
}</span>

type nameOff int32 // offset to a name
type typeOff int32 // offset to an *rtype
type textOff int32 // offset from top of text section

func (t *rtype) nameOff(off nameOff) name <span class="cov0" title="0">{
        return name{(*byte)(resolveNameOff(unsafe.Pointer(t), int32(off)))}
}</span>

func (t *rtype) typeOff(off typeOff) *rtype <span class="cov0" title="0">{
        return (*rtype)(resolveTypeOff(unsafe.Pointer(t), int32(off)))
}</span>

func (t *rtype) textOff(off textOff) unsafe.Pointer <span class="cov0" title="0">{
        return resolveTextOff(unsafe.Pointer(t), int32(off))
}</span>

func (t *rtype) uncommon() *uncommonType <span class="cov0" title="0">{
        if t.tflag&amp;tflagUncommon == 0 </span><span class="cov0" title="0">{
                return nil
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">switch t.Kind() </span>{
        <span class="cov0" title="0">case Struct:
                return &amp;(*structTypeUncommon)(unsafe.Pointer(t)).u</span>
        <span class="cov0" title="0">case Ptr:
                type u struct {
                        ptrType
                        u uncommonType
                }
                return &amp;(*u)(unsafe.Pointer(t)).u</span>
        <span class="cov0" title="0">case Func:
                type u struct {
                        funcType
                        u uncommonType
                }
                return &amp;(*u)(unsafe.Pointer(t)).u</span>
        <span class="cov0" title="0">case Slice:
                type u struct {
                        sliceType
                        u uncommonType
                }
                return &amp;(*u)(unsafe.Pointer(t)).u</span>
        <span class="cov0" title="0">case Array:
                type u struct {
                        arrayType
                        u uncommonType
                }
                return &amp;(*u)(unsafe.Pointer(t)).u</span>
        <span class="cov0" title="0">case Chan:
                type u struct {
                        chanType
                        u uncommonType
                }
                return &amp;(*u)(unsafe.Pointer(t)).u</span>
        <span class="cov0" title="0">case Map:
                type u struct {
                        mapType
                        u uncommonType
                }
                return &amp;(*u)(unsafe.Pointer(t)).u</span>
        <span class="cov0" title="0">case Interface:
                type u struct {
                        interfaceType
                        u uncommonType
                }
                return &amp;(*u)(unsafe.Pointer(t)).u</span>
        <span class="cov0" title="0">default:
                type u struct {
                        rtype
                        u uncommonType
                }
                return &amp;(*u)(unsafe.Pointer(t)).u</span>
        }
}

func (t *rtype) String() string <span class="cov0" title="0">{
        s := t.nameOff(t.str).name()
        if t.tflag&amp;tflagExtraStar != 0 </span><span class="cov0" title="0">{
                return s[1:]
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return s</span>
}

func (t *rtype) Size() uintptr <span class="cov0" title="0">{ return t.size }</span>

func (t *rtype) Bits() int <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                panic("reflect: Bits of nil Type")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">k := t.Kind()
        if k &lt; Int || k &gt; Complex128 </span><span class="cov0" title="0">{
                panic("reflect: Bits of non-arithmetic Type " + t.String())</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">return int(t.size) * 8</span>
}

func (t *rtype) Align() int <span class="cov0" title="0">{ return int(t.align) }</span>

func (t *rtype) FieldAlign() int <span class="cov0" title="0">{ return int(t.fieldAlign) }</span>

func (t *rtype) Kind() Kind <span class="cov0" title="0">{ return Kind(t.kind &amp; kindMask) }</span>

func (t *rtype) pointers() bool <span class="cov0" title="0">{ return t.ptrdata != 0 }</span>

func (t *rtype) common() *rtype <span class="cov0" title="0">{ return t }</span>

func (t *rtype) exportedMethods() []method <span class="cov0" title="0">{
        ut := t.uncommon()
        if ut == nil </span><span class="cov0" title="0">{
                return nil
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return ut.exportedMethods()</span>
}

func (t *rtype) NumMethod() int <span class="cov0" title="0">{
        if t.Kind() == Interface </span><span class="cov0" title="0">{
                tt := (*interfaceType)(unsafe.Pointer(t))
                return tt.NumMethod()
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return len(t.exportedMethods())</span>
}

func (t *rtype) Method(i int) (m Method) <span class="cov0" title="0">{
        if t.Kind() == Interface </span><span class="cov0" title="0">{
                tt := (*interfaceType)(unsafe.Pointer(t))
                return tt.Method(i)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">methods := t.exportedMethods()
        if i &lt; 0 || i &gt;= len(methods) </span><span class="cov0" title="0">{
                panic("reflect: Method index out of range")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">p := methods[i]
        pname := t.nameOff(p.name)
        m.Name = pname.name()
        fl := flag(Func)
        mtyp := t.typeOff(p.mtyp)
        ft := (*funcType)(unsafe.Pointer(mtyp))
        in := make([]Type, 0, 1+len(ft.in()))
        in = append(in, t)
        for _, arg := range ft.in() </span><span class="cov0" title="0">{
                in = append(in, arg)
        }</span>
        <span class="cov0" title="0">out := make([]Type, 0, len(ft.out()))
        for _, ret := range ft.out() </span><span class="cov0" title="0">{
                out = append(out, ret)
        }</span>
        <span class="cov0" title="0">mt := FuncOf(in, out, ft.IsVariadic())
        m.Type = mt
        tfn := t.textOff(p.tfn)
        fn := unsafe.Pointer(&amp;tfn)
        m.Func = Value{mt.(*rtype), fn, fl}

        m.Index = i
        return m</span>
}

func (t *rtype) MethodByName(name string) (m Method, ok bool) <span class="cov0" title="0">{
        if t.Kind() == Interface </span><span class="cov0" title="0">{
                tt := (*interfaceType)(unsafe.Pointer(t))
                return tt.MethodByName(name)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">ut := t.uncommon()
        if ut == nil </span><span class="cov0" title="0">{
                return Method{}, false
        }</span><span class="cov0" title="0">
</span>        // TODO(mdempsky): Binary search.
        <span class="cov0" title="0">for i, p := range ut.exportedMethods() </span><span class="cov0" title="0">{
                if t.nameOff(p.name).name() == name </span><span class="cov0" title="0">{
                        return t.Method(i), true
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return Method{}, false</span>
}

func (t *rtype) PkgPath() string <span class="cov0" title="0">{
        if t.tflag&amp;tflagNamed == 0 </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">ut := t.uncommon()
        if ut == nil </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return t.nameOff(ut.pkgPath).name()</span>
}

func (t *rtype) hasName() bool <span class="cov0" title="0">{
        return t.tflag&amp;tflagNamed != 0
}</span>

func (t *rtype) Name() string <span class="cov0" title="0">{
        if !t.hasName() </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">s := t.String()
        i := len(s) - 1
        for i &gt;= 0 &amp;&amp; s[i] != '.' </span><span class="cov0" title="0">{
                i--
        }</span>
        <span class="cov0" title="0">return s[i+1:]</span>
}

func (t *rtype) ChanDir() ChanDir <span class="cov0" title="0">{
        if t.Kind() != Chan </span><span class="cov0" title="0">{
                panic("reflect: ChanDir of non-chan type " + t.String())</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">tt := (*chanType)(unsafe.Pointer(t))
        return ChanDir(tt.dir)</span>
}

func (t *rtype) IsVariadic() bool <span class="cov0" title="0">{
        if t.Kind() != Func </span><span class="cov0" title="0">{
                panic("reflect: IsVariadic of non-func type " + t.String())</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">tt := (*funcType)(unsafe.Pointer(t))
        return tt.outCount&amp;(1&lt;&lt;15) != 0</span>
}

func (t *rtype) Elem() Type <span class="cov0" title="0">{
        switch t.Kind() </span>{
        <span class="cov0" title="0">case Array:
                tt := (*arrayType)(unsafe.Pointer(t))
                return toType(tt.elem)</span>
        <span class="cov0" title="0">case Chan:
                tt := (*chanType)(unsafe.Pointer(t))
                return toType(tt.elem)</span>
        <span class="cov0" title="0">case Map:
                tt := (*mapType)(unsafe.Pointer(t))
                return toType(tt.elem)</span>
        <span class="cov0" title="0">case Ptr:
                tt := (*ptrType)(unsafe.Pointer(t))
                return toType(tt.elem)</span>
        <span class="cov0" title="0">case Slice:
                tt := (*sliceType)(unsafe.Pointer(t))
                return toType(tt.elem)</span>
        }
        <span class="cov0" title="0">panic("reflect: Elem of invalid type " + t.String())</span>
}

func (t *rtype) Field(i int) StructField <span class="cov0" title="0">{
        if t.Kind() != Struct </span><span class="cov0" title="0">{
                panic("reflect: Field of non-struct type " + t.String())</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">tt := (*structType)(unsafe.Pointer(t))
        return tt.Field(i)</span>
}

func (t *rtype) FieldByIndex(index []int) StructField <span class="cov0" title="0">{
        if t.Kind() != Struct </span><span class="cov0" title="0">{
                panic("reflect: FieldByIndex of non-struct type " + t.String())</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">tt := (*structType)(unsafe.Pointer(t))
        return tt.FieldByIndex(index)</span>
}

func (t *rtype) FieldByName(name string) (StructField, bool) <span class="cov0" title="0">{
        if t.Kind() != Struct </span><span class="cov0" title="0">{
                panic("reflect: FieldByName of non-struct type " + t.String())</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">tt := (*structType)(unsafe.Pointer(t))
        return tt.FieldByName(name)</span>
}

func (t *rtype) FieldByNameFunc(match func(string) bool) (StructField, bool) <span class="cov0" title="0">{
        if t.Kind() != Struct </span><span class="cov0" title="0">{
                panic("reflect: FieldByNameFunc of non-struct type " + t.String())</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">tt := (*structType)(unsafe.Pointer(t))
        return tt.FieldByNameFunc(match)</span>
}

func (t *rtype) In(i int) Type <span class="cov0" title="0">{
        if t.Kind() != Func </span><span class="cov0" title="0">{
                panic("reflect: In of non-func type " + t.String())</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">tt := (*funcType)(unsafe.Pointer(t))
        return toType(tt.in()[i])</span>
}

func (t *rtype) Key() Type <span class="cov0" title="0">{
        if t.Kind() != Map </span><span class="cov0" title="0">{
                panic("reflect: Key of non-map type " + t.String())</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">tt := (*mapType)(unsafe.Pointer(t))
        return toType(tt.key)</span>
}

func (t *rtype) Len() int <span class="cov0" title="0">{
        if t.Kind() != Array </span><span class="cov0" title="0">{
                panic("reflect: Len of non-array type " + t.String())</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">tt := (*arrayType)(unsafe.Pointer(t))
        return int(tt.len)</span>
}

func (t *rtype) NumField() int <span class="cov0" title="0">{
        if t.Kind() != Struct </span><span class="cov0" title="0">{
                panic("reflect: NumField of non-struct type " + t.String())</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">tt := (*structType)(unsafe.Pointer(t))
        return len(tt.fields)</span>
}

func (t *rtype) NumIn() int <span class="cov0" title="0">{
        if t.Kind() != Func </span><span class="cov0" title="0">{
                panic("reflect: NumIn of non-func type " + t.String())</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">tt := (*funcType)(unsafe.Pointer(t))
        return int(tt.inCount)</span>
}

func (t *rtype) NumOut() int <span class="cov0" title="0">{
        if t.Kind() != Func </span><span class="cov0" title="0">{
                panic("reflect: NumOut of non-func type " + t.String())</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">tt := (*funcType)(unsafe.Pointer(t))
        return len(tt.out())</span>
}

func (t *rtype) Out(i int) Type <span class="cov0" title="0">{
        if t.Kind() != Func </span><span class="cov0" title="0">{
                panic("reflect: Out of non-func type " + t.String())</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">tt := (*funcType)(unsafe.Pointer(t))
        return toType(tt.out()[i])</span>
}

func (t *funcType) in() []*rtype <span class="cov0" title="0">{
        uadd := unsafe.Sizeof(*t)
        if t.tflag&amp;tflagUncommon != 0 </span><span class="cov0" title="0">{
                uadd += unsafe.Sizeof(uncommonType{})
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if t.inCount == 0 </span><span class="cov0" title="0">{
                return nil
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return (*[1 &lt;&lt; 20]*rtype)(add(unsafe.Pointer(t), uadd, "t.inCount &gt; 0"))[:t.inCount:t.inCount]</span>
}

func (t *funcType) out() []*rtype <span class="cov0" title="0">{
        uadd := unsafe.Sizeof(*t)
        if t.tflag&amp;tflagUncommon != 0 </span><span class="cov0" title="0">{
                uadd += unsafe.Sizeof(uncommonType{})
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">outCount := t.outCount &amp; (1&lt;&lt;15 - 1)
        if outCount == 0 </span><span class="cov0" title="0">{
                return nil
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return (*[1 &lt;&lt; 20]*rtype)(add(unsafe.Pointer(t), uadd, "outCount &gt; 0"))[t.inCount : t.inCount+outCount : t.inCount+outCount]</span>
}

// add returns p+x.
//
// The whySafe string is ignored, so that the function still inlines
// as efficiently as p+x, but all call sites should use the string to
// record why the addition is safe, which is to say why the addition
// does not cause x to advance to the very end of p's allocation
// and therefore point incorrectly at the next block in memory.
func add(p unsafe.Pointer, x uintptr, whySafe string) unsafe.Pointer <span class="cov0" title="0">{
        return unsafe.Pointer(uintptr(p) + x)
}</span>

func (d ChanDir) String() string <span class="cov0" title="0">{
        switch d </span>{
        <span class="cov0" title="0">case SendDir:
                return "chan&lt;-"</span>
        <span class="cov0" title="0">case RecvDir:
                return "&lt;-chan"</span>
        <span class="cov0" title="0">case BothDir:
                return "chan"</span>
        }
        <span class="cov0" title="0">return "ChanDir" + strconv.Itoa(int(d))</span>
}

// Method returns the i'th method in the type's method set.
func (t *interfaceType) Method(i int) (m Method) <span class="cov0" title="0">{
        if i &lt; 0 || i &gt;= len(t.methods) </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">p := &amp;t.methods[i]
        pname := t.nameOff(p.name)
        m.Name = pname.name()
        if !pname.isExported() </span><span class="cov0" title="0">{
                m.PkgPath = pname.pkgPath()
                if m.PkgPath == "" </span><span class="cov0" title="0">{
                        m.PkgPath = t.pkgPath.name()
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">m.Type = toType(t.typeOff(p.typ))
        m.Index = i
        return</span>
}

// NumMethod returns the number of interface methods in the type's method set.
func (t *interfaceType) NumMethod() int <span class="cov0" title="0">{ return len(t.methods) }</span>

// MethodByName method with the given name in the type's method set.
func (t *interfaceType) MethodByName(name string) (m Method, ok bool) <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">var p *imethod
        for i := range t.methods </span><span class="cov8" title="1">{
                p = &amp;t.methods[i]
                if t.nameOff(p.name).name() == name </span><span class="cov0" title="0">{
                        return t.Method(i), true
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return</span>
}

// A StructField describes a single field in a struct.
type StructField struct {
        // Name is the field name.
        Name string
        // PkgPath is the package path that qualifies a lower case (unexported)
        // field name. It is empty for upper case (exported) field names.
        // See https://golang.org/ref/spec#Uniqueness_of_identifiers
        PkgPath string

        Type      Type      // field type
        Tag       StructTag // field tag string
        Offset    uintptr   // offset within struct, in bytes
        Index     []int     // index sequence for Type.FieldByIndex
        Anonymous bool      // is an embedded field
}

// A StructTag is the tag string in a struct field.
//
// By convention, tag strings are a concatenation of
// optionally space-separated key:"value" pairs.
// Each key is a non-empty string consisting of non-control
// characters other than space (U+0020 ' '), quote (U+0022 '"'),
// and colon (U+003A ':').  Each value is quoted using U+0022 '"'
// characters and Go string literal syntax.
type StructTag string

// Get returns the value associated with key in the tag string.
// If there is no such key in the tag, Get returns the empty string.
// If the tag does not have the conventional format, the value
// returned by Get is unspecified. To determine whether a tag is
// explicitly set to the empty string, use Lookup.
func (tag StructTag) Get(key string) string <span class="cov0" title="0">{
        v, _ := tag.Lookup(key)
        return v
}</span>

// Lookup returns the value associated with key in the tag string.
// If the key is present in the tag the value (which may be empty)
// is returned. Otherwise the returned value will be the empty string.
// The ok return value reports whether the value was explicitly set in
// the tag string. If the tag does not have the conventional format,
// the value returned by Lookup is unspecified.
func (tag StructTag) Lookup(key string) (value string, ok bool) <span class="cov0" title="0">{
        // When modifying this code, also update the validateStructTag code
        // in cmd/vet/structtag.go.

        for tag != "" </span><span class="cov0" title="0">{
                // Skip leading space.
                i := 0
                for i &lt; len(tag) &amp;&amp; tag[i] == ' ' </span><span class="cov0" title="0">{
                        i++
                }</span>
                <span class="cov0" title="0">tag = tag[i:]
                if tag == "" </span><span class="cov0" title="0">{
                        break</span>
                }<span class="cov0" title="0">
</span>
                // Scan to colon. A space, a quote or a control character is a syntax error.
                // Strictly speaking, control chars include the range [0x7f, 0x9f], not just
                // [0x00, 0x1f], but in practice, we ignore the multi-byte control characters
                // as it is simpler to inspect the tag's bytes than the tag's runes.
                <span class="cov0" title="0">i = 0
                for i &lt; len(tag) &amp;&amp; tag[i] &gt; ' ' &amp;&amp; tag[i] != ':' &amp;&amp; tag[i] != '"' &amp;&amp; tag[i] != 0x7f </span><span class="cov0" title="0">{
                        i++
                }</span>
                <span class="cov0" title="0">if i == 0 || i+1 &gt;= len(tag) || tag[i] != ':' || tag[i+1] != '"' </span><span class="cov0" title="0">{
                        break</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">name := string(tag[:i])
                tag = tag[i+1:]

                // Scan quoted string to find value.
                i = 1
                for i &lt; len(tag) &amp;&amp; tag[i] != '"' </span><span class="cov0" title="0">{
                        if tag[i] == '\\' </span><span class="cov0" title="0">{
                                i++
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">i++</span>
                }
                <span class="cov0" title="0">if i &gt;= len(tag) </span><span class="cov0" title="0">{
                        break</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">qvalue := string(tag[:i+1])
                tag = tag[i+1:]

                if key == name </span><span class="cov0" title="0">{
                        value, err := strconv.Unquote(qvalue)
                        if err != nil </span><span class="cov0" title="0">{
                                break</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">return value, true</span>
                }<span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return "", false</span>
}

// Field returns the i'th struct field.
func (t *structType) Field(i int) (f StructField) <span class="cov0" title="0">{
        if i &lt; 0 || i &gt;= len(t.fields) </span><span class="cov0" title="0">{
                panic("reflect: Field index out of bounds")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">p := &amp;t.fields[i]
        f.Type = toType(p.typ)
        f.Name = p.name.name()
        f.Anonymous = p.embedded()
        if !p.name.isExported() </span><span class="cov0" title="0">{
                f.PkgPath = t.pkgPath.name()
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if tag := p.name.tag(); tag != "" </span><span class="cov0" title="0">{
                f.Tag = StructTag(tag)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">f.Offset = p.offset()

        // NOTE(rsc): This is the only allocation in the interface
        // presented by a reflect.Type. It would be nice to avoid,
        // at least in the common cases, but we need to make sure
        // that misbehaving clients of reflect cannot affect other
        // uses of reflect. One possibility is CL 5371098, but we
        // postponed that ugliness until there is a demonstrated
        // need for the performance. This is issue 2320.
        f.Index = []int{i}
        return</span>
}

// TODO(gri): Should there be an error/bool indicator if the index
//            is wrong for FieldByIndex?

// FieldByIndex returns the nested field corresponding to index.
func (t *structType) FieldByIndex(index []int) (f StructField) <span class="cov0" title="0">{
        f.Type = toType(&amp;t.rtype)
        for i, x := range index </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        ft := f.Type
                        if ft.Kind() == Ptr &amp;&amp; ft.Elem().Kind() == Struct </span><span class="cov0" title="0">{
                                ft = ft.Elem()
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">f.Type = ft</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">f = f.Type.Field(x)</span>
        }
        <span class="cov0" title="0">return</span>
}

// A fieldScan represents an item on the fieldByNameFunc scan work list.
type fieldScan struct {
        typ   *structType
        index []int
}

// FieldByNameFunc returns the struct field with a name that satisfies the
// match function and a boolean to indicate if the field was found.
func (t *structType) FieldByNameFunc(match func(string) bool) (result StructField, ok bool) <span class="cov0" title="0">{
        // This uses the same condition that the Go language does: there must be a unique instance
        // of the match at a given depth level. If there are multiple instances of a match at the
        // same depth, they annihilate each other and inhibit any possible match at a lower level.
        // The algorithm is breadth first search, one depth level at a time.

        // The current and next slices are work queues:
        // current lists the fields to visit on this depth level,
        // and next lists the fields on the next lower level.
        current := []fieldScan{}
        next := []fieldScan{{typ: t}}

        // nextCount records the number of times an embedded type has been
        // encountered and considered for queueing in the 'next' slice.
        // We only queue the first one, but we increment the count on each.
        // If a struct type T can be reached more than once at a given depth level,
        // then it annihilates itself and need not be considered at all when we
        // process that next depth level.
        var nextCount map[*structType]int

        // visited records the structs that have been considered already.
        // Embedded pointer fields can create cycles in the graph of
        // reachable embedded types; visited avoids following those cycles.
        // It also avoids duplicated effort: if we didn't find the field in an
        // embedded type T at level 2, we won't find it in one at level 4 either.
        visited := map[*structType]bool{}

        for len(next) &gt; 0 </span><span class="cov0" title="0">{
                current, next = next, current[:0]
                count := nextCount
                nextCount = nil

                // Process all the fields at this depth, now listed in 'current'.
                // The loop queues embedded fields found in 'next', for processing during the next
                // iteration. The multiplicity of the 'current' field counts is recorded
                // in 'count'; the multiplicity of the 'next' field counts is recorded in 'nextCount'.
                for _, scan := range current </span><span class="cov0" title="0">{
                        t := scan.typ
                        if visited[t] </span><span class="cov0" title="0">{
                                // We've looked through this type before, at a higher level.
                                // That higher level would shadow the lower level we're now at,
                                // so this one can't be useful to us. Ignore it.
                                continue</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">visited[t] = true
                        for i := range t.fields </span><span class="cov0" title="0">{
                                f := &amp;t.fields[i]
                                // Find name and (for embedded field) type for field f.
                                fname := f.name.name()
                                var ntyp *rtype
                                if f.embedded() </span><span class="cov0" title="0">{
                                        // Embedded field of type T or *T.
                                        ntyp = f.typ
                                        if ntyp.Kind() == Ptr </span><span class="cov0" title="0">{
                                                ntyp = ntyp.Elem().common()
                                        }</span><span class="cov0" title="0">
</span>                                }<span class="cov0" title="0">
</span>
                                // Does it match?
                                <span class="cov0" title="0">if match(fname) </span><span class="cov0" title="0">{
                                        // Potential match
                                        if count[t] &gt; 1 || ok </span><span class="cov0" title="0">{
                                                // Name appeared multiple times at this level: annihilate.
                                                return StructField{}, false
                                        }</span><span class="cov0" title="0">
</span>                                        <span class="cov0" title="0">result = t.Field(i)
                                        result.Index = nil
                                        result.Index = append(result.Index, scan.index...)
                                        result.Index = append(result.Index, i)
                                        ok = true
                                        continue</span>
                                }<span class="cov0" title="0">
</span>
                                // Queue embedded struct fields for processing with next level,
                                // but only if we haven't seen a match yet at this level and only
                                // if the embedded types haven't already been queued.
                                <span class="cov0" title="0">if ok || ntyp == nil || ntyp.Kind() != Struct </span><span class="cov0" title="0">{
                                        continue</span>
                                }<span class="cov0" title="0">
</span>                                <span class="cov0" title="0">styp := (*structType)(unsafe.Pointer(ntyp))
                                if nextCount[styp] &gt; 0 </span><span class="cov0" title="0">{
                                        nextCount[styp] = 2 // exact multiple doesn't matter
                                        continue</span>
                                }<span class="cov0" title="0">
</span>                                <span class="cov0" title="0">if nextCount == nil </span><span class="cov0" title="0">{
                                        nextCount = map[*structType]int{}
                                }</span><span class="cov0" title="0">
</span>                                <span class="cov0" title="0">nextCount[styp] = 1
                                if count[t] &gt; 1 </span><span class="cov0" title="0">{
                                        nextCount[styp] = 2 // exact multiple doesn't matter
                                }</span><span class="cov0" title="0">
</span>                                <span class="cov0" title="0">var index []int
                                index = append(index, scan.index...)
                                index = append(index, i)
                                next = append(next, fieldScan{styp, index})</span>
                        }
                }
                <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                        break</span>
                }<span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return</span>
}

// FieldByName returns the struct field with the given name
// and a boolean to indicate if the field was found.
func (t *structType) FieldByName(name string) (f StructField, present bool) <span class="cov0" title="0">{
        // Quick check for top-level name, or struct without embedded fields.
        hasEmbeds := false
        if name != "" </span><span class="cov0" title="0">{
                for i := range t.fields </span><span class="cov0" title="0">{
                        tf := &amp;t.fields[i]
                        if tf.name.name() == name </span><span class="cov0" title="0">{
                                return t.Field(i), true
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">if tf.embedded() </span><span class="cov0" title="0">{
                                hasEmbeds = true
                        }</span><span class="cov0" title="0">
</span>                }
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if !hasEmbeds </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return t.FieldByNameFunc(func(s string) bool </span><span class="cov0" title="0">{ return s == name }</span>)
}

// TypeOf returns the reflection Type that represents the dynamic type of i.
// If i is a nil interface value, TypeOf returns nil.
func TypeOf(i interface{}) Type <span class="cov0" title="0">{
        eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))
        return toType(eface.typ)
}</span>

// ptrMap is the cache for PtrTo.
var ptrMap sync.Map // map[*rtype]*ptrType

// PtrTo returns the pointer type with element t.
// For example, if t represents type Foo, PtrTo(t) represents *Foo.
func PtrTo(t Type) Type <span class="cov0" title="0">{
        return t.(*rtype).ptrTo()
}</span>

func (t *rtype) ptrTo() *rtype <span class="cov0" title="0">{
        if t.ptrToThis != 0 </span><span class="cov0" title="0">{
                return t.typeOff(t.ptrToThis)
        }</span><span class="cov0" title="0">
</span>
        // Check the cache.
        <span class="cov0" title="0">if pi, ok := ptrMap.Load(t); ok </span><span class="cov0" title="0">{
                return &amp;pi.(*ptrType).rtype
        }</span><span class="cov0" title="0">
</span>
        // Look in known types.
        <span class="cov0" title="0">s := "*" + t.String()
        for _, tt := range typesByString(s) </span><span class="cov0" title="0">{
                p := (*ptrType)(unsafe.Pointer(tt))
                if p.elem != t </span><span class="cov0" title="0">{
                        continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">pi, _ := ptrMap.LoadOrStore(t, p)
                return &amp;pi.(*ptrType).rtype</span>
        }

        // Create a new ptrType starting with the description
        // of an *unsafe.Pointer.
        <span class="cov0" title="0">var iptr interface{} = (*unsafe.Pointer)(nil)
        prototype := *(**ptrType)(unsafe.Pointer(&amp;iptr))
        pp := *prototype

        pp.str = resolveReflectName(newName(s, "", false))
        pp.ptrToThis = 0

        // For the type structures linked into the binary, the
        // compiler provides a good hash of the string.
        // Create a good hash for the new string by using
        // the FNV-1 hash's mixing function to combine the
        // old hash and the new "*".
        pp.hash = fnv1(t.hash, '*')

        pp.elem = t

        pi, _ := ptrMap.LoadOrStore(t, &amp;pp)
        return &amp;pi.(*ptrType).rtype</span>
}

// fnv1 incorporates the list of bytes into the hash x using the FNV-1 hash function.
func fnv1(x uint32, list ...byte) uint32 <span class="cov0" title="0">{
        for _, b := range list </span><span class="cov0" title="0">{
                x = x*16777619 ^ uint32(b)
        }</span>
        <span class="cov0" title="0">return x</span>
}

func (t *rtype) Implements(u Type) bool <span class="cov0" title="0">{
        if u == nil </span><span class="cov0" title="0">{
                panic("reflect: nil type passed to Type.Implements")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if u.Kind() != Interface </span><span class="cov0" title="0">{
                panic("reflect: non-interface type passed to Type.Implements")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">return implements(u.(*rtype), t)</span>
}

func (t *rtype) AssignableTo(u Type) bool <span class="cov0" title="0">{
        if u == nil </span><span class="cov0" title="0">{
                panic("reflect: nil type passed to Type.AssignableTo")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">uu := u.(*rtype)
        return directlyAssignable(uu, t) || implements(uu, t)</span>
}

func (t *rtype) ConvertibleTo(u Type) bool <span class="cov0" title="0">{
        if u == nil </span><span class="cov0" title="0">{
                panic("reflect: nil type passed to Type.ConvertibleTo")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">uu := u.(*rtype)
        return convertOp(uu, t) != nil</span>
}

func (t *rtype) Comparable() bool <span class="cov0" title="0">{
        return t.equal != nil
}</span>

// implements reports whether the type V implements the interface type T.
func implements(T, V *rtype) bool <span class="cov0" title="0">{
        if T.Kind() != Interface </span><span class="cov0" title="0">{
                return false
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">t := (*interfaceType)(unsafe.Pointer(T))
        if len(t.methods) == 0 </span><span class="cov0" title="0">{
                return true
        }</span><span class="cov0" title="0">
</span>
        // The same algorithm applies in both cases, but the
        // method tables for an interface type and a concrete type
        // are different, so the code is duplicated.
        // In both cases the algorithm is a linear scan over the two
        // lists - T's methods and V's methods - simultaneously.
        // Since method tables are stored in a unique sorted order
        // (alphabetical, with no duplicate method names), the scan
        // through V's methods must hit a match for each of T's
        // methods along the way, or else V does not implement T.
        // This lets us run the scan in overall linear time instead of
        // the quadratic time  a naive search would require.
        // See also ../runtime/iface.go.
        <span class="cov0" title="0">if V.Kind() == Interface </span><span class="cov0" title="0">{
                v := (*interfaceType)(unsafe.Pointer(V))
                i := 0
                for j := 0; j &lt; len(v.methods); j++ </span><span class="cov0" title="0">{
                        tm := &amp;t.methods[i]
                        tmName := t.nameOff(tm.name)
                        vm := &amp;v.methods[j]
                        vmName := V.nameOff(vm.name)
                        if vmName.name() == tmName.name() &amp;&amp; V.typeOff(vm.typ) == t.typeOff(tm.typ) </span><span class="cov0" title="0">{
                                if !tmName.isExported() </span><span class="cov0" title="0">{
                                        tmPkgPath := tmName.pkgPath()
                                        if tmPkgPath == "" </span><span class="cov0" title="0">{
                                                tmPkgPath = t.pkgPath.name()
                                        }</span><span class="cov0" title="0">
</span>                                        <span class="cov0" title="0">vmPkgPath := vmName.pkgPath()
                                        if vmPkgPath == "" </span><span class="cov0" title="0">{
                                                vmPkgPath = v.pkgPath.name()
                                        }</span><span class="cov0" title="0">
</span>                                        <span class="cov0" title="0">if tmPkgPath != vmPkgPath </span><span class="cov0" title="0">{
                                                continue</span>
                                        }<span class="cov0" title="0">
</span>                                }<span class="cov0" title="0">
</span>                                <span class="cov0" title="0">if i++; i &gt;= len(t.methods) </span><span class="cov0" title="0">{
                                        return true
                                }</span><span class="cov0" title="0">
</span>                        }<span class="cov0" title="0">
</span>                }
                <span class="cov0" title="0">return false</span>
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">v := V.uncommon()
        if v == nil </span><span class="cov0" title="0">{
                return false
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">i := 0
        vmethods := v.methods()
        for j := 0; j &lt; int(v.mcount); j++ </span><span class="cov0" title="0">{
                tm := &amp;t.methods[i]
                tmName := t.nameOff(tm.name)
                vm := vmethods[j]
                vmName := V.nameOff(vm.name)
                if vmName.name() == tmName.name() &amp;&amp; V.typeOff(vm.mtyp) == t.typeOff(tm.typ) </span><span class="cov0" title="0">{
                        if !tmName.isExported() </span><span class="cov0" title="0">{
                                tmPkgPath := tmName.pkgPath()
                                if tmPkgPath == "" </span><span class="cov0" title="0">{
                                        tmPkgPath = t.pkgPath.name()
                                }</span><span class="cov0" title="0">
</span>                                <span class="cov0" title="0">vmPkgPath := vmName.pkgPath()
                                if vmPkgPath == "" </span><span class="cov0" title="0">{
                                        vmPkgPath = V.nameOff(v.pkgPath).name()
                                }</span><span class="cov0" title="0">
</span>                                <span class="cov0" title="0">if tmPkgPath != vmPkgPath </span><span class="cov0" title="0">{
                                        continue</span>
                                }<span class="cov0" title="0">
</span>                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">if i++; i &gt;= len(t.methods) </span><span class="cov0" title="0">{
                                return true
                        }</span><span class="cov0" title="0">
</span>                }<span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return false</span>
}

// specialChannelAssignability reports whether a value x of channel type V
// can be directly assigned (using memmove) to another channel type T.
// https://golang.org/doc/go_spec.html#Assignability
// T and V must be both of Chan kind.
func specialChannelAssignability(T, V *rtype) bool <span class="cov0" title="0">{
        // Special case:
        // x is a bidirectional channel value, T is a channel type,
        // x's type V and T have identical element types,
        // and at least one of V or T is not a defined type.
        return V.ChanDir() == BothDir &amp;&amp; (T.Name() == "" || V.Name() == "") &amp;&amp; haveIdenticalType(T.Elem(), V.Elem(), true)
}</span>

// directlyAssignable reports whether a value x of type V can be directly
// assigned (using memmove) to a value of type T.
// https://golang.org/doc/go_spec.html#Assignability
// Ignoring the interface rules (implemented elsewhere)
// and the ideal constant rules (no ideal constants at run time).
func directlyAssignable(T, V *rtype) bool <span class="cov0" title="0">{
        // x's type V is identical to T?
        if T == V </span><span class="cov0" title="0">{
                return true
        }</span><span class="cov0" title="0">
</span>
        // Otherwise at least one of T and V must not be defined
        // and they must have the same kind.
        <span class="cov0" title="0">if T.hasName() &amp;&amp; V.hasName() || T.Kind() != V.Kind() </span><span class="cov0" title="0">{
                return false
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if T.Kind() == Chan &amp;&amp; specialChannelAssignability(T, V) </span><span class="cov0" title="0">{
                return true
        }</span><span class="cov0" title="0">
</span>
        // x's type T and V must have identical underlying types.
        <span class="cov0" title="0">return haveIdenticalUnderlyingType(T, V, true)</span>
}

func haveIdenticalType(T, V Type, cmpTags bool) bool <span class="cov0" title="0">{
        if cmpTags </span><span class="cov0" title="0">{
                return T == V
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if T.Name() != V.Name() || T.Kind() != V.Kind() </span><span class="cov0" title="0">{
                return false
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">return haveIdenticalUnderlyingType(T.common(), V.common(), false)</span>
}

func haveIdenticalUnderlyingType(T, V *rtype, cmpTags bool) bool <span class="cov0" title="0">{
        if T == V </span><span class="cov0" title="0">{
                return true
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">kind := T.Kind()
        if kind != V.Kind() </span><span class="cov0" title="0">{
                return false
        }</span><span class="cov0" title="0">
</span>
        // Non-composite types of equal kind have same underlying type
        // (the predefined instance of the type).
        <span class="cov0" title="0">if Bool &lt;= kind &amp;&amp; kind &lt;= Complex128 || kind == String || kind == UnsafePointer </span><span class="cov0" title="0">{
                return true
        }</span><span class="cov0" title="0">
</span>
        // Composite types.
        <span class="cov0" title="0">switch kind </span>{
        <span class="cov0" title="0">case Array:
                return T.Len() == V.Len() &amp;&amp; haveIdenticalType(T.Elem(), V.Elem(), cmpTags)</span>

        <span class="cov0" title="0">case Chan:
                return V.ChanDir() == T.ChanDir() &amp;&amp; haveIdenticalType(T.Elem(), V.Elem(), cmpTags)</span>

        <span class="cov0" title="0">case Func:
                t := (*funcType)(unsafe.Pointer(T))
                v := (*funcType)(unsafe.Pointer(V))
                if t.outCount != v.outCount || t.inCount != v.inCount </span><span class="cov0" title="0">{
                        return false
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">for i := 0; i &lt; t.NumIn(); i++ </span><span class="cov0" title="0">{
                        if !haveIdenticalType(t.In(i), v.In(i), cmpTags) </span><span class="cov0" title="0">{
                                return false
                        }</span><span class="cov0" title="0">
</span>                }
                <span class="cov0" title="0">for i := 0; i &lt; t.NumOut(); i++ </span><span class="cov0" title="0">{
                        if !haveIdenticalType(t.Out(i), v.Out(i), cmpTags) </span><span class="cov0" title="0">{
                                return false
                        }</span><span class="cov0" title="0">
</span>                }
                <span class="cov0" title="0">return true</span>

        <span class="cov0" title="0">case Interface:
                t := (*interfaceType)(unsafe.Pointer(T))
                v := (*interfaceType)(unsafe.Pointer(V))
                if len(t.methods) == 0 &amp;&amp; len(v.methods) == 0 </span><span class="cov0" title="0">{
                        return true
                }</span><span class="cov0" title="0">
</span>                // Might have the same methods but still
                // need a run time conversion.
                <span class="cov0" title="0">return false</span>

        <span class="cov0" title="0">case Map:
                return haveIdenticalType(T.Key(), V.Key(), cmpTags) &amp;&amp; haveIdenticalType(T.Elem(), V.Elem(), cmpTags)</span>

        <span class="cov0" title="0">case Ptr, Slice:
                return haveIdenticalType(T.Elem(), V.Elem(), cmpTags)</span>

        <span class="cov0" title="0">case Struct:
                t := (*structType)(unsafe.Pointer(T))
                v := (*structType)(unsafe.Pointer(V))
                if len(t.fields) != len(v.fields) </span><span class="cov0" title="0">{
                        return false
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if t.pkgPath.name() != v.pkgPath.name() </span><span class="cov0" title="0">{
                        return false
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">for i := range t.fields </span><span class="cov0" title="0">{
                        tf := &amp;t.fields[i]
                        vf := &amp;v.fields[i]
                        if tf.name.name() != vf.name.name() </span><span class="cov0" title="0">{
                                return false
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">if !haveIdenticalType(tf.typ, vf.typ, cmpTags) </span><span class="cov0" title="0">{
                                return false
                        }</span><span class="cov8" title="1">
</span>                        <span class="cov0" title="0">if cmpTags &amp;&amp; tf.name.tag() != vf.name.tag() </span><span class="cov0" title="0">{
                                return false
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">if tf.offsetEmbed != vf.offsetEmbed </span><span class="cov0" title="0">{
                                return false
                        }</span><span class="cov0" title="0">
</span>                }
                <span class="cov0" title="0">return true</span>
        }

        <span class="cov0" title="0">return false</span>
}

// typelinks is implemented in package runtime.
// It returns a slice of the sections in each module,
// and a slice of *rtype offsets in each module.
//
// The types in each module are sorted by string. That is, the first
// two linked types of the first module are:
//
//        d0 := sections[0]
//        t1 := (*rtype)(add(d0, offset[0][0]))
//        t2 := (*rtype)(add(d0, offset[0][1]))
//
// and
//
//        t1.String() &lt; t2.String()
//
// Note that strings are not unique identifiers for types:
// there can be more than one with a given string.
// Only types we might want to look up are included:
// pointers, channels, maps, slices, and arrays.
func typelinks() (sections []unsafe.Pointer, offset [][]int32)

func rtypeOff(section unsafe.Pointer, off int32) *rtype <span class="cov0" title="0">{
        return (*rtype)(add(section, uintptr(off), "sizeof(rtype) &gt; 0"))
}</span>

// typesByString returns the subslice of typelinks() whose elements have
// the given string representation.
// It may be empty (no known types with that string) or may have
// multiple elements (multiple types with that string).
func typesByString(s string) []*rtype <span class="cov0" title="0">{
        sections, offset := typelinks()
        var ret []*rtype

        for offsI, offs := range offset </span><span class="cov0" title="0">{
                section := sections[offsI]

                // We are looking for the first index i where the string becomes &gt;= s.
                // This is a copy of sort.Search, with f(h) replaced by (*typ[h].String() &gt;= s).
                i, j := 0, len(offs)
                for i &lt; j </span><span class="cov0" title="0">{
                        h := i + (j-i)/2 // avoid overflow when computing h
                        // i ≤ h &lt; j
                        if !(rtypeOff(section, offs[h]).String() &gt;= s) </span><span class="cov0" title="0">{
                                i = h + 1 // preserves f(i-1) == false
                        }</span><span class="cov0" title="0"> else {
                                j = h // preserves f(j) == true
                        }</span>
                }
                // i == j, f(i-1) == false, and f(j) (= f(i)) == true  =&gt;  answer is i.

                // Having found the first, linear scan forward to find the last.
                // We could do a second binary search, but the caller is going
                // to do a linear scan anyway.
                <span class="cov0" title="0">for j := i; j &lt; len(offs); j++ </span><span class="cov0" title="0">{
                        typ := rtypeOff(section, offs[j])
                        if typ.String() != s </span><span class="cov0" title="0">{
                                break</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov8" title="1">ret = append(ret, typ)</span>
                }
        }
        <span class="cov0" title="0">return ret</span>
}

// The lookupCache caches ArrayOf, ChanOf, MapOf and SliceOf lookups.
var lookupCache sync.Map // map[cacheKey]*rtype

// A cacheKey is the key for use in the lookupCache.
// Four values describe any of the types we are looking for:
// type kind, one or two subtypes, and an extra integer.
type cacheKey struct {
        kind  Kind
        t1    *rtype
        t2    *rtype
        extra uintptr
}

// The funcLookupCache caches FuncOf lookups.
// FuncOf does not share the common lookupCache since cacheKey is not
// sufficient to represent functions unambiguously.
var funcLookupCache struct {
        sync.Mutex // Guards stores (but not loads) on m.

        // m is a map[uint32][]*rtype keyed by the hash calculated in FuncOf.
        // Elements of m are append-only and thus safe for concurrent reading.
        m sync.Map
}

// ChanOf returns the channel type with the given direction and element type.
// For example, if t represents int, ChanOf(RecvDir, t) represents &lt;-chan int.
//
// The gc runtime imposes a limit of 64 kB on channel element types.
// If t's size is equal to or exceeds this limit, ChanOf panics.
func ChanOf(dir ChanDir, t Type) Type <span class="cov0" title="0">{
        typ := t.(*rtype)

        // Look in cache.
        ckey := cacheKey{Chan, typ, nil, uintptr(dir)}
        if ch, ok := lookupCache.Load(ckey); ok </span><span class="cov0" title="0">{
                return ch.(*rtype)
        }</span><span class="cov0" title="0">
</span>
        // This restriction is imposed by the gc compiler and the runtime.
        <span class="cov0" title="0">if typ.size &gt;= 1&lt;&lt;16 </span><span class="cov0" title="0">{
                panic("reflect.ChanOf: element size too large")</span>
        }<span class="cov0" title="0">
</span>
        // Look in known types.
        // TODO: Precedence when constructing string.
        <span class="cov0" title="0">var s string
        switch dir </span>{
        <span class="cov0" title="0">default:
                panic("reflect.ChanOf: invalid dir")</span>
        <span class="cov0" title="0">case SendDir:
                s = "chan&lt;- " + typ.String()</span>
        <span class="cov0" title="0">case RecvDir:
                s = "&lt;-chan " + typ.String()</span>
        <span class="cov0" title="0">case BothDir:
                s = "chan " + typ.String()</span>
        }
        <span class="cov0" title="0">for _, tt := range typesByString(s) </span><span class="cov0" title="0">{
                ch := (*chanType)(unsafe.Pointer(tt))
                if ch.elem == typ &amp;&amp; ch.dir == uintptr(dir) </span><span class="cov0" title="0">{
                        ti, _ := lookupCache.LoadOrStore(ckey, tt)
                        return ti.(Type)
                }</span><span class="cov0" title="0">
</span>        }

        // Make a channel type.
        <span class="cov0" title="0">var ichan interface{} = (chan unsafe.Pointer)(nil)
        prototype := *(**chanType)(unsafe.Pointer(&amp;ichan))
        ch := *prototype
        ch.tflag = tflagRegularMemory
        ch.dir = uintptr(dir)
        ch.str = resolveReflectName(newName(s, "", false))
        ch.hash = fnv1(typ.hash, 'c', byte(dir))
        ch.elem = typ

        ti, _ := lookupCache.LoadOrStore(ckey, &amp;ch.rtype)
        return ti.(Type)</span>
}

// MapOf returns the map type with the given key and element types.
// For example, if k represents int and e represents string,
// MapOf(k, e) represents map[int]string.
//
// If the key type is not a valid map key type (that is, if it does
// not implement Go's == operator), MapOf panics.
func MapOf(key, elem Type) Type <span class="cov0" title="0">{
        ktyp := key.(*rtype)
        etyp := elem.(*rtype)

        if ktyp.equal == nil </span><span class="cov0" title="0">{
                panic("reflect.MapOf: invalid key type " + ktyp.String())</span>
        }<span class="cov0" title="0">
</span>
        // Look in cache.
        <span class="cov0" title="0">ckey := cacheKey{Map, ktyp, etyp, 0}
        if mt, ok := lookupCache.Load(ckey); ok </span><span class="cov0" title="0">{
                return mt.(Type)
        }</span><span class="cov0" title="0">
</span>
        // Look in known types.
        <span class="cov0" title="0">s := "map[" + ktyp.String() + "]" + etyp.String()
        for _, tt := range typesByString(s) </span><span class="cov0" title="0">{
                mt := (*mapType)(unsafe.Pointer(tt))
                if mt.key == ktyp &amp;&amp; mt.elem == etyp </span><span class="cov0" title="0">{
                        ti, _ := lookupCache.LoadOrStore(ckey, tt)
                        return ti.(Type)
                }</span><span class="cov0" title="0">
</span>        }

        // Make a map type.
        // Note: flag values must match those used in the TMAP case
        // in ../cmd/compile/internal/gc/reflect.go:dtypesym.
        <span class="cov0" title="0">var imap interface{} = (map[unsafe.Pointer]unsafe.Pointer)(nil)
        mt := **(**mapType)(unsafe.Pointer(&amp;imap))
        mt.str = resolveReflectName(newName(s, "", false))
        mt.tflag = 0
        mt.hash = fnv1(etyp.hash, 'm', byte(ktyp.hash&gt;&gt;24), byte(ktyp.hash&gt;&gt;16), byte(ktyp.hash&gt;&gt;8), byte(ktyp.hash))
        mt.key = ktyp
        mt.elem = etyp
        mt.bucket = bucketOf(ktyp, etyp)
        mt.hasher = func(p unsafe.Pointer, seed uintptr) uintptr </span><span class="cov0" title="0">{
                return typehash(ktyp, p, seed)
        }</span>
        <span class="cov0" title="0">mt.flags = 0
        if ktyp.size &gt; maxKeySize </span><span class="cov0" title="0">{
                mt.keysize = uint8(ptrSize)
                mt.flags |= 1 // indirect key
        }</span><span class="cov0" title="0"> else {
                mt.keysize = uint8(ktyp.size)
        }</span>
        <span class="cov0" title="0">if etyp.size &gt; maxValSize </span><span class="cov0" title="0">{
                mt.valuesize = uint8(ptrSize)
                mt.flags |= 2 // indirect value
        }</span><span class="cov0" title="0"> else {
                mt.valuesize = uint8(etyp.size)
        }</span>
        <span class="cov0" title="0">mt.bucketsize = uint16(mt.bucket.size)
        if isReflexive(ktyp) </span><span class="cov0" title="0">{
                mt.flags |= 4
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if needKeyUpdate(ktyp) </span><span class="cov0" title="0">{
                mt.flags |= 8
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if hashMightPanic(ktyp) </span><span class="cov0" title="0">{
                mt.flags |= 16
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">mt.ptrToThis = 0

        ti, _ := lookupCache.LoadOrStore(ckey, &amp;mt.rtype)
        return ti.(Type)</span>
}

// TODO(crawshaw): as these funcTypeFixedN structs have no methods,
// they could be defined at runtime using the StructOf function.
type funcTypeFixed4 struct {
        funcType
        args [4]*rtype
}
type funcTypeFixed8 struct {
        funcType
        args [8]*rtype
}
type funcTypeFixed16 struct {
        funcType
        args [16]*rtype
}
type funcTypeFixed32 struct {
        funcType
        args [32]*rtype
}
type funcTypeFixed64 struct {
        funcType
        args [64]*rtype
}
type funcTypeFixed128 struct {
        funcType
        args [128]*rtype
}

// FuncOf returns the function type with the given argument and result types.
// For example if k represents int and e represents string,
// FuncOf([]Type{k}, []Type{e}, false) represents func(int) string.
//
// The variadic argument controls whether the function is variadic. FuncOf
// panics if the in[len(in)-1] does not represent a slice and variadic is
// true.
func FuncOf(in, out []Type, variadic bool) Type <span class="cov0" title="0">{
        if variadic &amp;&amp; (len(in) == 0 || in[len(in)-1].Kind() != Slice) </span><span class="cov0" title="0">{
                panic("reflect.FuncOf: last arg of variadic func must be slice")</span>
        }<span class="cov0" title="0">
</span>
        // Make a func type.
        <span class="cov0" title="0">var ifunc interface{} = (func())(nil)
        prototype := *(**funcType)(unsafe.Pointer(&amp;ifunc))
        n := len(in) + len(out)

        var ft *funcType
        var args []*rtype
        switch </span>{
        <span class="cov0" title="0">case n &lt;= 4:
                fixed := new(funcTypeFixed4)
                args = fixed.args[:0:len(fixed.args)]
                ft = &amp;fixed.funcType</span>
        <span class="cov0" title="0">case n &lt;= 8:
                fixed := new(funcTypeFixed8)
                args = fixed.args[:0:len(fixed.args)]
                ft = &amp;fixed.funcType</span>
        <span class="cov0" title="0">case n &lt;= 16:
                fixed := new(funcTypeFixed16)
                args = fixed.args[:0:len(fixed.args)]
                ft = &amp;fixed.funcType</span>
        <span class="cov0" title="0">case n &lt;= 32:
                fixed := new(funcTypeFixed32)
                args = fixed.args[:0:len(fixed.args)]
                ft = &amp;fixed.funcType</span>
        <span class="cov0" title="0">case n &lt;= 64:
                fixed := new(funcTypeFixed64)
                args = fixed.args[:0:len(fixed.args)]
                ft = &amp;fixed.funcType</span>
        <span class="cov0" title="0">case n &lt;= 128:
                fixed := new(funcTypeFixed128)
                args = fixed.args[:0:len(fixed.args)]
                ft = &amp;fixed.funcType</span>
        <span class="cov0" title="0">default:
                panic("reflect.FuncOf: too many arguments")</span>
        }
        <span class="cov0" title="0">*ft = *prototype

        // Build a hash and minimally populate ft.
        var hash uint32
        for _, in := range in </span><span class="cov0" title="0">{
                t := in.(*rtype)
                args = append(args, t)
                hash = fnv1(hash, byte(t.hash&gt;&gt;24), byte(t.hash&gt;&gt;16), byte(t.hash&gt;&gt;8), byte(t.hash))
        }</span>
        <span class="cov0" title="0">if variadic </span><span class="cov0" title="0">{
                hash = fnv1(hash, 'v')
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">hash = fnv1(hash, '.')
        for _, out := range out </span><span class="cov0" title="0">{
                t := out.(*rtype)
                args = append(args, t)
                hash = fnv1(hash, byte(t.hash&gt;&gt;24), byte(t.hash&gt;&gt;16), byte(t.hash&gt;&gt;8), byte(t.hash))
        }</span>
        <span class="cov0" title="0">if len(args) &gt; 50 </span><span class="cov0" title="0">{
                panic("reflect.FuncOf does not support more than 50 arguments")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">ft.tflag = 0
        ft.hash = hash
        ft.inCount = uint16(len(in))
        ft.outCount = uint16(len(out))
        if variadic </span><span class="cov0" title="0">{
                ft.outCount |= 1 &lt;&lt; 15
        }</span><span class="cov0" title="0">
</span>
        // Look in cache.
        <span class="cov0" title="0">if ts, ok := funcLookupCache.m.Load(hash); ok </span><span class="cov0" title="0">{
                for _, t := range ts.([]*rtype) </span><span class="cov0" title="0">{
                        if haveIdenticalUnderlyingType(&amp;ft.rtype, t, true) </span><span class="cov0" title="0">{
                                return t
                        }</span><span class="cov0" title="0">
</span>                }
        }<span class="cov8" title="1">
</span>
        // Not in cache, lock and retry.
        <span class="cov0" title="0">funcLookupCache.Lock()
        defer funcLookupCache.Unlock()
        if ts, ok := funcLookupCache.m.Load(hash); ok </span><span class="cov0" title="0">{
                for _, t := range ts.([]*rtype) </span><span class="cov0" title="0">{
                        if haveIdenticalUnderlyingType(&amp;ft.rtype, t, true) </span><span class="cov0" title="0">{
                                return t
                        }</span><span class="cov0" title="0">
</span>                }
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">addToCache := func(tt *rtype) Type </span><span class="cov0" title="0">{
                var rts []*rtype
                if rti, ok := funcLookupCache.m.Load(hash); ok </span><span class="cov0" title="0">{
                        rts = rti.([]*rtype)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">funcLookupCache.m.Store(hash, append(rts, tt))
                return tt</span>
        }

        // Look in known types for the same string representation.
        <span class="cov0" title="0">str := funcStr(ft)
        for _, tt := range typesByString(str) </span><span class="cov0" title="0">{
                if haveIdenticalUnderlyingType(&amp;ft.rtype, tt, true) </span><span class="cov0" title="0">{
                        return addToCache(tt)
                }</span><span class="cov0" title="0">
</span>        }

        // Populate the remaining fields of ft and store in cache.
        <span class="cov0" title="0">ft.str = resolveReflectName(newName(str, "", false))
        ft.ptrToThis = 0
        return addToCache(&amp;ft.rtype)</span>
}

// funcStr builds a string representation of a funcType.
func funcStr(ft *funcType) string <span class="cov0" title="0">{
        repr := make([]byte, 0, 64)
        repr = append(repr, "func("...)
        for i, t := range ft.in() </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        repr = append(repr, ", "...)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if ft.IsVariadic() &amp;&amp; i == int(ft.inCount)-1 </span><span class="cov0" title="0">{
                        repr = append(repr, "..."...)
                        repr = append(repr, (*sliceType)(unsafe.Pointer(t)).elem.String()...)
                }</span><span class="cov0" title="0"> else {
                        repr = append(repr, t.String()...)
                }</span>
        }
        <span class="cov0" title="0">repr = append(repr, ')')
        out := ft.out()
        if len(out) == 1 </span><span class="cov8" title="1">{
                repr = append(repr, ' ')
        }</span><span class="cov0" title="0"> else if len(out) &gt; 1 </span><span class="cov0" title="0">{
                repr = append(repr, " ("...)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">for i, t := range out </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        repr = append(repr, ", "...)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">repr = append(repr, t.String()...)</span>
        }
        <span class="cov0" title="0">if len(out) &gt; 1 </span><span class="cov0" title="0">{
                repr = append(repr, ')')
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return string(repr)</span>
}

// isReflexive reports whether the == operation on the type is reflexive.
// That is, x == x for all values x of type t.
func isReflexive(t *rtype) bool <span class="cov0" title="0">{
        switch t.Kind() </span>{
        <span class="cov0" title="0">case Bool, Int, Int8, Int16, Int32, Int64, Uint, Uint8, Uint16, Uint32, Uint64, Uintptr, Chan, Ptr, String, UnsafePointer:
                return true</span>
        <span class="cov0" title="0">case Float32, Float64, Complex64, Complex128, Interface:
                return false</span>
        <span class="cov0" title="0">case Array:
                tt := (*arrayType)(unsafe.Pointer(t))
                return isReflexive(tt.elem)</span>
        <span class="cov0" title="0">case Struct:
                tt := (*structType)(unsafe.Pointer(t))
                for _, f := range tt.fields </span><span class="cov0" title="0">{
                        if !isReflexive(f.typ) </span><span class="cov0" title="0">{
                                return false
                        }</span><span class="cov0" title="0">
</span>                }
                <span class="cov0" title="0">return true</span>
        <span class="cov0" title="0">default:
                // Func, Map, Slice, Invalid
                panic("isReflexive called on non-key type " + t.String())</span>
        }
}

// needKeyUpdate reports whether map overwrites require the key to be copied.
func needKeyUpdate(t *rtype) bool <span class="cov0" title="0">{
        switch t.Kind() </span>{
        <span class="cov0" title="0">case Bool, Int, Int8, Int16, Int32, Int64, Uint, Uint8, Uint16, Uint32, Uint64, Uintptr, Chan, Ptr, UnsafePointer:
                return false</span>
        <span class="cov0" title="0">case Float32, Float64, Complex64, Complex128, Interface, String:
                // Float keys can be updated from +0 to -0.
                // String keys can be updated to use a smaller backing store.
                // Interfaces might have floats of strings in them.
                return true</span>
        <span class="cov0" title="0">case Array:
                tt := (*arrayType)(unsafe.Pointer(t))
                return needKeyUpdate(tt.elem)</span>
        <span class="cov0" title="0">case Struct:
                tt := (*structType)(unsafe.Pointer(t))
                for _, f := range tt.fields </span><span class="cov0" title="0">{
                        if needKeyUpdate(f.typ) </span><span class="cov0" title="0">{
                                return true
                        }</span><span class="cov0" title="0">
</span>                }
                <span class="cov0" title="0">return false</span>
        <span class="cov0" title="0">default:
                // Func, Map, Slice, Invalid
                panic("needKeyUpdate called on non-key type " + t.String())</span>
        }
}

// hashMightPanic reports whether the hash of a map key of type t might panic.
func hashMightPanic(t *rtype) bool <span class="cov0" title="0">{
        switch t.Kind() </span>{
        <span class="cov0" title="0">case Interface:
                return true</span>
        <span class="cov0" title="0">case Array:
                tt := (*arrayType)(unsafe.Pointer(t))
                return hashMightPanic(tt.elem)</span>
        <span class="cov0" title="0">case Struct:
                tt := (*structType)(unsafe.Pointer(t))
                for _, f := range tt.fields </span><span class="cov0" title="0">{
                        if hashMightPanic(f.typ) </span><span class="cov0" title="0">{
                                return true
                        }</span><span class="cov0" title="0">
</span>                }
                <span class="cov0" title="0">return false</span>
        <span class="cov0" title="0">default:
                return false</span>
        }
}

// Make sure these routines stay in sync with ../../runtime/map.go!
// These types exist only for GC, so we only fill out GC relevant info.
// Currently, that's just size and the GC program. We also fill in string
// for possible debugging use.
const (
        bucketSize uintptr = 8
        maxKeySize uintptr = 128
        maxValSize uintptr = 128
)

func bucketOf(ktyp, etyp *rtype) *rtype <span class="cov0" title="0">{
        if ktyp.size &gt; maxKeySize </span><span class="cov0" title="0">{
                ktyp = PtrTo(ktyp).(*rtype)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if etyp.size &gt; maxValSize </span><span class="cov0" title="0">{
                etyp = PtrTo(etyp).(*rtype)
        }</span><span class="cov0" title="0">
</span>
        // Prepare GC data if any.
        // A bucket is at most bucketSize*(1+maxKeySize+maxValSize)+2*ptrSize bytes,
        // or 2072 bytes, or 259 pointer-size words, or 33 bytes of pointer bitmap.
        // Note that since the key and value are known to be &lt;= 128 bytes,
        // they're guaranteed to have bitmaps instead of GC programs.
        <span class="cov0" title="0">var gcdata *byte
        var ptrdata uintptr
        var overflowPad uintptr

        size := bucketSize*(1+ktyp.size+etyp.size) + overflowPad + ptrSize
        if size&amp;uintptr(ktyp.align-1) != 0 || size&amp;uintptr(etyp.align-1) != 0 </span><span class="cov0" title="0">{
                panic("reflect: bad size computation in MapOf")</span>
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if ktyp.ptrdata != 0 || etyp.ptrdata != 0 </span><span class="cov0" title="0">{
                nptr := (bucketSize*(1+ktyp.size+etyp.size) + ptrSize) / ptrSize
                mask := make([]byte, (nptr+7)/8)
                base := bucketSize / ptrSize

                if ktyp.ptrdata != 0 </span><span class="cov0" title="0">{
                        emitGCMask(mask, base, ktyp, bucketSize)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">base += bucketSize * ktyp.size / ptrSize

                if etyp.ptrdata != 0 </span><span class="cov0" title="0">{
                        emitGCMask(mask, base, etyp, bucketSize)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">base += bucketSize * etyp.size / ptrSize
                base += overflowPad / ptrSize

                word := base
                mask[word/8] |= 1 &lt;&lt; (word % 8)
                gcdata = &amp;mask[0]
                ptrdata = (word + 1) * ptrSize

                // overflow word must be last
                if ptrdata != size </span><span class="cov0" title="0">{
                        panic("reflect: bad layout computation in MapOf")</span>
                }<span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">b := &amp;rtype{
                align:   ptrSize,
                size:    size,
                kind:    uint8(Struct),
                ptrdata: ptrdata,
                gcdata:  gcdata,
        }
        if overflowPad &gt; 0 </span><span class="cov0" title="0">{
                b.align = 8
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">s := "bucket(" + ktyp.String() + "," + etyp.String() + ")"
        b.str = resolveReflectName(newName(s, "", false))
        return b</span>
}

func (t *rtype) gcSlice(begin, end uintptr) []byte <span class="cov0" title="0">{
        return (*[1 &lt;&lt; 30]byte)(unsafe.Pointer(t.gcdata))[begin:end:end]
}</span>

// emitGCMask writes the GC mask for [n]typ into out, starting at bit
// offset base.
func emitGCMask(out []byte, base uintptr, typ *rtype, n uintptr) <span class="cov0" title="0">{
        if typ.kind&amp;kindGCProg != 0 </span><span class="cov0" title="0">{
                panic("reflect: unexpected GC program")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">ptrs := typ.ptrdata / ptrSize
        words := typ.size / ptrSize
        mask := typ.gcSlice(0, (ptrs+7)/8)
        for j := uintptr(0); j &lt; ptrs; j++ </span><span class="cov0" title="0">{
                if (mask[j/8]&gt;&gt;(j%8))&amp;1 != 0 </span><span class="cov0" title="0">{
                        for i := uintptr(0); i &lt; n; i++ </span><span class="cov0" title="0">{
                                k := base + i*words + j
                                out[k/8] |= 1 &lt;&lt; (k % 8)
                        }</span>
                }<span class="cov0" title="0">
</span>        }
}

// appendGCProg appends the GC program for the first ptrdata bytes of
// typ to dst and returns the extended slice.
func appendGCProg(dst []byte, typ *rtype) []byte <span class="cov0" title="0">{
        if typ.kind&amp;kindGCProg != 0 </span><span class="cov0" title="0">{
                // Element has GC program; emit one element.
                n := uintptr(*(*uint32)(unsafe.Pointer(typ.gcdata)))
                prog := typ.gcSlice(4, 4+n-1)
                return append(dst, prog...)
        }</span><span class="cov0" title="0">
</span>
        // Element is small with pointer mask; use as literal bits.
        <span class="cov0" title="0">ptrs := typ.ptrdata / ptrSize
        mask := typ.gcSlice(0, (ptrs+7)/8)

        // Emit 120-bit chunks of full bytes (max is 127 but we avoid using partial bytes).
        for ; ptrs &gt; 120; ptrs -= 120 </span><span class="cov0" title="0">{
                dst = append(dst, 120)
                dst = append(dst, mask[:15]...)
                mask = mask[15:]
        }</span>

        <span class="cov0" title="0">dst = append(dst, byte(ptrs))
        dst = append(dst, mask...)
        return dst</span>
}

// SliceOf returns the slice type with element type t.
// For example, if t represents int, SliceOf(t) represents []int.
func SliceOf(t Type) Type <span class="cov0" title="0">{
        typ := t.(*rtype)

        // Look in cache.
        ckey := cacheKey{Slice, typ, nil, 0}
        if slice, ok := lookupCache.Load(ckey); ok </span><span class="cov0" title="0">{
                return slice.(Type)
        }</span><span class="cov0" title="0">
</span>
        // Look in known types.
        <span class="cov0" title="0">s := "[]" + typ.String()
        for _, tt := range typesByString(s) </span><span class="cov0" title="0">{
                slice := (*sliceType)(unsafe.Pointer(tt))
                if slice.elem == typ </span><span class="cov0" title="0">{
                        ti, _ := lookupCache.LoadOrStore(ckey, tt)
                        return ti.(Type)
                }</span><span class="cov8" title="1">
</span>        }

        // Make a slice type.
        <span class="cov0" title="0">var islice interface{} = ([]unsafe.Pointer)(nil)
        prototype := *(**sliceType)(unsafe.Pointer(&amp;islice))
        slice := *prototype
        slice.tflag = 0
        slice.str = resolveReflectName(newName(s, "", false))
        slice.hash = fnv1(typ.hash, '[')
        slice.elem = typ
        slice.ptrToThis = 0

        ti, _ := lookupCache.LoadOrStore(ckey, &amp;slice.rtype)
        return ti.(Type)</span>
}

// The structLookupCache caches StructOf lookups.
// StructOf does not share the common lookupCache since we need to pin
// the memory associated with *structTypeFixedN.
var structLookupCache struct {
        sync.Mutex // Guards stores (but not loads) on m.

        // m is a map[uint32][]Type keyed by the hash calculated in StructOf.
        // Elements in m are append-only and thus safe for concurrent reading.
        m sync.Map
}

type structTypeUncommon struct {
        structType
        u uncommonType
}

// isLetter reports whether a given 'rune' is classified as a Letter.
func isLetter(ch rune) bool <span class="cov0" title="0">{
        return 'a' &lt;= ch &amp;&amp; ch &lt;= 'z' || 'A' &lt;= ch &amp;&amp; ch &lt;= 'Z' || ch == '_' || ch &gt;= utf8.RuneSelf &amp;&amp; unicode.IsLetter(ch)
}</span>

// isValidFieldName checks if a string is a valid (struct) field name or not.
//
// According to the language spec, a field name should be an identifier.
//
// identifier = letter { letter | unicode_digit } .
// letter = unicode_letter | "_" .
func isValidFieldName(fieldName string) bool <span class="cov0" title="0">{
        for i, c := range fieldName </span><span class="cov0" title="0">{
                if i == 0 &amp;&amp; !isLetter(c) </span><span class="cov0" title="0">{
                        return false
                }</span><span class="cov0" title="0">
</span>
                <span class="cov0" title="0">if !(isLetter(c) || unicode.IsDigit(c)) </span><span class="cov0" title="0">{
                        return false
                }</span><span class="cov0" title="0">
</span>        }

        <span class="cov0" title="0">return len(fieldName) &gt; 0</span>
}

// StructOf returns the struct type containing fields.
// The Offset and Index fields are ignored and computed as they would be
// by the compiler.
//
// StructOf currently does not generate wrapper methods for embedded
// fields and panics if passed unexported StructFields.
// These limitations may be lifted in a future version.
func StructOf(fields []StructField) Type <span class="cov0" title="0">{
        var (
                hash       = fnv1(0, []byte("struct {")...)
                size       uintptr
                typalign   uint8
                comparable = true
                methods    []method

                fs   = make([]structField, len(fields))
                repr = make([]byte, 0, 64)
                fset = map[string]struct{}{} // fields' names

                hasGCProg = false // records whether a struct-field type has a GCProg
        )

        lastzero := uintptr(0)
        repr = append(repr, "struct {"...)
        pkgpath := ""
        for i, field := range fields </span><span class="cov0" title="0">{
                if field.Name == "" </span><span class="cov0" title="0">{
                        panic("reflect.StructOf: field " + strconv.Itoa(i) + " has no name")</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">if !isValidFieldName(field.Name) </span><span class="cov0" title="0">{
                        panic("reflect.StructOf: field " + strconv.Itoa(i) + " has invalid name")</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">if field.Type == nil </span><span class="cov0" title="0">{
                        panic("reflect.StructOf: field " + strconv.Itoa(i) + " has no type")</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">f, fpkgpath := runtimeStructField(field)
                ft := f.typ
                if ft.kind&amp;kindGCProg != 0 </span><span class="cov0" title="0">{
                        hasGCProg = true
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if fpkgpath != "" </span><span class="cov0" title="0">{
                        if pkgpath == "" </span><span class="cov0" title="0">{
                                pkgpath = fpkgpath
                        }</span><span class="cov0" title="0"> else if pkgpath != fpkgpath </span><span class="cov0" title="0">{
                                panic("reflect.Struct: fields with different PkgPath " + pkgpath + " and " + fpkgpath)</span>
                        }<span class="cov0" title="0">
</span>                }<span class="cov0" title="0">
</span>
                // Update string and hash
                <span class="cov0" title="0">name := f.name.name()
                hash = fnv1(hash, []byte(name)...)
                repr = append(repr, (" " + name)...)
                if f.embedded() </span><span class="cov0" title="0">{
                        // Embedded field
                        if f.typ.Kind() == Ptr </span><span class="cov0" title="0">{
                                // Embedded ** and *interface{} are illegal
                                elem := ft.Elem()
                                if k := elem.Kind(); k == Ptr || k == Interface </span><span class="cov0" title="0">{
                                        panic("reflect.StructOf: illegal embedded field type " + ft.String())</span>
                                }<span class="cov0" title="0">
</span>                        }<span class="cov0" title="0">
</span>
                        <span class="cov0" title="0">switch f.typ.Kind() </span>{
                        <span class="cov0" title="0">case Interface:
                                ift := (*interfaceType)(unsafe.Pointer(ft))
                                for im, m := range ift.methods </span><span class="cov0" title="0">{
                                        if ift.nameOff(m.name).pkgPath() != "" </span><span class="cov0" title="0">{
                                                // TODO(sbinet).  Issue 15924.
                                                panic("reflect: embedded interface with unexported method(s) not implemented")</span>
                                        }<span class="cov0" title="0">
</span>
                                        <span class="cov0" title="0">var (
                                                mtyp    = ift.typeOff(m.typ)
                                                ifield  = i
                                                imethod = im
                                                ifn     Value
                                                tfn     Value
                                        )

                                        if ft.kind&amp;kindDirectIface != 0 </span><span class="cov0" title="0">{
                                                tfn = MakeFunc(mtyp, func(in []Value) []Value </span><span class="cov0" title="0">{
                                                        var args []Value
                                                        var recv = in[0]
                                                        if len(in) &gt; 1 </span><span class="cov0" title="0">{
                                                                args = in[1:]
                                                        }</span><span class="cov0" title="0">
</span>                                                        <span class="cov0" title="0">return recv.Field(ifield).Method(imethod).Call(args)</span>
                                                })
                                                <span class="cov0" title="0">ifn = MakeFunc(mtyp, func(in []Value) []Value </span><span class="cov0" title="0">{
                                                        var args []Value
                                                        var recv = in[0]
                                                        if len(in) &gt; 1 </span><span class="cov0" title="0">{
                                                                args = in[1:]
                                                        }</span><span class="cov0" title="0">
</span>                                                        <span class="cov0" title="0">return recv.Field(ifield).Method(imethod).Call(args)</span>
                                                })
                                        }<span class="cov0" title="0"> else {
                                                tfn = MakeFunc(mtyp, func(in []Value) []Value </span><span class="cov0" title="0">{
                                                        var args []Value
                                                        var recv = in[0]
                                                        if len(in) &gt; 1 </span><span class="cov0" title="0">{
                                                                args = in[1:]
                                                        }</span><span class="cov0" title="0">
</span>                                                        <span class="cov0" title="0">return recv.Field(ifield).Method(imethod).Call(args)</span>
                                                })
                                                <span class="cov0" title="0">ifn = MakeFunc(mtyp, func(in []Value) []Value </span><span class="cov0" title="0">{
                                                        var args []Value
                                                        var recv = Indirect(in[0])
                                                        if len(in) &gt; 1 </span><span class="cov0" title="0">{
                                                                args = in[1:]
                                                        }</span><span class="cov0" title="0">
</span>                                                        <span class="cov0" title="0">return recv.Field(ifield).Method(imethod).Call(args)</span>
                                                })
                                        }

                                        <span class="cov0" title="0">methods = append(methods, method{
                                                name: resolveReflectName(ift.nameOff(m.name)),
                                                mtyp: resolveReflectType(mtyp),
                                                ifn:  resolveReflectText(unsafe.Pointer(&amp;ifn)),
                                                tfn:  resolveReflectText(unsafe.Pointer(&amp;tfn)),
                                        })</span>
                                }
                        <span class="cov0" title="0">case Ptr:
                                ptr := (*ptrType)(unsafe.Pointer(ft))
                                if unt := ptr.uncommon(); unt != nil </span><span class="cov0" title="0">{
                                        if i &gt; 0 &amp;&amp; unt.mcount &gt; 0 </span><span class="cov0" title="0">{
                                                // Issue 15924.
                                                panic("reflect: embedded type with methods not implemented if type is not first field")</span>
                                        }<span class="cov0" title="0">
</span>                                        <span class="cov0" title="0">if len(fields) &gt; 1 </span><span class="cov0" title="0">{
                                                panic("reflect: embedded type with methods not implemented if there is more than one field")</span>
                                        }<span class="cov0" title="0">
</span>                                        <span class="cov0" title="0">for _, m := range unt.methods() </span><span class="cov0" title="0">{
                                                mname := ptr.nameOff(m.name)
                                                if mname.pkgPath() != "" </span><span class="cov0" title="0">{
                                                        // TODO(sbinet).
                                                        // Issue 15924.
                                                        panic("reflect: embedded interface with unexported method(s) not implemented")</span>
                                                }<span class="cov0" title="0">
</span>                                                <span class="cov0" title="0">methods = append(methods, method{
                                                        name: resolveReflectName(mname),
                                                        mtyp: resolveReflectType(ptr.typeOff(m.mtyp)),
                                                        ifn:  resolveReflectText(ptr.textOff(m.ifn)),
                                                        tfn:  resolveReflectText(ptr.textOff(m.tfn)),
                                                })</span>
                                        }
                                }<span class="cov0" title="0">
</span>                                <span class="cov0" title="0">if unt := ptr.elem.uncommon(); unt != nil </span><span class="cov0" title="0">{
                                        for _, m := range unt.methods() </span><span class="cov0" title="0">{
                                                mname := ptr.nameOff(m.name)
                                                if mname.pkgPath() != "" </span><span class="cov0" title="0">{
                                                        // TODO(sbinet)
                                                        // Issue 15924.
                                                        panic("reflect: embedded interface with unexported method(s) not implemented")</span>
                                                }<span class="cov0" title="0">
</span>                                                <span class="cov0" title="0">methods = append(methods, method{
                                                        name: resolveReflectName(mname),
                                                        mtyp: resolveReflectType(ptr.elem.typeOff(m.mtyp)),
                                                        ifn:  resolveReflectText(ptr.elem.textOff(m.ifn)),
                                                        tfn:  resolveReflectText(ptr.elem.textOff(m.tfn)),
                                                })</span>
                                        }
                                }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">default:
                                if unt := ft.uncommon(); unt != nil </span><span class="cov0" title="0">{
                                        if i &gt; 0 &amp;&amp; unt.mcount &gt; 0 </span><span class="cov0" title="0">{
                                                // Issue 15924.
                                                panic("reflect: embedded type with methods not implemented if type is not first field")</span>
                                        }<span class="cov0" title="0">
</span>                                        <span class="cov0" title="0">if len(fields) &gt; 1 &amp;&amp; ft.kind&amp;kindDirectIface != 0 </span><span class="cov0" title="0">{
                                                panic("reflect: embedded type with methods not implemented for non-pointer type")</span>
                                        }<span class="cov0" title="0">
</span>                                        <span class="cov0" title="0">for _, m := range unt.methods() </span><span class="cov0" title="0">{
                                                mname := ft.nameOff(m.name)
                                                if mname.pkgPath() != "" </span><span class="cov0" title="0">{
                                                        // TODO(sbinet)
                                                        // Issue 15924.
                                                        panic("reflect: embedded interface with unexported method(s) not implemented")</span>
                                                }<span class="cov0" title="0">
</span>                                                <span class="cov0" title="0">methods = append(methods, method{
                                                        name: resolveReflectName(mname),
                                                        mtyp: resolveReflectType(ft.typeOff(m.mtyp)),
                                                        ifn:  resolveReflectText(ft.textOff(m.ifn)),
                                                        tfn:  resolveReflectText(ft.textOff(m.tfn)),
                                                })</span>

                                        }
                                }<span class="cov0" title="0">
</span>                        }
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">if _, dup := fset[name]; dup </span><span class="cov0" title="0">{
                        panic("reflect.StructOf: duplicate field " + name)</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">fset[name] = struct{}{}

                hash = fnv1(hash, byte(ft.hash&gt;&gt;24), byte(ft.hash&gt;&gt;16), byte(ft.hash&gt;&gt;8), byte(ft.hash))

                repr = append(repr, (" " + ft.String())...)
                if f.name.tagLen() &gt; 0 </span><span class="cov0" title="0">{
                        hash = fnv1(hash, []byte(f.name.tag())...)
                        repr = append(repr, (" " + strconv.Quote(f.name.tag()))...)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if i &lt; len(fields)-1 </span><span class="cov0" title="0">{
                        repr = append(repr, ';')
                }</span><span class="cov0" title="0">
</span>
                <span class="cov0" title="0">comparable = comparable &amp;&amp; (ft.equal != nil)

                offset := align(size, uintptr(ft.align))
                if ft.align &gt; typalign </span><span class="cov0" title="0">{
                        typalign = ft.align
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">size = offset + ft.size
                f.offsetEmbed |= offset &lt;&lt; 1

                if ft.size == 0 </span><span class="cov0" title="0">{
                        lastzero = size
                }</span><span class="cov0" title="0">
</span>
                <span class="cov0" title="0">fs[i] = f</span>
        }

        <span class="cov0" title="0">if size &gt; 0 &amp;&amp; lastzero == size </span><span class="cov0" title="0">{
                // This is a non-zero sized struct that ends in a
                // zero-sized field. We add an extra byte of padding,
                // to ensure that taking the address of the final
                // zero-sized field can't manufacture a pointer to the
                // next object in the heap. See issue 9401.
                size++
        }</span><span class="cov0" title="0">
</span>
        <span class="cov8" title="1">var typ *structType
        var ut *uncommonType

        if len(methods) == 0 </span><span class="cov0" title="0">{
                t := new(structTypeUncommon)
                typ = &amp;t.structType
                ut = &amp;t.u
        }</span><span class="cov0" title="0"> else {
                // A *rtype representing a struct is followed directly in memory by an
                // array of method objects representing the methods attached to the
                // struct. To get the same layout for a run time generated type, we
                // need an array directly following the uncommonType memory.
                // A similar strategy is used for funcTypeFixed4, ...funcTypeFixedN.
                tt := New(StructOf([]StructField{
                        {Name: "S", Type: TypeOf(structType{})},
                        {Name: "U", Type: TypeOf(uncommonType{})},
                        {Name: "M", Type: ArrayOf(len(methods), TypeOf(methods[0]))},
                }))

                typ = (*structType)(unsafe.Pointer(tt.Elem().Field(0).UnsafeAddr()))
                ut = (*uncommonType)(unsafe.Pointer(tt.Elem().Field(1).UnsafeAddr()))

                copy(tt.Elem().Field(2).Slice(0, len(methods)).Interface().([]method), methods)
        }</span>
        // TODO(sbinet): Once we allow embedding multiple types,
        // methods will need to be sorted like the compiler does.
        // TODO(sbinet): Once we allow non-exported methods, we will
        // need to compute xcount as the number of exported methods.
        <span class="cov0" title="0">ut.mcount = uint16(len(methods))
        ut.xcount = ut.mcount
        ut.moff = uint32(unsafe.Sizeof(uncommonType{}))

        if len(fs) &gt; 0 </span><span class="cov0" title="0">{
                repr = append(repr, ' ')
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">repr = append(repr, '}')
        hash = fnv1(hash, '}')
        str := string(repr)

        // Round the size up to be a multiple of the alignment.
        size = align(size, uintptr(typalign))

        // Make the struct type.
        var istruct interface{} = struct{}{}
        prototype := *(**structType)(unsafe.Pointer(&amp;istruct))
        *typ = *prototype
        typ.fields = fs
        if pkgpath != "" </span><span class="cov0" title="0">{
                typ.pkgPath = newName(pkgpath, "", false)
        }</span><span class="cov0" title="0">
</span>
        // Look in cache.
        <span class="cov0" title="0">if ts, ok := structLookupCache.m.Load(hash); ok </span><span class="cov0" title="0">{
                for _, st := range ts.([]Type) </span><span class="cov0" title="0">{
                        t := st.common()
                        if haveIdenticalUnderlyingType(&amp;typ.rtype, t, true) </span><span class="cov0" title="0">{
                                return t
                        }</span><span class="cov0" title="0">
</span>                }
        }<span class="cov0" title="0">
</span>
        // Not in cache, lock and retry.
        <span class="cov0" title="0">structLookupCache.Lock()
        defer structLookupCache.Unlock()
        if ts, ok := structLookupCache.m.Load(hash); ok </span><span class="cov0" title="0">{
                for _, st := range ts.([]Type) </span><span class="cov0" title="0">{
                        t := st.common()
                        if haveIdenticalUnderlyingType(&amp;typ.rtype, t, true) </span><span class="cov0" title="0">{
                                return t
                        }</span><span class="cov0" title="0">
</span>                }
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">addToCache := func(t Type) Type </span><span class="cov0" title="0">{
                var ts []Type
                if ti, ok := structLookupCache.m.Load(hash); ok </span><span class="cov0" title="0">{
                        ts = ti.([]Type)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">structLookupCache.m.Store(hash, append(ts, t))
                return t</span>
        }

        // Look in known types.
        <span class="cov0" title="0">for _, t := range typesByString(str) </span><span class="cov0" title="0">{
                if haveIdenticalUnderlyingType(&amp;typ.rtype, t, true) </span><span class="cov0" title="0">{
                        // even if 't' wasn't a structType with methods, we should be ok
                        // as the 'u uncommonType' field won't be accessed except when
                        // tflag&amp;tflagUncommon is set.
                        return addToCache(t)
                }</span><span class="cov0" title="0">
</span>        }

        <span class="cov0" title="0">typ.str = resolveReflectName(newName(str, "", false))
        typ.tflag = 0 // TODO: set tflagRegularMemory
        typ.hash = hash
        typ.size = size
        typ.ptrdata = typeptrdata(typ.common())
        typ.align = typalign
        typ.fieldAlign = typalign
        typ.ptrToThis = 0
        if len(methods) &gt; 0 </span><span class="cov0" title="0">{
                typ.tflag |= tflagUncommon
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if hasGCProg </span><span class="cov0" title="0">{
                lastPtrField := 0
                for i, ft := range fs </span><span class="cov0" title="0">{
                        if ft.typ.pointers() </span><span class="cov0" title="0">{
                                lastPtrField = i
                        }</span><span class="cov0" title="0">
</span>                }
                <span class="cov0" title="0">prog := []byte{0, 0, 0, 0} // will be length of prog
                var off uintptr
                for i, ft := range fs </span><span class="cov0" title="0">{
                        if i &gt; lastPtrField </span><span class="cov0" title="0">{
                                // gcprog should not include anything for any field after
                                // the last field that contains pointer data
                                break</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">if !ft.typ.pointers() </span><span class="cov0" title="0">{
                                // Ignore pointerless fields.
                                continue</span>
                        }<span class="cov0" title="0">
</span>                        // Pad to start of this field with zeros.
                        <span class="cov0" title="0">if ft.offset() &gt; off </span><span class="cov0" title="0">{
                                n := (ft.offset() - off) / ptrSize
                                prog = append(prog, 0x01, 0x00) // emit a 0 bit
                                if n &gt; 1 </span><span class="cov0" title="0">{
                                        prog = append(prog, 0x81)      // repeat previous bit
                                        prog = appendVarint(prog, n-1) // n-1 times
                                }</span><span class="cov0" title="0">
</span>                                <span class="cov0" title="0">off = ft.offset()</span>
                        }<span class="cov0" title="0">
</span>
                        <span class="cov0" title="0">prog = appendGCProg(prog, ft.typ)
                        off += ft.typ.ptrdata</span>
                }
                <span class="cov0" title="0">prog = append(prog, 0)
                *(*uint32)(unsafe.Pointer(&amp;prog[0])) = uint32(len(prog) - 4)
                typ.kind |= kindGCProg
                typ.gcdata = &amp;prog[0]</span>
        }<span class="cov0" title="0"> else {
                typ.kind &amp;^= kindGCProg
                bv := new(bitVector)
                addTypeBits(bv, 0, typ.common())
                if len(bv.data) &gt; 0 </span><span class="cov0" title="0">{
                        typ.gcdata = &amp;bv.data[0]
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">typ.equal = nil
        if comparable </span><span class="cov0" title="0">{
                typ.equal = func(p, q unsafe.Pointer) bool </span><span class="cov0" title="0">{
                        for _, ft := range typ.fields </span><span class="cov0" title="0">{
                                pi := add(p, ft.offset(), "&amp;x.field safe")
                                qi := add(q, ft.offset(), "&amp;x.field safe")
                                if !ft.typ.equal(pi, qi) </span><span class="cov0" title="0">{
                                        return false
                                }</span><span class="cov0" title="0">
</span>                        }
                        <span class="cov0" title="0">return true</span>
                }
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">switch </span>{
        <span class="cov0" title="0">case len(fs) == 1 &amp;&amp; !ifaceIndir(fs[0].typ):
                // structs of 1 direct iface type can be direct
                typ.kind |= kindDirectIface</span>
        <span class="cov0" title="0">default:
                typ.kind &amp;^= kindDirectIface</span>
        }

        <span class="cov0" title="0">return addToCache(&amp;typ.rtype)</span>
}

// runtimeStructField takes a StructField value passed to StructOf and
// returns both the corresponding internal representation, of type
// structField, and the pkgpath value to use for this field.
func runtimeStructField(field StructField) (structField, string) <span class="cov0" title="0">{
        if field.Anonymous &amp;&amp; field.PkgPath != "" </span><span class="cov0" title="0">{
                panic("reflect.StructOf: field \"" + field.Name + "\" is anonymous but has PkgPath set")</span>
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">exported := field.PkgPath == ""
        if exported </span><span class="cov0" title="0">{
                // Best-effort check for misuse.
                // Since this field will be treated as exported, not much harm done if Unicode lowercase slips through.
                c := field.Name[0]
                if 'a' &lt;= c &amp;&amp; c &lt;= 'z' || c == '_' </span><span class="cov0" title="0">{
                        panic("reflect.StructOf: field \"" + field.Name + "\" is unexported but missing PkgPath")</span>
                }<span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">offsetEmbed := uintptr(0)
        if field.Anonymous </span><span class="cov0" title="0">{
                offsetEmbed |= 1
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">resolveReflectType(field.Type.common()) // install in runtime
        f := structField{
                name:        newName(field.Name, string(field.Tag), exported),
                typ:         field.Type.common(),
                offsetEmbed: offsetEmbed,
        }
        return f, field.PkgPath</span>
}

// typeptrdata returns the length in bytes of the prefix of t
// containing pointer data. Anything after this offset is scalar data.
// keep in sync with ../cmd/compile/internal/gc/reflect.go
func typeptrdata(t *rtype) uintptr <span class="cov0" title="0">{
        switch t.Kind() </span>{
        <span class="cov0" title="0">case Struct:
                st := (*structType)(unsafe.Pointer(t))
                // find the last field that has pointers.
                field := -1
                for i := range st.fields </span><span class="cov0" title="0">{
                        ft := st.fields[i].typ
                        if ft.pointers() </span><span class="cov0" title="0">{
                                field = i
                        }</span><span class="cov0" title="0">
</span>                }
                <span class="cov0" title="0">if field == -1 </span><span class="cov0" title="0">{
                        return 0
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">f := st.fields[field]
                return f.offset() + f.typ.ptrdata</span>

        <span class="cov0" title="0">default:
                panic("reflect.typeptrdata: unexpected type, " + t.String())</span>
        }
}

// See cmd/compile/internal/gc/reflect.go for derivation of constant.
const maxPtrmaskBytes = 2048

// ArrayOf returns the array type with the given count and element type.
// For example, if t represents int, ArrayOf(5, t) represents [5]int.
//
// If the resulting type would be larger than the available address space,
// ArrayOf panics.
func ArrayOf(count int, elem Type) Type <span class="cov0" title="0">{
        typ := elem.(*rtype)

        // Look in cache.
        ckey := cacheKey{Array, typ, nil, uintptr(count)}
        if array, ok := lookupCache.Load(ckey); ok </span><span class="cov0" title="0">{
                return array.(Type)
        }</span><span class="cov0" title="0">
</span>
        // Look in known types.
        <span class="cov0" title="0">s := "[" + strconv.Itoa(count) + "]" + typ.String()
        for _, tt := range typesByString(s) </span><span class="cov0" title="0">{
                array := (*arrayType)(unsafe.Pointer(tt))
                if array.elem == typ </span><span class="cov0" title="0">{
                        ti, _ := lookupCache.LoadOrStore(ckey, tt)
                        return ti.(Type)
                }</span><span class="cov0" title="0">
</span>        }

        // Make an array type.
        <span class="cov0" title="0">var iarray interface{} = [1]unsafe.Pointer{}
        prototype := *(**arrayType)(unsafe.Pointer(&amp;iarray))
        array := *prototype
        array.tflag = typ.tflag &amp; tflagRegularMemory
        array.str = resolveReflectName(newName(s, "", false))
        array.hash = fnv1(typ.hash, '[')
        for n := uint32(count); n &gt; 0; n &gt;&gt;= 8 </span><span class="cov0" title="0">{
                array.hash = fnv1(array.hash, byte(n))
        }</span>
        <span class="cov0" title="0">array.hash = fnv1(array.hash, ']')
        array.elem = typ
        array.ptrToThis = 0
        if typ.size &gt; 0 </span><span class="cov0" title="0">{
                max := ^uintptr(0) / typ.size
                if uintptr(count) &gt; max </span><span class="cov0" title="0">{
                        panic("reflect.ArrayOf: array size would exceed virtual address space")</span>
                }<span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">array.size = typ.size * uintptr(count)
        if count &gt; 0 &amp;&amp; typ.ptrdata != 0 </span><span class="cov0" title="0">{
                array.ptrdata = typ.size*uintptr(count-1) + typ.ptrdata
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">array.align = typ.align
        array.fieldAlign = typ.fieldAlign
        array.len = uintptr(count)
        array.slice = SliceOf(elem).(*rtype)

        switch </span>{
        <span class="cov0" title="0">case typ.ptrdata == 0 || array.size == 0:
                // No pointers.
                array.gcdata = nil
                array.ptrdata = 0</span>

        <span class="cov0" title="0">case count == 1:
                // In memory, 1-element array looks just like the element.
                array.kind |= typ.kind &amp; kindGCProg
                array.gcdata = typ.gcdata
                array.ptrdata = typ.ptrdata</span>

        <span class="cov0" title="0">case typ.kind&amp;kindGCProg == 0 &amp;&amp; array.size &lt;= maxPtrmaskBytes*8*ptrSize:
                // Element is small with pointer mask; array is still small.
                // Create direct pointer mask by turning each 1 bit in elem
                // into count 1 bits in larger mask.
                mask := make([]byte, (array.ptrdata/ptrSize+7)/8)
                emitGCMask(mask, 0, typ, array.len)
                array.gcdata = &amp;mask[0]</span>

        <span class="cov0" title="0">default:
                // Create program that emits one element
                // and then repeats to make the array.
                prog := []byte{0, 0, 0, 0} // will be length of prog
                prog = appendGCProg(prog, typ)
                // Pad from ptrdata to size.
                elemPtrs := typ.ptrdata / ptrSize
                elemWords := typ.size / ptrSize
                if elemPtrs &lt; elemWords </span><span class="cov0" title="0">{
                        // Emit literal 0 bit, then repeat as needed.
                        prog = append(prog, 0x01, 0x00)
                        if elemPtrs+1 &lt; elemWords </span><span class="cov0" title="0">{
                                prog = append(prog, 0x81)
                                prog = appendVarint(prog, elemWords-elemPtrs-1)
                        }</span><span class="cov0" title="0">
</span>                }<span class="cov0" title="0">
</span>                // Repeat count-1 times.
                <span class="cov0" title="0">if elemWords &lt; 0x80 </span><span class="cov0" title="0">{
                        prog = append(prog, byte(elemWords|0x80))
                }</span><span class="cov0" title="0"> else {
                        prog = append(prog, 0x80)
                        prog = appendVarint(prog, elemWords)
                }</span>
                <span class="cov0" title="0">prog = appendVarint(prog, uintptr(count)-1)
                prog = append(prog, 0)
                *(*uint32)(unsafe.Pointer(&amp;prog[0])) = uint32(len(prog) - 4)
                array.kind |= kindGCProg
                array.gcdata = &amp;prog[0]
                array.ptrdata = array.size</span> // overestimate but ok; must match program
        }

        <span class="cov0" title="0">etyp := typ.common()
        esize := etyp.Size()

        array.equal = nil
        if eequal := etyp.equal; eequal != nil </span><span class="cov0" title="0">{
                array.equal = func(p, q unsafe.Pointer) bool </span><span class="cov0" title="0">{
                        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                                pi := arrayAt(p, i, esize, "i &lt; count")
                                qi := arrayAt(q, i, esize, "i &lt; count")
                                if !eequal(pi, qi) </span><span class="cov0" title="0">{
                                        return false
                                }</span><span class="cov0" title="0">
</span>
                        }
                        <span class="cov0" title="0">return true</span>
                }
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">switch </span>{
        <span class="cov0" title="0">case count == 1 &amp;&amp; !ifaceIndir(typ):
                // array of 1 direct iface type can be direct
                array.kind |= kindDirectIface</span>
        <span class="cov0" title="0">default:
                array.kind &amp;^= kindDirectIface</span>
        }

        <span class="cov0" title="0">ti, _ := lookupCache.LoadOrStore(ckey, &amp;array.rtype)
        return ti.(Type)</span>
}

func appendVarint(x []byte, v uintptr) []byte <span class="cov0" title="0">{
        for ; v &gt;= 0x80; v &gt;&gt;= 7 </span><span class="cov0" title="0">{
                x = append(x, byte(v|0x80))
        }</span>
        <span class="cov0" title="0">x = append(x, byte(v))
        return x</span>
}

// toType converts from a *rtype to a Type that can be returned
// to the client of package reflect. In gc, the only concern is that
// a nil *rtype must be replaced by a nil Type, but in gccgo this
// function takes care of ensuring that multiple *rtype for the same
// type are coalesced into a single Type.
func toType(t *rtype) Type <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return t</span>
}

type layoutKey struct {
        ftyp *funcType // function signature
        rcvr *rtype    // receiver type, or nil if none
}

type layoutType struct {
        t         *rtype
        argSize   uintptr // size of arguments
        retOffset uintptr // offset of return values.
        stack     *bitVector
        framePool *sync.Pool
}

var layoutCache sync.Map // map[layoutKey]layoutType

// funcLayout computes a struct type representing the layout of the
// function arguments and return values for the function type t.
// If rcvr != nil, rcvr specifies the type of the receiver.
// The returned type exists only for GC, so we only fill out GC relevant info.
// Currently, that's just size and the GC program. We also fill in
// the name for possible debugging use.
func funcLayout(t *funcType, rcvr *rtype) (frametype *rtype, argSize, retOffset uintptr, stk *bitVector, framePool *sync.Pool) <span class="cov0" title="0">{
        if t.Kind() != Func </span><span class="cov0" title="0">{
                panic("reflect: funcLayout of non-func type " + t.String())</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if rcvr != nil &amp;&amp; rcvr.Kind() == Interface </span><span class="cov0" title="0">{
                panic("reflect: funcLayout with interface receiver " + rcvr.String())</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">k := layoutKey{t, rcvr}
        if lti, ok := layoutCache.Load(k); ok </span><span class="cov0" title="0">{
                lt := lti.(layoutType)
                return lt.t, lt.argSize, lt.retOffset, lt.stack, lt.framePool
        }</span><span class="cov0" title="0">
</span>
        // compute gc program &amp; stack bitmap for arguments
        <span class="cov0" title="0">ptrmap := new(bitVector)
        var offset uintptr
        if rcvr != nil </span><span class="cov0" title="0">{
                // Reflect uses the "interface" calling convention for
                // methods, where receivers take one word of argument
                // space no matter how big they actually are.
                if ifaceIndir(rcvr) || rcvr.pointers() </span><span class="cov0" title="0">{
                        ptrmap.append(1)
                }</span><span class="cov0" title="0"> else {
                        ptrmap.append(0)
                }</span>
                <span class="cov0" title="0">offset += ptrSize</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">for _, arg := range t.in() </span><span class="cov0" title="0">{
                offset += -offset &amp; uintptr(arg.align-1)
                addTypeBits(ptrmap, offset, arg)
                offset += arg.size
        }</span>
        <span class="cov0" title="0">argSize = offset
        offset += -offset &amp; (ptrSize - 1)
        retOffset = offset
        for _, res := range t.out() </span><span class="cov0" title="0">{
                offset += -offset &amp; uintptr(res.align-1)
                addTypeBits(ptrmap, offset, res)
                offset += res.size
        }</span>
        <span class="cov0" title="0">offset += -offset &amp; (ptrSize - 1)

        // build dummy rtype holding gc program
        x := &amp;rtype{
                align:   ptrSize,
                size:    offset,
                ptrdata: uintptr(ptrmap.n) * ptrSize,
        }
        if ptrmap.n &gt; 0 </span><span class="cov0" title="0">{
                x.gcdata = &amp;ptrmap.data[0]
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">var s string
        if rcvr != nil </span><span class="cov0" title="0">{
                s = "methodargs(" + rcvr.String() + ")(" + t.String() + ")"
        }</span><span class="cov0" title="0"> else {
                s = "funcargs(" + t.String() + ")"
        }</span>
        <span class="cov0" title="0">x.str = resolveReflectName(newName(s, "", false))

        // cache result for future callers
        framePool = &amp;sync.Pool{New: func() interface{} </span><span class="cov0" title="0">{
                return unsafe_New(x)
        }</span>}
        <span class="cov0" title="0">lti, _ := layoutCache.LoadOrStore(k, layoutType{
                t:         x,
                argSize:   argSize,
                retOffset: retOffset,
                stack:     ptrmap,
                framePool: framePool,
        })
        lt := lti.(layoutType)
        return lt.t, lt.argSize, lt.retOffset, lt.stack, lt.framePool</span>
}

// ifaceIndir reports whether t is stored indirectly in an interface value.
func ifaceIndir(t *rtype) bool <span class="cov0" title="0">{
        return t.kind&amp;kindDirectIface == 0
}</span>

// Note: this type must agree with runtime.bitvector.
type bitVector struct {
        n    uint32 // number of bits
        data []byte
}

// append a bit to the bitmap.
func (bv *bitVector) append(bit uint8) <span class="cov0" title="0">{
        if bv.n%8 == 0 </span><span class="cov0" title="0">{
                bv.data = append(bv.data, 0)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">bv.data[bv.n/8] |= bit &lt;&lt; (bv.n % 8)
        bv.n++</span>
}

func addTypeBits(bv *bitVector, offset uintptr, t *rtype) <span class="cov0" title="0">{
        if t.ptrdata == 0 </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">switch Kind(t.kind &amp; kindMask) </span>{
        <span class="cov0" title="0">case Chan, Func, Map, Ptr, Slice, String, UnsafePointer:
                // 1 pointer at start of representation
                for bv.n &lt; uint32(offset/uintptr(ptrSize)) </span><span class="cov0" title="0">{
                        bv.append(0)
                }</span>
                <span class="cov0" title="0">bv.append(1)</span>

        <span class="cov0" title="0">case Interface:
                // 2 pointers
                for bv.n &lt; uint32(offset/uintptr(ptrSize)) </span><span class="cov0" title="0">{
                        bv.append(0)
                }</span>
                <span class="cov0" title="0">bv.append(1)
                bv.append(1)</span>

        <span class="cov0" title="0">case Array:
                // repeat inner type
                tt := (*arrayType)(unsafe.Pointer(t))
                for i := 0; i &lt; int(tt.len); i++ </span><span class="cov0" title="0">{
                        addTypeBits(bv, offset+uintptr(i)*tt.elem.size, tt.elem)
                }</span>

        <span class="cov0" title="0">case Struct:
                // apply fields
                tt := (*structType)(unsafe.Pointer(t))
                for i := range tt.fields </span><span class="cov0" title="0">{
                        f := &amp;tt.fields[i]
                        addTypeBits(bv, offset+f.offset(), f.typ)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package reflect

import (
        "internal/unsafeheader"
        "math"
        "runtime"
        "unsafe"
)

const ptrSize = 4 &lt;&lt; (^uintptr(0) &gt;&gt; 63) // unsafe.Sizeof(uintptr(0)) but an ideal const

// Value is the reflection interface to a Go value.
//
// Not all methods apply to all kinds of values. Restrictions,
// if any, are noted in the documentation for each method.
// Use the Kind method to find out the kind of value before
// calling kind-specific methods. Calling a method
// inappropriate to the kind of type causes a run time panic.
//
// The zero Value represents no value.
// Its IsValid method returns false, its Kind method returns Invalid,
// its String method returns "&lt;invalid Value&gt;", and all other methods panic.
// Most functions and methods never return an invalid value.
// If one does, its documentation states the conditions explicitly.
//
// A Value can be used concurrently by multiple goroutines provided that
// the underlying Go value can be used concurrently for the equivalent
// direct operations.
//
// To compare two Values, compare the results of the Interface method.
// Using == on two Values does not compare the underlying values
// they represent.
type Value struct {
        // typ holds the type of the value represented by a Value.
        typ *rtype

        // Pointer-valued data or, if flagIndir is set, pointer to data.
        // Valid when either flagIndir is set or typ.pointers() is true.
        ptr unsafe.Pointer

        // flag holds metadata about the value.
        // The lowest bits are flag bits:
        //        - flagStickyRO: obtained via unexported not embedded field, so read-only
        //        - flagEmbedRO: obtained via unexported embedded field, so read-only
        //        - flagIndir: val holds a pointer to the data
        //        - flagAddr: v.CanAddr is true (implies flagIndir)
        //        - flagMethod: v is a method value.
        // The next five bits give the Kind of the value.
        // This repeats typ.Kind() except for method values.
        // The remaining 23+ bits give a method number for method values.
        // If flag.kind() != Func, code can assume that flagMethod is unset.
        // If ifaceIndir(typ), code can assume that flagIndir is set.
        flag

        // A method value represents a curried method invocation
        // like r.Read for some receiver r. The typ+val+flag bits describe
        // the receiver r, but the flag's Kind bits say Func (methods are
        // functions), and the top bits of the flag give the method number
        // in r's type's method table.
}

type flag uintptr

const (
        flagKindWidth        = 5 // there are 27 kinds
        flagKindMask    flag = 1&lt;&lt;flagKindWidth - 1
        flagStickyRO    flag = 1 &lt;&lt; 5
        flagEmbedRO     flag = 1 &lt;&lt; 6
        flagIndir       flag = 1 &lt;&lt; 7
        flagAddr        flag = 1 &lt;&lt; 8
        flagMethod      flag = 1 &lt;&lt; 9
        flagMethodShift      = 10
        flagRO          flag = flagStickyRO | flagEmbedRO
)

func (f flag) kind() Kind <span class="cov0" title="0">{
        return Kind(f &amp; flagKindMask)
}</span>

func (f flag) ro() flag <span class="cov0" title="0">{
        if f&amp;flagRO != 0 </span><span class="cov0" title="0">{
                return flagStickyRO
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return 0</span>
}

// pointer returns the underlying pointer represented by v.
// v.Kind() must be Ptr, Map, Chan, Func, or UnsafePointer
func (v Value) pointer() unsafe.Pointer <span class="cov0" title="0">{
        if v.typ.size != ptrSize || !v.typ.pointers() </span><span class="cov0" title="0">{
                panic("can't call pointer on a non-pointer Value")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if v.flag&amp;flagIndir != 0 </span><span class="cov0" title="0">{
                return *(*unsafe.Pointer)(v.ptr)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return v.ptr</span>
}

// packEface converts v to the empty interface.
func packEface(v Value) interface{} <span class="cov0" title="0">{
        t := v.typ
        var i interface{}
        e := (*emptyInterface)(unsafe.Pointer(&amp;i))
        // First, fill in the data portion of the interface.
        switch </span>{
        <span class="cov0" title="0">case ifaceIndir(t):
                if v.flag&amp;flagIndir == 0 </span><span class="cov0" title="0">{
                        panic("bad indir")</span>
                }<span class="cov0" title="0">
</span>                // Value is indirect, and so is the interface we're making.
                <span class="cov0" title="0">ptr := v.ptr
                if v.flag&amp;flagAddr != 0 </span><span class="cov0" title="0">{
                        // TODO: pass safe boolean from valueInterface so
                        // we don't need to copy if safe==true?
                        c := unsafe_New(t)
                        typedmemmove(t, c, ptr)
                        ptr = c
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">e.word = ptr</span>
        <span class="cov0" title="0">case v.flag&amp;flagIndir != 0:
                // Value is indirect, but interface is direct. We need
                // to load the data at v.ptr into the interface data word.
                e.word = *(*unsafe.Pointer)(v.ptr)</span>
        <span class="cov0" title="0">default:
                // Value is direct, and so is the interface.
                e.word = v.ptr</span>
        }
        // Now, fill in the type portion. We're very careful here not
        // to have any operation between the e.word and e.typ assignments
        // that would let the garbage collector observe the partially-built
        // interface value.
        <span class="cov0" title="0">e.typ = t
        return i</span>
}

// unpackEface converts the empty interface i to a Value.
func unpackEface(i interface{}) Value <span class="cov0" title="0">{
        e := (*emptyInterface)(unsafe.Pointer(&amp;i))
        // NOTE: don't read e.word until we know whether it is really a pointer or not.
        t := e.typ
        if t == nil </span><span class="cov0" title="0">{
                return Value{}
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">f := flag(t.Kind())
        if ifaceIndir(t) </span><span class="cov0" title="0">{
                f |= flagIndir
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return Value{t, e.word, f}</span>
}

// A ValueError occurs when a Value method is invoked on
// a Value that does not support it. Such cases are documented
// in the description of each method.
type ValueError struct {
        Method string
        Kind   Kind
}

func (e *ValueError) Error() string <span class="cov0" title="0">{
        if e.Kind == 0 </span><span class="cov0" title="0">{
                return "reflect: call of " + e.Method + " on zero Value"
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return "reflect: call of " + e.Method + " on " + e.Kind.String() + " Value"</span>
}

// methodName returns the name of the calling method,
// assumed to be two stack frames above.
func methodName() string <span class="cov0" title="0">{
        pc, _, _, _ := runtime.Caller(2)
        f := runtime.FuncForPC(pc)
        if f == nil </span><span class="cov0" title="0">{
                return "unknown method"
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return f.Name()</span>
}

// methodNameSkip is like methodName, but skips another stack frame.
// This is a separate function so that reflect.flag.mustBe will be inlined.
func methodNameSkip() string <span class="cov0" title="0">{
        pc, _, _, _ := runtime.Caller(3)
        f := runtime.FuncForPC(pc)
        if f == nil </span><span class="cov0" title="0">{
                return "unknown method"
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return f.Name()</span>
}

// emptyInterface is the header for an interface{} value.
type emptyInterface struct {
        typ  *rtype
        word unsafe.Pointer
}

// nonEmptyInterface is the header for an interface value with methods.
type nonEmptyInterface struct {
        // see ../runtime/iface.go:/Itab
        itab *struct {
                ityp *rtype // static interface type
                typ  *rtype // dynamic concrete type
                hash uint32 // copy of typ.hash
                _    [4]byte
                fun  [100000]unsafe.Pointer // method table
        }
        word unsafe.Pointer
}

// mustBe panics if f's kind is not expected.
// Making this a method on flag instead of on Value
// (and embedding flag in Value) means that we can write
// the very clear v.mustBe(Bool) and have it compile into
// v.flag.mustBe(Bool), which will only bother to copy the
// single important word for the receiver.
func (f flag) mustBe(expected Kind) <span class="cov0" title="0">{
        // TODO(mvdan): use f.kind() again once mid-stack inlining gets better
        if Kind(f&amp;flagKindMask) != expected </span><span class="cov0" title="0">{
                panic(&amp;ValueError{methodName(), f.kind()})</span>
        }<span class="cov0" title="0">
</span>}

// mustBeExported panics if f records that the value was obtained using
// an unexported field.
func (f flag) mustBeExported() <span class="cov0" title="0">{
        if f == 0 || f&amp;flagRO != 0 </span><span class="cov0" title="0">{
                f.mustBeExportedSlow()
        }</span><span class="cov0" title="0">
</span>}

func (f flag) mustBeExportedSlow() <span class="cov0" title="0">{
        if f == 0 </span><span class="cov0" title="0">{
                panic(&amp;ValueError{methodNameSkip(), Invalid})</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if f&amp;flagRO != 0 </span><span class="cov0" title="0">{
                panic("reflect: " + methodNameSkip() + " using value obtained using unexported field")</span>
        }<span class="cov0" title="0">
</span>}

// mustBeAssignable panics if f records that the value is not assignable,
// which is to say that either it was obtained using an unexported field
// or it is not addressable.
func (f flag) mustBeAssignable() <span class="cov0" title="0">{
        if f&amp;flagRO != 0 || f&amp;flagAddr == 0 </span><span class="cov0" title="0">{
                f.mustBeAssignableSlow()
        }</span><span class="cov0" title="0">
</span>}

func (f flag) mustBeAssignableSlow() <span class="cov0" title="0">{
        if f == 0 </span><span class="cov0" title="0">{
                panic(&amp;ValueError{methodNameSkip(), Invalid})</span>
        }<span class="cov0" title="0">
</span>        // Assignable if addressable and not read-only.
        <span class="cov0" title="0">if f&amp;flagRO != 0 </span><span class="cov0" title="0">{
                panic("reflect: " + methodNameSkip() + " using value obtained using unexported field")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if f&amp;flagAddr == 0 </span><span class="cov0" title="0">{
                panic("reflect: " + methodNameSkip() + " using unaddressable value")</span>
        }<span class="cov0" title="0">
</span>}

// Addr returns a pointer value representing the address of v.
// It panics if CanAddr() returns false.
// Addr is typically used to obtain a pointer to a struct field
// or slice element in order to call a method that requires a
// pointer receiver.
func (v Value) Addr() Value <span class="cov0" title="0">{
        if v.flag&amp;flagAddr == 0 </span><span class="cov0" title="0">{
                panic("reflect.Value.Addr of unaddressable value")</span>
        }<span class="cov0" title="0">
</span>        // Preserve flagRO instead of using v.flag.ro() so that
        // v.Addr().Elem() is equivalent to v (#32772)
        <span class="cov0" title="0">fl := v.flag &amp; flagRO
        return Value{v.typ.ptrTo(), v.ptr, fl | flag(Ptr)}</span>
}

// Bool returns v's underlying value.
// It panics if v's kind is not Bool.
func (v Value) Bool() bool <span class="cov0" title="0">{
        v.mustBe(Bool)
        return *(*bool)(v.ptr)
}</span>

// Bytes returns v's underlying value.
// It panics if v's underlying value is not a slice of bytes.
func (v Value) Bytes() []byte <span class="cov0" title="0">{
        v.mustBe(Slice)
        if v.typ.Elem().Kind() != Uint8 </span><span class="cov0" title="0">{
                panic("reflect.Value.Bytes of non-byte slice")</span>
        }<span class="cov0" title="0">
</span>        // Slice is always bigger than a word; assume flagIndir.
        <span class="cov0" title="0">return *(*[]byte)(v.ptr)</span>
}

// runes returns v's underlying value.
// It panics if v's underlying value is not a slice of runes (int32s).
func (v Value) runes() []rune <span class="cov0" title="0">{
        v.mustBe(Slice)
        if v.typ.Elem().Kind() != Int32 </span><span class="cov0" title="0">{
                panic("reflect.Value.Bytes of non-rune slice")</span>
        }<span class="cov0" title="0">
</span>        // Slice is always bigger than a word; assume flagIndir.
        <span class="cov0" title="0">return *(*[]rune)(v.ptr)</span>
}

// CanAddr reports whether the value's address can be obtained with Addr.
// Such values are called addressable. A value is addressable if it is
// an element of a slice, an element of an addressable array,
// a field of an addressable struct, or the result of dereferencing a pointer.
// If CanAddr returns false, calling Addr will panic.
func (v Value) CanAddr() bool <span class="cov0" title="0">{
        return v.flag&amp;flagAddr != 0
}</span>

// CanSet reports whether the value of v can be changed.
// A Value can be changed only if it is addressable and was not
// obtained by the use of unexported struct fields.
// If CanSet returns false, calling Set or any type-specific
// setter (e.g., SetBool, SetInt) will panic.
func (v Value) CanSet() bool <span class="cov0" title="0">{
        return v.flag&amp;(flagAddr|flagRO) == flagAddr
}</span>

// Call calls the function v with the input arguments in.
// For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]).
// Call panics if v's Kind is not Func.
// It returns the output results as Values.
// As in Go, each input argument must be assignable to the
// type of the function's corresponding input parameter.
// If v is a variadic function, Call creates the variadic slice parameter
// itself, copying in the corresponding values.
func (v Value) Call(in []Value) []Value <span class="cov0" title="0">{
        v.mustBe(Func)
        v.mustBeExported()
        return v.call("Call", in)
}</span>

// CallSlice calls the variadic function v with the input arguments in,
// assigning the slice in[len(in)-1] to v's final variadic argument.
// For example, if len(in) == 3, v.CallSlice(in) represents the Go call v(in[0], in[1], in[2]...).
// CallSlice panics if v's Kind is not Func or if v is not variadic.
// It returns the output results as Values.
// As in Go, each input argument must be assignable to the
// type of the function's corresponding input parameter.
func (v Value) CallSlice(in []Value) []Value <span class="cov0" title="0">{
        v.mustBe(Func)
        v.mustBeExported()
        return v.call("CallSlice", in)
}</span>

var callGC bool // for testing; see TestCallMethodJump

func (v Value) call(op string, in []Value) []Value <span class="cov0" title="0">{
        // Get function pointer, type.
        t := (*funcType)(unsafe.Pointer(v.typ))
        var (
                fn       unsafe.Pointer
                rcvr     Value
                rcvrtype *rtype
        )
        if v.flag&amp;flagMethod != 0 </span><span class="cov0" title="0">{
                rcvr = v
                rcvrtype, t, fn = methodReceiver(op, v, int(v.flag)&gt;&gt;flagMethodShift)
        }</span><span class="cov0" title="0"> else if v.flag&amp;flagIndir != 0 </span><span class="cov0" title="0">{
                fn = *(*unsafe.Pointer)(v.ptr)
        }</span><span class="cov0" title="0"> else {
                fn = v.ptr
        }</span>

        <span class="cov0" title="0">if fn == nil </span><span class="cov0" title="0">{
                panic("reflect.Value.Call: call of nil function")</span>
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">isSlice := op == "CallSlice"
        n := t.NumIn()
        if isSlice </span><span class="cov0" title="0">{
                if !t.IsVariadic() </span><span class="cov0" title="0">{
                        panic("reflect: CallSlice of non-variadic function")</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">if len(in) &lt; n </span><span class="cov0" title="0">{
                        panic("reflect: CallSlice with too few input arguments")</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">if len(in) &gt; n </span><span class="cov0" title="0">{
                        panic("reflect: CallSlice with too many input arguments")</span>
                }<span class="cov0" title="0">
</span>        }<span class="cov0" title="0"> else {
                if t.IsVariadic() </span><span class="cov0" title="0">{
                        n--
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if len(in) &lt; n </span><span class="cov0" title="0">{
                        panic("reflect: Call with too few input arguments")</span>
                }<span class="cov8" title="1">
</span>                <span class="cov0" title="0">if !t.IsVariadic() &amp;&amp; len(in) &gt; n </span><span class="cov0" title="0">{
                        panic("reflect: Call with too many input arguments")</span>
                }<span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">for _, x := range in </span><span class="cov0" title="0">{
                if x.Kind() == Invalid </span><span class="cov0" title="0">{
                        panic("reflect: " + op + " using zero Value argument")</span>
                }<span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                if xt, targ := in[i].Type(), t.In(i); !xt.AssignableTo(targ) </span><span class="cov0" title="0">{
                        panic("reflect: " + op + " using " + xt.String() + " as type " + targ.String())</span>
                }<span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">if !isSlice &amp;&amp; t.IsVariadic() </span><span class="cov0" title="0">{
                // prepare slice for remaining values
                m := len(in) - n
                slice := MakeSlice(t.In(n), m, m)
                elem := t.In(n).Elem()
                for i := 0; i &lt; m; i++ </span><span class="cov0" title="0">{
                        x := in[n+i]
                        if xt := x.Type(); !xt.AssignableTo(elem) </span><span class="cov0" title="0">{
                                panic("reflect: cannot use " + xt.String() + " as type " + elem.String() + " in " + op)</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">slice.Index(i).Set(x)</span>
                }
                <span class="cov0" title="0">origIn := in
                in = make([]Value, n+1)
                copy(in[:n], origIn)
                in[n] = slice</span>
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">nin := len(in)
        if nin != t.NumIn() </span><span class="cov0" title="0">{
                panic("reflect.Value.Call: wrong argument count")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">nout := t.NumOut()

        // Compute frame type.
        frametype, _, retOffset, _, framePool := funcLayout(t, rcvrtype)

        // Allocate a chunk of memory for frame.
        var args unsafe.Pointer
        if nout == 0 </span><span class="cov0" title="0">{
                args = framePool.Get().(unsafe.Pointer)
        }</span><span class="cov0" title="0"> else {
                // Can't use pool if the function has return values.
                // We will leak pointer to args in ret, so its lifetime is not scoped.
                args = unsafe_New(frametype)
        }</span>
        <span class="cov0" title="0">off := uintptr(0)

        // Copy inputs into args.
        if rcvrtype != nil </span><span class="cov0" title="0">{
                storeRcvr(rcvr, args)
                off = ptrSize
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">for i, v := range in </span><span class="cov0" title="0">{
                v.mustBeExported()
                targ := t.In(i).(*rtype)
                a := uintptr(targ.align)
                off = (off + a - 1) &amp;^ (a - 1)
                n := targ.size
                if n == 0 </span><span class="cov0" title="0">{
                        // Not safe to compute args+off pointing at 0 bytes,
                        // because that might point beyond the end of the frame,
                        // but we still need to call assignTo to check assignability.
                        v.assignTo("reflect.Value.Call", targ, nil)
                        continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">addr := add(args, off, "n &gt; 0")
                v = v.assignTo("reflect.Value.Call", targ, addr)
                if v.flag&amp;flagIndir != 0 </span><span class="cov0" title="0">{
                        typedmemmove(targ, addr, v.ptr)
                }</span><span class="cov0" title="0"> else {
                        *(*unsafe.Pointer)(addr) = v.ptr
                }</span>
                <span class="cov0" title="0">off += n</span>
        }

        // Call.
        <span class="cov0" title="0">call(frametype, fn, args, uint32(frametype.size), uint32(retOffset))

        // For testing; see TestCallMethodJump.
        if callGC </span><span class="cov0" title="0">{
                runtime.GC()
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">var ret []Value
        if nout == 0 </span><span class="cov0" title="0">{
                typedmemclr(frametype, args)
                framePool.Put(args)
        }</span><span class="cov0" title="0"> else {
                // Zero the now unused input area of args,
                // because the Values returned by this function contain pointers to the args object,
                // and will thus keep the args object alive indefinitely.
                typedmemclrpartial(frametype, args, 0, retOffset)

                // Wrap Values around return values in args.
                ret = make([]Value, nout)
                off = retOffset
                for i := 0; i &lt; nout; i++ </span><span class="cov0" title="0">{
                        tv := t.Out(i)
                        a := uintptr(tv.Align())
                        off = (off + a - 1) &amp;^ (a - 1)
                        if tv.Size() != 0 </span><span class="cov0" title="0">{
                                fl := flagIndir | flag(tv.Kind())
                                ret[i] = Value{tv.common(), add(args, off, "tv.Size() != 0"), fl}
                                // Note: this does introduce false sharing between results -
                                // if any result is live, they are all live.
                                // (And the space for the args is live as well, but as we've
                                // cleared that space it isn't as big a deal.)
                        }</span><span class="cov0" title="0"> else {
                                // For zero-sized return value, args+off may point to the next object.
                                // In this case, return the zero value instead.
                                ret[i] = Zero(tv)
                        }</span>
                        <span class="cov0" title="0">off += tv.Size()</span>
                }
        }

        <span class="cov0" title="0">return ret</span>
}

// callReflect is the call implementation used by a function
// returned by MakeFunc. In many ways it is the opposite of the
// method Value.call above. The method above converts a call using Values
// into a call of a function with a concrete argument frame, while
// callReflect converts a call of a function with a concrete argument
// frame into a call using Values.
// It is in this file so that it can be next to the call method above.
// The remainder of the MakeFunc implementation is in makefunc.go.
//
// NOTE: This function must be marked as a "wrapper" in the generated code,
// so that the linker can make it work correctly for panic and recover.
// The gc compilers know to do that for the name "reflect.callReflect".
//
// ctxt is the "closure" generated by MakeFunc.
// frame is a pointer to the arguments to that closure on the stack.
// retValid points to a boolean which should be set when the results
// section of frame is set.
func callReflect(ctxt *makeFuncImpl, frame unsafe.Pointer, retValid *bool) <span class="cov0" title="0">{
        ftyp := ctxt.ftyp
        f := ctxt.fn

        // Copy argument frame into Values.
        ptr := frame
        off := uintptr(0)
        in := make([]Value, 0, int(ftyp.inCount))
        for _, typ := range ftyp.in() </span><span class="cov0" title="0">{
                off += -off &amp; uintptr(typ.align-1)
                v := Value{typ, nil, flag(typ.Kind())}
                if ifaceIndir(typ) </span><span class="cov0" title="0">{
                        // value cannot be inlined in interface data.
                        // Must make a copy, because f might keep a reference to it,
                        // and we cannot let f keep a reference to the stack frame
                        // after this function returns, not even a read-only reference.
                        v.ptr = unsafe_New(typ)
                        if typ.size &gt; 0 </span><span class="cov0" title="0">{
                                typedmemmove(typ, v.ptr, add(ptr, off, "typ.size &gt; 0"))
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">v.flag |= flagIndir</span>
                }<span class="cov0" title="0"> else {
                        v.ptr = *(*unsafe.Pointer)(add(ptr, off, "1-ptr"))
                }</span>
                <span class="cov0" title="0">in = append(in, v)
                off += typ.size</span>
        }

        // Call underlying function.
        <span class="cov0" title="0">out := f(in)
        numOut := ftyp.NumOut()
        if len(out) != numOut </span><span class="cov0" title="0">{
                panic("reflect: wrong return count from function created by MakeFunc")</span>
        }<span class="cov0" title="0">
</span>
        // Copy results back into argument frame.
        <span class="cov0" title="0">if numOut &gt; 0 </span><span class="cov0" title="0">{
                off += -off &amp; (ptrSize - 1)
                for i, typ := range ftyp.out() </span><span class="cov0" title="0">{
                        v := out[i]
                        if v.typ == nil </span><span class="cov0" title="0">{
                                panic("reflect: function created by MakeFunc using " + funcName(f) +
                                        " returned zero Value")</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">if v.flag&amp;flagRO != 0 </span><span class="cov0" title="0">{
                                panic("reflect: function created by MakeFunc using " + funcName(f) +
                                        " returned value obtained from unexported field")</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">off += -off &amp; uintptr(typ.align-1)
                        if typ.size == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">addr := add(ptr, off, "typ.size &gt; 0")

                        // Convert v to type typ if v is assignable to a variable
                        // of type t in the language spec.
                        // See issue 28761.
                        if typ.Kind() == Interface </span><span class="cov0" title="0">{
                                // We must clear the destination before calling assignTo,
                                // in case assignTo writes (with memory barriers) to the
                                // target location used as scratch space. See issue 39541.
                                *(*uintptr)(addr) = 0
                                *(*uintptr)(add(addr, ptrSize, "typ.size == 2*ptrSize")) = 0
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">v = v.assignTo("reflect.MakeFunc", typ, addr)

                        // We are writing to stack. No write barrier.
                        if v.flag&amp;flagIndir != 0 </span><span class="cov0" title="0">{
                                memmove(addr, v.ptr, typ.size)
                        }</span><span class="cov0" title="0"> else {
                                *(*uintptr)(addr) = uintptr(v.ptr)
                        }</span>
                        <span class="cov0" title="0">off += typ.size</span>
                }
        }<span class="cov0" title="0">
</span>
        // Announce that the return values are valid.
        // After this point the runtime can depend on the return values being valid.
        <span class="cov0" title="0">*retValid = true

        // We have to make sure that the out slice lives at least until
        // the runtime knows the return values are valid. Otherwise, the
        // return values might not be scanned by anyone during a GC.
        // (out would be dead, and the return slots not yet alive.)
        runtime.KeepAlive(out)

        // runtime.getArgInfo expects to be able to find ctxt on the
        // stack when it finds our caller, makeFuncStub. Make sure it
        // doesn't get garbage collected.
        runtime.KeepAlive(ctxt)</span>
}

// methodReceiver returns information about the receiver
// described by v. The Value v may or may not have the
// flagMethod bit set, so the kind cached in v.flag should
// not be used.
// The return value rcvrtype gives the method's actual receiver type.
// The return value t gives the method type signature (without the receiver).
// The return value fn is a pointer to the method code.
func methodReceiver(op string, v Value, methodIndex int) (rcvrtype *rtype, t *funcType, fn unsafe.Pointer) <span class="cov0" title="0">{
        i := methodIndex
        if v.typ.Kind() == Interface </span><span class="cov0" title="0">{
                tt := (*interfaceType)(unsafe.Pointer(v.typ))
                if uint(i) &gt;= uint(len(tt.methods)) </span><span class="cov0" title="0">{
                        panic("reflect: internal error: invalid method index")</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">m := &amp;tt.methods[i]
                if !tt.nameOff(m.name).isExported() </span><span class="cov0" title="0">{
                        panic("reflect: " + op + " of unexported method")</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">iface := (*nonEmptyInterface)(v.ptr)
                if iface.itab == nil </span><span class="cov0" title="0">{
                        panic("reflect: " + op + " of method on nil interface value")</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">rcvrtype = iface.itab.typ
                fn = unsafe.Pointer(&amp;iface.itab.fun[i])
                t = (*funcType)(unsafe.Pointer(tt.typeOff(m.typ)))</span>
        }<span class="cov0" title="0"> else {
                rcvrtype = v.typ
                ms := v.typ.exportedMethods()
                if uint(i) &gt;= uint(len(ms)) </span><span class="cov0" title="0">{
                        panic("reflect: internal error: invalid method index")</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">m := ms[i]
                if !v.typ.nameOff(m.name).isExported() </span><span class="cov0" title="0">{
                        panic("reflect: " + op + " of unexported method")</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">ifn := v.typ.textOff(m.ifn)
                fn = unsafe.Pointer(&amp;ifn)
                t = (*funcType)(unsafe.Pointer(v.typ.typeOff(m.mtyp)))</span>
        }
        <span class="cov0" title="0">return</span>
}

// v is a method receiver. Store at p the word which is used to
// encode that receiver at the start of the argument list.
// Reflect uses the "interface" calling convention for
// methods, which always uses one word to record the receiver.
func storeRcvr(v Value, p unsafe.Pointer) <span class="cov0" title="0">{
        t := v.typ
        if t.Kind() == Interface </span><span class="cov0" title="0">{
                // the interface data word becomes the receiver word
                iface := (*nonEmptyInterface)(v.ptr)
                *(*unsafe.Pointer)(p) = iface.word
        }</span><span class="cov0" title="0"> else if v.flag&amp;flagIndir != 0 &amp;&amp; !ifaceIndir(t) </span><span class="cov0" title="0">{
                *(*unsafe.Pointer)(p) = *(*unsafe.Pointer)(v.ptr)
        }</span><span class="cov0" title="0"> else {
                *(*unsafe.Pointer)(p) = v.ptr
        }</span>
}

// align returns the result of rounding x up to a multiple of n.
// n must be a power of two.
func align(x, n uintptr) uintptr <span class="cov0" title="0">{
        return (x + n - 1) &amp;^ (n - 1)
}</span>

// callMethod is the call implementation used by a function returned
// by makeMethodValue (used by v.Method(i).Interface()).
// It is a streamlined version of the usual reflect call: the caller has
// already laid out the argument frame for us, so we don't have
// to deal with individual Values for each argument.
// It is in this file so that it can be next to the two similar functions above.
// The remainder of the makeMethodValue implementation is in makefunc.go.
//
// NOTE: This function must be marked as a "wrapper" in the generated code,
// so that the linker can make it work correctly for panic and recover.
// The gc compilers know to do that for the name "reflect.callMethod".
//
// ctxt is the "closure" generated by makeVethodValue.
// frame is a pointer to the arguments to that closure on the stack.
// retValid points to a boolean which should be set when the results
// section of frame is set.
func callMethod(ctxt *methodValue, frame unsafe.Pointer, retValid *bool) <span class="cov0" title="0">{
        rcvr := ctxt.rcvr
        rcvrtype, t, fn := methodReceiver("call", rcvr, ctxt.method)
        frametype, argSize, retOffset, _, framePool := funcLayout(t, rcvrtype)

        // Make a new frame that is one word bigger so we can store the receiver.
        // This space is used for both arguments and return values.
        scratch := framePool.Get().(unsafe.Pointer)

        // Copy in receiver and rest of args.
        storeRcvr(rcvr, scratch)
        // Align the first arg. The alignment can't be larger than ptrSize.
        argOffset := uintptr(ptrSize)
        if len(t.in()) &gt; 0 </span><span class="cov0" title="0">{
                argOffset = align(argOffset, uintptr(t.in()[0].align))
        }</span><span class="cov0" title="0">
</span>        // Avoid constructing out-of-bounds pointers if there are no args.
        <span class="cov0" title="0">if argSize-argOffset &gt; 0 </span><span class="cov0" title="0">{
                typedmemmovepartial(frametype, add(scratch, argOffset, "argSize &gt; argOffset"), frame, argOffset, argSize-argOffset)
        }</span><span class="cov0" title="0">
</span>
        // Call.
        // Call copies the arguments from scratch to the stack, calls fn,
        // and then copies the results back into scratch.
        <span class="cov0" title="0">call(frametype, fn, scratch, uint32(frametype.size), uint32(retOffset))

        // Copy return values.
        // Ignore any changes to args and just copy return values.
        // Avoid constructing out-of-bounds pointers if there are no return values.
        if frametype.size-retOffset &gt; 0 </span><span class="cov8" title="1">{
                callerRetOffset := retOffset - argOffset
                // This copies to the stack. Write barriers are not needed.
                memmove(add(frame, callerRetOffset, "frametype.size &gt; retOffset"),
                        add(scratch, retOffset, "frametype.size &gt; retOffset"),
                        frametype.size-retOffset)
        }</span><span class="cov0" title="0">
</span>
        // Tell the runtime it can now depend on the return values
        // being properly initialized.
        <span class="cov0" title="0">*retValid = true

        // Clear the scratch space and put it back in the pool.
        // This must happen after the statement above, so that the return
        // values will always be scanned by someone.
        typedmemclr(frametype, scratch)
        framePool.Put(scratch)

        // See the comment in callReflect.
        runtime.KeepAlive(ctxt)</span>
}

// funcName returns the name of f, for use in error messages.
func funcName(f func([]Value) []Value) string <span class="cov0" title="0">{
        pc := *(*uintptr)(unsafe.Pointer(&amp;f))
        rf := runtime.FuncForPC(pc)
        if rf != nil </span><span class="cov0" title="0">{
                return rf.Name()
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return "closure"</span>
}

// Cap returns v's capacity.
// It panics if v's Kind is not Array, Chan, or Slice.
func (v Value) Cap() int <span class="cov0" title="0">{
        k := v.kind()
        switch k </span>{
        <span class="cov0" title="0">case Array:
                return v.typ.Len()</span>
        <span class="cov0" title="0">case Chan:
                return chancap(v.pointer())</span>
        <span class="cov0" title="0">case Slice:
                // Slice is always bigger than a word; assume flagIndir.
                return (*unsafeheader.Slice)(v.ptr).Cap</span>
        }
        <span class="cov0" title="0">panic(&amp;ValueError{"reflect.Value.Cap", v.kind()})</span>
}

// Close closes the channel v.
// It panics if v's Kind is not Chan.
func (v Value) Close() <span class="cov0" title="0">{
        v.mustBe(Chan)
        v.mustBeExported()
        chanclose(v.pointer())
}</span>

// Complex returns v's underlying value, as a complex128.
// It panics if v's Kind is not Complex64 or Complex128
func (v Value) Complex() complex128 <span class="cov0" title="0">{
        k := v.kind()
        switch k </span>{
        <span class="cov0" title="0">case Complex64:
                return complex128(*(*complex64)(v.ptr))</span>
        <span class="cov0" title="0">case Complex128:
                return *(*complex128)(v.ptr)</span>
        }
        <span class="cov0" title="0">panic(&amp;ValueError{"reflect.Value.Complex", v.kind()})</span>
}

// Elem returns the value that the interface v contains
// or that the pointer v points to.
// It panics if v's Kind is not Interface or Ptr.
// It returns the zero Value if v is nil.
func (v Value) Elem() Value <span class="cov0" title="0">{
        k := v.kind()
        switch k </span>{
        <span class="cov0" title="0">case Interface:
                var eface interface{}
                if v.typ.NumMethod() == 0 </span><span class="cov0" title="0">{
                        eface = *(*interface{})(v.ptr)
                }</span><span class="cov0" title="0"> else {
                        eface = (interface{})(*(*interface {
                                M()
                        })(v.ptr))
                }</span>
                <span class="cov0" title="0">x := unpackEface(eface)
                if x.flag != 0 </span><span class="cov0" title="0">{
                        x.flag |= v.flag.ro()
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return x</span>
        <span class="cov0" title="0">case Ptr:
                ptr := v.ptr
                if v.flag&amp;flagIndir != 0 </span><span class="cov0" title="0">{
                        ptr = *(*unsafe.Pointer)(ptr)
                }</span><span class="cov0" title="0">
</span>                // The returned value's address is v's value.
                <span class="cov0" title="0">if ptr == nil </span><span class="cov0" title="0">{
                        return Value{}
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">tt := (*ptrType)(unsafe.Pointer(v.typ))
                typ := tt.elem
                fl := v.flag&amp;flagRO | flagIndir | flagAddr
                fl |= flag(typ.Kind())
                return Value{typ, ptr, fl}</span>
        }
        <span class="cov0" title="0">panic(&amp;ValueError{"reflect.Value.Elem", v.kind()})</span>
}

// Field returns the i'th field of the struct v.
// It panics if v's Kind is not Struct or i is out of range.
func (v Value) Field(i int) Value <span class="cov0" title="0">{
        if v.kind() != Struct </span><span class="cov0" title="0">{
                panic(&amp;ValueError{"reflect.Value.Field", v.kind()})</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">tt := (*structType)(unsafe.Pointer(v.typ))
        if uint(i) &gt;= uint(len(tt.fields)) </span><span class="cov0" title="0">{
                panic("reflect: Field index out of range")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">field := &amp;tt.fields[i]
        typ := field.typ

        // Inherit permission bits from v, but clear flagEmbedRO.
        fl := v.flag&amp;(flagStickyRO|flagIndir|flagAddr) | flag(typ.Kind())
        // Using an unexported field forces flagRO.
        if !field.name.isExported() </span><span class="cov0" title="0">{
                if field.embedded() </span><span class="cov0" title="0">{
                        fl |= flagEmbedRO
                }</span><span class="cov0" title="0"> else {
                        fl |= flagStickyRO
                }</span>
        }<span class="cov0" title="0">
</span>        // Either flagIndir is set and v.ptr points at struct,
        // or flagIndir is not set and v.ptr is the actual struct data.
        // In the former case, we want v.ptr + offset.
        // In the latter case, we must have field.offset = 0,
        // so v.ptr + field.offset is still the correct address.
        <span class="cov0" title="0">ptr := add(v.ptr, field.offset(), "same as non-reflect &amp;v.field")
        return Value{typ, ptr, fl}</span>
}

// FieldByIndex returns the nested field corresponding to index.
// It panics if v's Kind is not struct.
func (v Value) FieldByIndex(index []int) Value <span class="cov0" title="0">{
        if len(index) == 1 </span><span class="cov0" title="0">{
                return v.Field(index[0])
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">v.mustBe(Struct)
        for i, x := range index </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        if v.Kind() == Ptr &amp;&amp; v.typ.Elem().Kind() == Struct </span><span class="cov0" title="0">{
                                if v.IsNil() </span><span class="cov0" title="0">{
                                        panic("reflect: indirection through nil pointer to embedded struct")</span>
                                }<span class="cov0" title="0">
</span>                                <span class="cov0" title="0">v = v.Elem()</span>
                        }<span class="cov0" title="0">
</span>                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">v = v.Field(x)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// FieldByName returns the struct field with the given name.
// It returns the zero Value if no field was found.
// It panics if v's Kind is not struct.
func (v Value) FieldByName(name string) Value <span class="cov0" title="0">{
        v.mustBe(Struct)
        if f, ok := v.typ.FieldByName(name); ok </span><span class="cov0" title="0">{
                return v.FieldByIndex(f.Index)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return Value{}</span>
}

// FieldByNameFunc returns the struct field with a name
// that satisfies the match function.
// It panics if v's Kind is not struct.
// It returns the zero Value if no field was found.
func (v Value) FieldByNameFunc(match func(string) bool) Value <span class="cov0" title="0">{
        if f, ok := v.typ.FieldByNameFunc(match); ok </span><span class="cov0" title="0">{
                return v.FieldByIndex(f.Index)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return Value{}</span>
}

// Float returns v's underlying value, as a float64.
// It panics if v's Kind is not Float32 or Float64
func (v Value) Float() float64 <span class="cov0" title="0">{
        k := v.kind()
        switch k </span>{
        <span class="cov0" title="0">case Float32:
                return float64(*(*float32)(v.ptr))</span>
        <span class="cov0" title="0">case Float64:
                return *(*float64)(v.ptr)</span>
        }
        <span class="cov0" title="0">panic(&amp;ValueError{"reflect.Value.Float", v.kind()})</span>
}

var uint8Type = TypeOf(uint8(0)).(*rtype)

// Index returns v's i'th element.
// It panics if v's Kind is not Array, Slice, or String or i is out of range.
func (v Value) Index(i int) Value <span class="cov0" title="0">{
        switch v.kind() </span>{
        <span class="cov0" title="0">case Array:
                tt := (*arrayType)(unsafe.Pointer(v.typ))
                if uint(i) &gt;= uint(tt.len) </span><span class="cov0" title="0">{
                        panic("reflect: array index out of range")</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">typ := tt.elem
                offset := uintptr(i) * typ.size

                // Either flagIndir is set and v.ptr points at array,
                // or flagIndir is not set and v.ptr is the actual array data.
                // In the former case, we want v.ptr + offset.
                // In the latter case, we must be doing Index(0), so offset = 0,
                // so v.ptr + offset is still the correct address.
                val := add(v.ptr, offset, "same as &amp;v[i], i &lt; tt.len")
                fl := v.flag&amp;(flagIndir|flagAddr) | v.flag.ro() | flag(typ.Kind()) // bits same as overall array
                return Value{typ, val, fl}</span>

        <span class="cov0" title="0">case Slice:
                // Element flag same as Elem of Ptr.
                // Addressable, indirect, possibly read-only.
                s := (*unsafeheader.Slice)(v.ptr)
                if uint(i) &gt;= uint(s.Len) </span><span class="cov0" title="0">{
                        panic("reflect: slice index out of range")</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">tt := (*sliceType)(unsafe.Pointer(v.typ))
                typ := tt.elem
                val := arrayAt(s.Data, i, typ.size, "i &lt; s.Len")
                fl := flagAddr | flagIndir | v.flag.ro() | flag(typ.Kind())
                return Value{typ, val, fl}</span>

        <span class="cov0" title="0">case String:
                s := (*unsafeheader.String)(v.ptr)
                if uint(i) &gt;= uint(s.Len) </span><span class="cov0" title="0">{
                        panic("reflect: string index out of range")</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">p := arrayAt(s.Data, i, 1, "i &lt; s.Len")
                fl := v.flag.ro() | flag(Uint8) | flagIndir
                return Value{uint8Type, p, fl}</span>
        }
        <span class="cov0" title="0">panic(&amp;ValueError{"reflect.Value.Index", v.kind()})</span>
}

// Int returns v's underlying value, as an int64.
// It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.
func (v Value) Int() int64 <span class="cov0" title="0">{
        k := v.kind()
        p := v.ptr
        switch k </span>{
        <span class="cov0" title="0">case Int:
                return int64(*(*int)(p))</span>
        <span class="cov0" title="0">case Int8:
                return int64(*(*int8)(p))</span>
        <span class="cov0" title="0">case Int16:
                return int64(*(*int16)(p))</span>
        <span class="cov0" title="0">case Int32:
                return int64(*(*int32)(p))</span>
        <span class="cov0" title="0">case Int64:
                return *(*int64)(p)</span>
        }
        <span class="cov0" title="0">panic(&amp;ValueError{"reflect.Value.Int", v.kind()})</span>
}

// CanInterface reports whether Interface can be used without panicking.
func (v Value) CanInterface() bool <span class="cov0" title="0">{
        if v.flag == 0 </span><span class="cov0" title="0">{
                panic(&amp;ValueError{"reflect.Value.CanInterface", Invalid})</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">return v.flag&amp;flagRO == 0</span>
}

// Interface returns v's current value as an interface{}.
// It is equivalent to:
//        var i interface{} = (v's underlying value)
// It panics if the Value was obtained by accessing
// unexported struct fields.
func (v Value) Interface() (i interface{}) <span class="cov0" title="0">{
        return valueInterface(v, true)
}</span>

func valueInterface(v Value, safe bool) interface{} <span class="cov0" title="0">{
        if v.flag == 0 </span><span class="cov0" title="0">{
                panic(&amp;ValueError{"reflect.Value.Interface", Invalid})</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if safe &amp;&amp; v.flag&amp;flagRO != 0 </span><span class="cov0" title="0">{
                // Do not allow access to unexported values via Interface,
                // because they might be pointers that should not be
                // writable or methods or function that should not be callable.
                panic("reflect.Value.Interface: cannot return value obtained from unexported field or method")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if v.flag&amp;flagMethod != 0 </span><span class="cov0" title="0">{
                v = makeMethodValue("Interface", v)
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if v.kind() == Interface </span><span class="cov0" title="0">{
                // Special case: return the element inside the interface.
                // Empty interface has one layout, all interfaces with
                // methods have a second layout.
                if v.NumMethod() == 0 </span><span class="cov0" title="0">{
                        return *(*interface{})(v.ptr)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return *(*interface {
                        M()
                })(v.ptr)</span>
        }<span class="cov0" title="0">
</span>
        // TODO: pass safe to packEface so we don't need to copy if safe==true?
        <span class="cov0" title="0">return packEface(v)</span>
}

// InterfaceData returns the interface v's value as a uintptr pair.
// It panics if v's Kind is not Interface.
func (v Value) InterfaceData() [2]uintptr <span class="cov0" title="0">{
        // TODO: deprecate this
        v.mustBe(Interface)
        // We treat this as a read operation, so we allow
        // it even for unexported data, because the caller
        // has to import "unsafe" to turn it into something
        // that can be abused.
        // Interface value is always bigger than a word; assume flagIndir.
        return *(*[2]uintptr)(v.ptr)
}</span>

// IsNil reports whether its argument v is nil. The argument must be
// a chan, func, interface, map, pointer, or slice value; if it is
// not, IsNil panics. Note that IsNil is not always equivalent to a
// regular comparison with nil in Go. For example, if v was created
// by calling ValueOf with an uninitialized interface variable i,
// i==nil will be true but v.IsNil will panic as v will be the zero
// Value.
func (v Value) IsNil() bool <span class="cov0" title="0">{
        k := v.kind()
        switch k </span>{
        <span class="cov0" title="0">case Chan, Func, Map, Ptr, UnsafePointer:
                if v.flag&amp;flagMethod != 0 </span><span class="cov0" title="0">{
                        return false
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">ptr := v.ptr
                if v.flag&amp;flagIndir != 0 </span><span class="cov0" title="0">{
                        ptr = *(*unsafe.Pointer)(ptr)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return ptr == nil</span>
        <span class="cov0" title="0">case Interface, Slice:
                // Both interface and slice are nil if first word is 0.
                // Both are always bigger than a word; assume flagIndir.
                return *(*unsafe.Pointer)(v.ptr) == nil</span>
        }
        <span class="cov0" title="0">panic(&amp;ValueError{"reflect.Value.IsNil", v.kind()})</span>
}

// IsValid reports whether v represents a value.
// It returns false if v is the zero Value.
// If IsValid returns false, all other methods except String panic.
// Most functions and methods never return an invalid Value.
// If one does, its documentation states the conditions explicitly.
func (v Value) IsValid() bool <span class="cov0" title="0">{
        return v.flag != 0
}</span>

// IsZero reports whether v is the zero value for its type.
// It panics if the argument is invalid.
func (v Value) IsZero() bool <span class="cov0" title="0">{
        switch v.kind() </span>{
        <span class="cov0" title="0">case Bool:
                return !v.Bool()</span>
        <span class="cov0" title="0">case Int, Int8, Int16, Int32, Int64:
                return v.Int() == 0</span>
        <span class="cov0" title="0">case Uint, Uint8, Uint16, Uint32, Uint64, Uintptr:
                return v.Uint() == 0</span>
        <span class="cov0" title="0">case Float32, Float64:
                return math.Float64bits(v.Float()) == 0</span>
        <span class="cov0" title="0">case Complex64, Complex128:
                c := v.Complex()
                return math.Float64bits(real(c)) == 0 &amp;&amp; math.Float64bits(imag(c)) == 0</span>
        <span class="cov0" title="0">case Array:
                for i := 0; i &lt; v.Len(); i++ </span><span class="cov0" title="0">{
                        if !v.Index(i).IsZero() </span><span class="cov0" title="0">{
                                return false
                        }</span><span class="cov0" title="0">
</span>                }
                <span class="cov0" title="0">return true</span>
        <span class="cov0" title="0">case Chan, Func, Interface, Map, Ptr, Slice, UnsafePointer:
                return v.IsNil()</span>
        <span class="cov0" title="0">case String:
                return v.Len() == 0</span>
        <span class="cov0" title="0">case Struct:
                for i := 0; i &lt; v.NumField(); i++ </span><span class="cov0" title="0">{
                        if !v.Field(i).IsZero() </span><span class="cov0" title="0">{
                                return false
                        }</span><span class="cov0" title="0">
</span>                }
                <span class="cov0" title="0">return true</span>
        <span class="cov0" title="0">default:
                // This should never happens, but will act as a safeguard for
                // later, as a default value doesn't makes sense here.
                panic(&amp;ValueError{"reflect.Value.IsZero", v.Kind()})</span>
        }
}

// Kind returns v's Kind.
// If v is the zero Value (IsValid returns false), Kind returns Invalid.
func (v Value) Kind() Kind <span class="cov0" title="0">{
        return v.kind()
}</span>

// Len returns v's length.
// It panics if v's Kind is not Array, Chan, Map, Slice, or String.
func (v Value) Len() int <span class="cov0" title="0">{
        k := v.kind()
        switch k </span>{
        <span class="cov0" title="0">case Array:
                tt := (*arrayType)(unsafe.Pointer(v.typ))
                return int(tt.len)</span>
        <span class="cov0" title="0">case Chan:
                return chanlen(v.pointer())</span>
        <span class="cov0" title="0">case Map:
                return maplen(v.pointer())</span>
        <span class="cov0" title="0">case Slice:
                // Slice is bigger than a word; assume flagIndir.
                return (*unsafeheader.Slice)(v.ptr).Len</span>
        <span class="cov0" title="0">case String:
                // String is bigger than a word; assume flagIndir.
                return (*unsafeheader.String)(v.ptr).Len</span>
        }
        <span class="cov0" title="0">panic(&amp;ValueError{"reflect.Value.Len", v.kind()})</span>
}

// MapIndex returns the value associated with key in the map v.
// It panics if v's Kind is not Map.
// It returns the zero Value if key is not found in the map or if v represents a nil map.
// As in Go, the key's value must be assignable to the map's key type.
func (v Value) MapIndex(key Value) Value <span class="cov0" title="0">{
        v.mustBe(Map)
        tt := (*mapType)(unsafe.Pointer(v.typ))

        // Do not require key to be exported, so that DeepEqual
        // and other programs can use all the keys returned by
        // MapKeys as arguments to MapIndex. If either the map
        // or the key is unexported, though, the result will be
        // considered unexported. This is consistent with the
        // behavior for structs, which allow read but not write
        // of unexported fields.
        key = key.assignTo("reflect.Value.MapIndex", tt.key, nil)

        var k unsafe.Pointer
        if key.flag&amp;flagIndir != 0 </span><span class="cov0" title="0">{
                k = key.ptr
        }</span><span class="cov0" title="0"> else {
                k = unsafe.Pointer(&amp;key.ptr)
        }</span>
        <span class="cov0" title="0">e := mapaccess(v.typ, v.pointer(), k)
        if e == nil </span><span class="cov0" title="0">{
                return Value{}
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">typ := tt.elem
        fl := (v.flag | key.flag).ro()
        fl |= flag(typ.Kind())
        return copyVal(typ, fl, e)</span>
}

// MapKeys returns a slice containing all the keys present in the map,
// in unspecified order.
// It panics if v's Kind is not Map.
// It returns an empty slice if v represents a nil map.
func (v Value) MapKeys() []Value <span class="cov0" title="0">{
        v.mustBe(Map)
        tt := (*mapType)(unsafe.Pointer(v.typ))
        keyType := tt.key

        fl := v.flag.ro() | flag(keyType.Kind())

        m := v.pointer()
        mlen := int(0)
        if m != nil </span><span class="cov0" title="0">{
                mlen = maplen(m)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">it := mapiterinit(v.typ, m)
        a := make([]Value, mlen)
        var i int
        for i = 0; i &lt; len(a); i++ </span><span class="cov0" title="0">{
                key := mapiterkey(it)
                if key == nil </span><span class="cov0" title="0">{
                        // Someone deleted an entry from the map since we
                        // called maplen above. It's a data race, but nothing
                        // we can do about it.
                        break</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">a[i] = copyVal(keyType, fl, key)
                mapiternext(it)</span>
        }
        <span class="cov0" title="0">return a[:i]</span>
}

// A MapIter is an iterator for ranging over a map.
// See Value.MapRange.
type MapIter struct {
        m  Value
        it unsafe.Pointer
}

// Key returns the key of the iterator's current map entry.
func (it *MapIter) Key() Value <span class="cov0" title="0">{
        if it.it == nil </span><span class="cov0" title="0">{
                panic("MapIter.Key called before Next")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if mapiterkey(it.it) == nil </span><span class="cov0" title="0">{
                panic("MapIter.Key called on exhausted iterator")</span>
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">t := (*mapType)(unsafe.Pointer(it.m.typ))
        ktype := t.key
        return copyVal(ktype, it.m.flag.ro()|flag(ktype.Kind()), mapiterkey(it.it))</span>
}

// Value returns the value of the iterator's current map entry.
func (it *MapIter) Value() Value <span class="cov0" title="0">{
        if it.it == nil </span><span class="cov0" title="0">{
                panic("MapIter.Value called before Next")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if mapiterkey(it.it) == nil </span><span class="cov0" title="0">{
                panic("MapIter.Value called on exhausted iterator")</span>
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">t := (*mapType)(unsafe.Pointer(it.m.typ))
        vtype := t.elem
        return copyVal(vtype, it.m.flag.ro()|flag(vtype.Kind()), mapiterelem(it.it))</span>
}

// Next advances the map iterator and reports whether there is another
// entry. It returns false when the iterator is exhausted; subsequent
// calls to Key, Value, or Next will panic.
func (it *MapIter) Next() bool <span class="cov0" title="0">{
        if it.it == nil </span><span class="cov0" title="0">{
                it.it = mapiterinit(it.m.typ, it.m.pointer())
        }</span><span class="cov0" title="0"> else {
                if mapiterkey(it.it) == nil </span><span class="cov0" title="0">{
                        panic("MapIter.Next called on exhausted iterator")</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">mapiternext(it.it)</span>
        }
        <span class="cov0" title="0">return mapiterkey(it.it) != nil</span>
}

// MapRange returns a range iterator for a map.
// It panics if v's Kind is not Map.
//
// Call Next to advance the iterator, and Key/Value to access each entry.
// Next returns false when the iterator is exhausted.
// MapRange follows the same iteration semantics as a range statement.
//
// Example:
//
//        iter := reflect.ValueOf(m).MapRange()
//         for iter.Next() {
//                k := iter.Key()
//                v := iter.Value()
//                ...
//        }
//
func (v Value) MapRange() *MapIter <span class="cov0" title="0">{
        v.mustBe(Map)
        return &amp;MapIter{m: v}
}</span>

// copyVal returns a Value containing the map key or value at ptr,
// allocating a new variable as needed.
func copyVal(typ *rtype, fl flag, ptr unsafe.Pointer) Value <span class="cov0" title="0">{
        if ifaceIndir(typ) </span><span class="cov0" title="0">{
                // Copy result so future changes to the map
                // won't change the underlying value.
                c := unsafe_New(typ)
                typedmemmove(typ, c, ptr)
                return Value{typ, c, fl | flagIndir}
        }</span><span class="cov8" title="1">
</span>        <span class="cov0" title="0">return Value{typ, *(*unsafe.Pointer)(ptr), fl}</span>
}

// Method returns a function value corresponding to v's i'th method.
// The arguments to a Call on the returned function should not include
// a receiver; the returned function will always use v as the receiver.
// Method panics if i is out of range or if v is a nil interface value.
func (v Value) Method(i int) Value <span class="cov0" title="0">{
        if v.typ == nil </span><span class="cov0" title="0">{
                panic(&amp;ValueError{"reflect.Value.Method", Invalid})</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if v.flag&amp;flagMethod != 0 || uint(i) &gt;= uint(v.typ.NumMethod()) </span><span class="cov0" title="0">{
                panic("reflect: Method index out of range")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if v.typ.Kind() == Interface &amp;&amp; v.IsNil() </span><span class="cov0" title="0">{
                panic("reflect: Method on nil interface value")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">fl := v.flag.ro() | (v.flag &amp; flagIndir)
        fl |= flag(Func)
        fl |= flag(i)&lt;&lt;flagMethodShift | flagMethod
        return Value{v.typ, v.ptr, fl}</span>
}

// NumMethod returns the number of exported methods in the value's method set.
func (v Value) NumMethod() int <span class="cov0" title="0">{
        if v.typ == nil </span><span class="cov0" title="0">{
                panic(&amp;ValueError{"reflect.Value.NumMethod", Invalid})</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if v.flag&amp;flagMethod != 0 </span><span class="cov0" title="0">{
                return 0
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return v.typ.NumMethod()</span>
}

// MethodByName returns a function value corresponding to the method
// of v with the given name.
// The arguments to a Call on the returned function should not include
// a receiver; the returned function will always use v as the receiver.
// It returns the zero Value if no method was found.
func (v Value) MethodByName(name string) Value <span class="cov0" title="0">{
        if v.typ == nil </span><span class="cov0" title="0">{
                panic(&amp;ValueError{"reflect.Value.MethodByName", Invalid})</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if v.flag&amp;flagMethod != 0 </span><span class="cov0" title="0">{
                return Value{}
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">m, ok := v.typ.MethodByName(name)
        if !ok </span><span class="cov0" title="0">{
                return Value{}
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return v.Method(m.Index)</span>
}

// NumField returns the number of fields in the struct v.
// It panics if v's Kind is not Struct.
func (v Value) NumField() int <span class="cov0" title="0">{
        v.mustBe(Struct)
        tt := (*structType)(unsafe.Pointer(v.typ))
        return len(tt.fields)
}</span>

// OverflowComplex reports whether the complex128 x cannot be represented by v's type.
// It panics if v's Kind is not Complex64 or Complex128.
func (v Value) OverflowComplex(x complex128) bool <span class="cov0" title="0">{
        k := v.kind()
        switch k </span>{
        <span class="cov0" title="0">case Complex64:
                return overflowFloat32(real(x)) || overflowFloat32(imag(x))</span>
        <span class="cov0" title="0">case Complex128:
                return false</span>
        }
        <span class="cov0" title="0">panic(&amp;ValueError{"reflect.Value.OverflowComplex", v.kind()})</span>
}

// OverflowFloat reports whether the float64 x cannot be represented by v's type.
// It panics if v's Kind is not Float32 or Float64.
func (v Value) OverflowFloat(x float64) bool <span class="cov0" title="0">{
        k := v.kind()
        switch k </span>{
        <span class="cov0" title="0">case Float32:
                return overflowFloat32(x)</span>
        <span class="cov0" title="0">case Float64:
                return false</span>
        }
        <span class="cov0" title="0">panic(&amp;ValueError{"reflect.Value.OverflowFloat", v.kind()})</span>
}

func overflowFloat32(x float64) bool <span class="cov0" title="0">{
        if x &lt; 0 </span><span class="cov0" title="0">{
                x = -x
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return math.MaxFloat32 &lt; x &amp;&amp; x &lt;= math.MaxFloat64</span>
}

// OverflowInt reports whether the int64 x cannot be represented by v's type.
// It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.
func (v Value) OverflowInt(x int64) bool <span class="cov0" title="0">{
        k := v.kind()
        switch k </span>{
        <span class="cov0" title="0">case Int, Int8, Int16, Int32, Int64:
                bitSize := v.typ.size * 8
                trunc := (x &lt;&lt; (64 - bitSize)) &gt;&gt; (64 - bitSize)
                return x != trunc</span>
        }
        <span class="cov0" title="0">panic(&amp;ValueError{"reflect.Value.OverflowInt", v.kind()})</span>
}

// OverflowUint reports whether the uint64 x cannot be represented by v's type.
// It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.
func (v Value) OverflowUint(x uint64) bool <span class="cov0" title="0">{
        k := v.kind()
        switch k </span>{
        <span class="cov0" title="0">case Uint, Uintptr, Uint8, Uint16, Uint32, Uint64:
                bitSize := v.typ.size * 8
                trunc := (x &lt;&lt; (64 - bitSize)) &gt;&gt; (64 - bitSize)
                return x != trunc</span>
        }
        <span class="cov0" title="0">panic(&amp;ValueError{"reflect.Value.OverflowUint", v.kind()})</span>
}

//go:nocheckptr
// This prevents inlining Value.Pointer when -d=checkptr is enabled,
// which ensures cmd/compile can recognize unsafe.Pointer(v.Pointer())
// and make an exception.

// Pointer returns v's value as a uintptr.
// It returns uintptr instead of unsafe.Pointer so that
// code using reflect cannot obtain unsafe.Pointers
// without importing the unsafe package explicitly.
// It panics if v's Kind is not Chan, Func, Map, Ptr, Slice, or UnsafePointer.
//
// If v's Kind is Func, the returned pointer is an underlying
// code pointer, but not necessarily enough to identify a
// single function uniquely. The only guarantee is that the
// result is zero if and only if v is a nil func Value.
//
// If v's Kind is Slice, the returned pointer is to the first
// element of the slice. If the slice is nil the returned value
// is 0.  If the slice is empty but non-nil the return value is non-zero.
func (v Value) Pointer() uintptr <span class="cov0" title="0">{
        // TODO: deprecate
        k := v.kind()
        switch k </span>{
        <span class="cov0" title="0">case Chan, Map, Ptr, UnsafePointer:
                return uintptr(v.pointer())</span>
        <span class="cov0" title="0">case Func:
                if v.flag&amp;flagMethod != 0 </span><span class="cov0" title="0">{
                        // As the doc comment says, the returned pointer is an
                        // underlying code pointer but not necessarily enough to
                        // identify a single function uniquely. All method expressions
                        // created via reflect have the same underlying code pointer,
                        // so their Pointers are equal. The function used here must
                        // match the one used in makeMethodValue.
                        f := methodValueCall
                        return **(**uintptr)(unsafe.Pointer(&amp;f))
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">p := v.pointer()
                // Non-nil func value points at data block.
                // First word of data block is actual code.
                if p != nil </span><span class="cov0" title="0">{
                        p = *(*unsafe.Pointer)(p)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return uintptr(p)</span>

        <span class="cov0" title="0">case Slice:
                return (*SliceHeader)(v.ptr).Data</span>
        }
        <span class="cov0" title="0">panic(&amp;ValueError{"reflect.Value.Pointer", v.kind()})</span>
}

// Recv receives and returns a value from the channel v.
// It panics if v's Kind is not Chan.
// The receive blocks until a value is ready.
// The boolean value ok is true if the value x corresponds to a send
// on the channel, false if it is a zero value received because the channel is closed.
func (v Value) Recv() (x Value, ok bool) <span class="cov0" title="0">{
        v.mustBe(Chan)
        v.mustBeExported()
        return v.recv(false)
}</span>

// internal recv, possibly non-blocking (nb).
// v is known to be a channel.
func (v Value) recv(nb bool) (val Value, ok bool) <span class="cov0" title="0">{
        tt := (*chanType)(unsafe.Pointer(v.typ))
        if ChanDir(tt.dir)&amp;RecvDir == 0 </span><span class="cov0" title="0">{
                panic("reflect: recv on send-only channel")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">t := tt.elem
        val = Value{t, nil, flag(t.Kind())}
        var p unsafe.Pointer
        if ifaceIndir(t) </span><span class="cov0" title="0">{
                p = unsafe_New(t)
                val.ptr = p
                val.flag |= flagIndir
        }</span><span class="cov0" title="0"> else {
                p = unsafe.Pointer(&amp;val.ptr)
        }</span>
        <span class="cov0" title="0">selected, ok := chanrecv(v.pointer(), nb, p)
        if !selected </span><span class="cov0" title="0">{
                val = Value{}
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return</span>
}

// Send sends x on the channel v.
// It panics if v's kind is not Chan or if x's type is not the same type as v's element type.
// As in Go, x's value must be assignable to the channel's element type.
func (v Value) Send(x Value) <span class="cov0" title="0">{
        v.mustBe(Chan)
        v.mustBeExported()
        v.send(x, false)
}</span>

// internal send, possibly non-blocking.
// v is known to be a channel.
func (v Value) send(x Value, nb bool) (selected bool) <span class="cov0" title="0">{
        tt := (*chanType)(unsafe.Pointer(v.typ))
        if ChanDir(tt.dir)&amp;SendDir == 0 </span><span class="cov0" title="0">{
                panic("reflect: send on recv-only channel")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">x.mustBeExported()
        x = x.assignTo("reflect.Value.Send", tt.elem, nil)
        var p unsafe.Pointer
        if x.flag&amp;flagIndir != 0 </span><span class="cov0" title="0">{
                p = x.ptr
        }</span><span class="cov0" title="0"> else {
                p = unsafe.Pointer(&amp;x.ptr)
        }</span>
        <span class="cov0" title="0">return chansend(v.pointer(), p, nb)</span>
}

// Set assigns x to the value v.
// It panics if CanSet returns false.
// As in Go, x's value must be assignable to v's type.
func (v Value) Set(x Value) <span class="cov0" title="0">{
        v.mustBeAssignable()
        x.mustBeExported() // do not let unexported x leak
        var target unsafe.Pointer
        if v.kind() == Interface </span><span class="cov0" title="0">{
                target = v.ptr
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">x = x.assignTo("reflect.Set", v.typ, target)
        if x.flag&amp;flagIndir != 0 </span><span class="cov0" title="0">{
                typedmemmove(v.typ, v.ptr, x.ptr)
        }</span><span class="cov0" title="0"> else {
                *(*unsafe.Pointer)(v.ptr) = x.ptr
        }</span>
}

// SetBool sets v's underlying value.
// It panics if v's Kind is not Bool or if CanSet() is false.
func (v Value) SetBool(x bool) <span class="cov0" title="0">{
        v.mustBeAssignable()
        v.mustBe(Bool)
        *(*bool)(v.ptr) = x
}</span>

// SetBytes sets v's underlying value.
// It panics if v's underlying value is not a slice of bytes.
func (v Value) SetBytes(x []byte) <span class="cov0" title="0">{
        v.mustBeAssignable()
        v.mustBe(Slice)
        if v.typ.Elem().Kind() != Uint8 </span><span class="cov0" title="0">{
                panic("reflect.Value.SetBytes of non-byte slice")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">*(*[]byte)(v.ptr) = x</span>
}

// setRunes sets v's underlying value.
// It panics if v's underlying value is not a slice of runes (int32s).
func (v Value) setRunes(x []rune) <span class="cov0" title="0">{
        v.mustBeAssignable()
        v.mustBe(Slice)
        if v.typ.Elem().Kind() != Int32 </span><span class="cov0" title="0">{
                panic("reflect.Value.setRunes of non-rune slice")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">*(*[]rune)(v.ptr) = x</span>
}

// SetComplex sets v's underlying value to x.
// It panics if v's Kind is not Complex64 or Complex128, or if CanSet() is false.
func (v Value) SetComplex(x complex128) <span class="cov0" title="0">{
        v.mustBeAssignable()
        switch k := v.kind(); k </span>{
        <span class="cov0" title="0">default:
                panic(&amp;ValueError{"reflect.Value.SetComplex", v.kind()})</span>
        <span class="cov0" title="0">case Complex64:
                *(*complex64)(v.ptr) = complex64(x)</span>
        <span class="cov0" title="0">case Complex128:
                *(*complex128)(v.ptr) = x</span>
        }
}

// SetFloat sets v's underlying value to x.
// It panics if v's Kind is not Float32 or Float64, or if CanSet() is false.
func (v Value) SetFloat(x float64) <span class="cov0" title="0">{
        v.mustBeAssignable()
        switch k := v.kind(); k </span>{
        <span class="cov0" title="0">default:
                panic(&amp;ValueError{"reflect.Value.SetFloat", v.kind()})</span>
        <span class="cov0" title="0">case Float32:
                *(*float32)(v.ptr) = float32(x)</span>
        <span class="cov0" title="0">case Float64:
                *(*float64)(v.ptr) = x</span>
        }
}

// SetInt sets v's underlying value to x.
// It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64, or if CanSet() is false.
func (v Value) SetInt(x int64) <span class="cov0" title="0">{
        v.mustBeAssignable()
        switch k := v.kind(); k </span>{
        <span class="cov0" title="0">default:
                panic(&amp;ValueError{"reflect.Value.SetInt", v.kind()})</span>
        <span class="cov0" title="0">case Int:
                *(*int)(v.ptr) = int(x)</span>
        <span class="cov0" title="0">case Int8:
                *(*int8)(v.ptr) = int8(x)</span>
        <span class="cov0" title="0">case Int16:
                *(*int16)(v.ptr) = int16(x)</span>
        <span class="cov0" title="0">case Int32:
                *(*int32)(v.ptr) = int32(x)</span>
        <span class="cov0" title="0">case Int64:
                *(*int64)(v.ptr) = x</span>
        }
}

// SetLen sets v's length to n.
// It panics if v's Kind is not Slice or if n is negative or
// greater than the capacity of the slice.
func (v Value) SetLen(n int) <span class="cov0" title="0">{
        v.mustBeAssignable()
        v.mustBe(Slice)
        s := (*unsafeheader.Slice)(v.ptr)
        if uint(n) &gt; uint(s.Cap) </span><span class="cov0" title="0">{
                panic("reflect: slice length out of range in SetLen")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">s.Len = n</span>
}

// SetCap sets v's capacity to n.
// It panics if v's Kind is not Slice or if n is smaller than the length or
// greater than the capacity of the slice.
func (v Value) SetCap(n int) <span class="cov0" title="0">{
        v.mustBeAssignable()
        v.mustBe(Slice)
        s := (*unsafeheader.Slice)(v.ptr)
        if n &lt; s.Len || n &gt; s.Cap </span><span class="cov0" title="0">{
                panic("reflect: slice capacity out of range in SetCap")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">s.Cap = n</span>
}

// SetMapIndex sets the element associated with key in the map v to elem.
// It panics if v's Kind is not Map.
// If elem is the zero Value, SetMapIndex deletes the key from the map.
// Otherwise if v holds a nil map, SetMapIndex will panic.
// As in Go, key's elem must be assignable to the map's key type,
// and elem's value must be assignable to the map's elem type.
func (v Value) SetMapIndex(key, elem Value) <span class="cov0" title="0">{
        v.mustBe(Map)
        v.mustBeExported()
        key.mustBeExported()
        tt := (*mapType)(unsafe.Pointer(v.typ))
        key = key.assignTo("reflect.Value.SetMapIndex", tt.key, nil)
        var k unsafe.Pointer
        if key.flag&amp;flagIndir != 0 </span><span class="cov0" title="0">{
                k = key.ptr
        }</span><span class="cov0" title="0"> else {
                k = unsafe.Pointer(&amp;key.ptr)
        }</span>
        <span class="cov0" title="0">if elem.typ == nil </span><span class="cov0" title="0">{
                mapdelete(v.typ, v.pointer(), k)
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">elem.mustBeExported()
        elem = elem.assignTo("reflect.Value.SetMapIndex", tt.elem, nil)
        var e unsafe.Pointer
        if elem.flag&amp;flagIndir != 0 </span><span class="cov0" title="0">{
                e = elem.ptr
        }</span><span class="cov0" title="0"> else {
                e = unsafe.Pointer(&amp;elem.ptr)
        }</span>
        <span class="cov0" title="0">mapassign(v.typ, v.pointer(), k, e)</span>
}

// SetUint sets v's underlying value to x.
// It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64, or if CanSet() is false.
func (v Value) SetUint(x uint64) <span class="cov0" title="0">{
        v.mustBeAssignable()
        switch k := v.kind(); k </span>{
        <span class="cov0" title="0">default:
                panic(&amp;ValueError{"reflect.Value.SetUint", v.kind()})</span>
        <span class="cov0" title="0">case Uint:
                *(*uint)(v.ptr) = uint(x)</span>
        <span class="cov0" title="0">case Uint8:
                *(*uint8)(v.ptr) = uint8(x)</span>
        <span class="cov0" title="0">case Uint16:
                *(*uint16)(v.ptr) = uint16(x)</span>
        <span class="cov0" title="0">case Uint32:
                *(*uint32)(v.ptr) = uint32(x)</span>
        <span class="cov0" title="0">case Uint64:
                *(*uint64)(v.ptr) = x</span>
        <span class="cov0" title="0">case Uintptr:
                *(*uintptr)(v.ptr) = uintptr(x)</span>
        }
}

// SetPointer sets the unsafe.Pointer value v to x.
// It panics if v's Kind is not UnsafePointer.
func (v Value) SetPointer(x unsafe.Pointer) <span class="cov0" title="0">{
        v.mustBeAssignable()
        v.mustBe(UnsafePointer)
        *(*unsafe.Pointer)(v.ptr) = x
}</span>

// SetString sets v's underlying value to x.
// It panics if v's Kind is not String or if CanSet() is false.
func (v Value) SetString(x string) <span class="cov0" title="0">{
        v.mustBeAssignable()
        v.mustBe(String)
        *(*string)(v.ptr) = x
}</span>

// Slice returns v[i:j].
// It panics if v's Kind is not Array, Slice or String, or if v is an unaddressable array,
// or if the indexes are out of bounds.
func (v Value) Slice(i, j int) Value <span class="cov0" title="0">{
        var (
                cap  int
                typ  *sliceType
                base unsafe.Pointer
        )
        switch kind := v.kind(); kind </span>{
        <span class="cov0" title="0">default:
                panic(&amp;ValueError{"reflect.Value.Slice", v.kind()})</span>

        <span class="cov0" title="0">case Array:
                if v.flag&amp;flagAddr == 0 </span><span class="cov0" title="0">{
                        panic("reflect.Value.Slice: slice of unaddressable array")</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">tt := (*arrayType)(unsafe.Pointer(v.typ))
                cap = int(tt.len)
                typ = (*sliceType)(unsafe.Pointer(tt.slice))
                base = v.ptr</span>

        <span class="cov0" title="0">case Slice:
                typ = (*sliceType)(unsafe.Pointer(v.typ))
                s := (*unsafeheader.Slice)(v.ptr)
                base = s.Data
                cap = s.Cap</span>

        <span class="cov0" title="0">case String:
                s := (*unsafeheader.String)(v.ptr)
                if i &lt; 0 || j &lt; i || j &gt; s.Len </span><span class="cov0" title="0">{
                        panic("reflect.Value.Slice: string slice index out of bounds")</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">var t unsafeheader.String
                if i &lt; s.Len </span><span class="cov0" title="0">{
                        t = unsafeheader.String{Data: arrayAt(s.Data, i, 1, "i &lt; s.Len"), Len: j - i}
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return Value{v.typ, unsafe.Pointer(&amp;t), v.flag}</span>
        }

        <span class="cov0" title="0">if i &lt; 0 || j &lt; i || j &gt; cap </span><span class="cov0" title="0">{
                panic("reflect.Value.Slice: slice index out of bounds")</span>
        }<span class="cov0" title="0">
</span>
        // Declare slice so that gc can see the base pointer in it.
        <span class="cov0" title="0">var x []unsafe.Pointer

        // Reinterpret as *unsafeheader.Slice to edit.
        s := (*unsafeheader.Slice)(unsafe.Pointer(&amp;x))
        s.Len = j - i
        s.Cap = cap - i
        if cap-i &gt; 0 </span><span class="cov0" title="0">{
                s.Data = arrayAt(base, i, typ.elem.Size(), "i &lt; cap")
        }</span><span class="cov0" title="0"> else {
                // do not advance pointer, to avoid pointing beyond end of slice
                s.Data = base
        }</span>

        <span class="cov0" title="0">fl := v.flag.ro() | flagIndir | flag(Slice)
        return Value{typ.common(), unsafe.Pointer(&amp;x), fl}</span>
}

// Slice3 is the 3-index form of the slice operation: it returns v[i:j:k].
// It panics if v's Kind is not Array or Slice, or if v is an unaddressable array,
// or if the indexes are out of bounds.
func (v Value) Slice3(i, j, k int) Value <span class="cov0" title="0">{
        var (
                cap  int
                typ  *sliceType
                base unsafe.Pointer
        )
        switch kind := v.kind(); kind </span>{
        <span class="cov0" title="0">default:
                panic(&amp;ValueError{"reflect.Value.Slice3", v.kind()})</span>

        <span class="cov0" title="0">case Array:
                if v.flag&amp;flagAddr == 0 </span><span class="cov0" title="0">{
                        panic("reflect.Value.Slice3: slice of unaddressable array")</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">tt := (*arrayType)(unsafe.Pointer(v.typ))
                cap = int(tt.len)
                typ = (*sliceType)(unsafe.Pointer(tt.slice))
                base = v.ptr</span>

        <span class="cov0" title="0">case Slice:
                typ = (*sliceType)(unsafe.Pointer(v.typ))
                s := (*unsafeheader.Slice)(v.ptr)
                base = s.Data
                cap = s.Cap</span>
        }

        <span class="cov0" title="0">if i &lt; 0 || j &lt; i || k &lt; j || k &gt; cap </span><span class="cov0" title="0">{
                panic("reflect.Value.Slice3: slice index out of bounds")</span>
        }<span class="cov0" title="0">
</span>
        // Declare slice so that the garbage collector
        // can see the base pointer in it.
        <span class="cov0" title="0">var x []unsafe.Pointer

        // Reinterpret as *unsafeheader.Slice to edit.
        s := (*unsafeheader.Slice)(unsafe.Pointer(&amp;x))
        s.Len = j - i
        s.Cap = k - i
        if k-i &gt; 0 </span><span class="cov0" title="0">{
                s.Data = arrayAt(base, i, typ.elem.Size(), "i &lt; k &lt;= cap")
        }</span><span class="cov0" title="0"> else {
                // do not advance pointer, to avoid pointing beyond end of slice
                s.Data = base
        }</span>

        <span class="cov0" title="0">fl := v.flag.ro() | flagIndir | flag(Slice)
        return Value{typ.common(), unsafe.Pointer(&amp;x), fl}</span>
}

// String returns the string v's underlying value, as a string.
// String is a special case because of Go's String method convention.
// Unlike the other getters, it does not panic if v's Kind is not String.
// Instead, it returns a string of the form "&lt;T value&gt;" where T is v's type.
// The fmt package treats Values specially. It does not call their String
// method implicitly but instead prints the concrete values they hold.
func (v Value) String() string <span class="cov0" title="0">{
        switch k := v.kind(); k </span>{
        <span class="cov0" title="0">case Invalid:
                return "&lt;invalid Value&gt;"</span>
        <span class="cov0" title="0">case String:
                return *(*string)(v.ptr)</span>
        }
        // If you call String on a reflect.Value of other type, it's better to
        // print something than to panic. Useful in debugging.
        <span class="cov0" title="0">return "&lt;" + v.Type().String() + " Value&gt;"</span>
}

// TryRecv attempts to receive a value from the channel v but will not block.
// It panics if v's Kind is not Chan.
// If the receive delivers a value, x is the transferred value and ok is true.
// If the receive cannot finish without blocking, x is the zero Value and ok is false.
// If the channel is closed, x is the zero value for the channel's element type and ok is false.
func (v Value) TryRecv() (x Value, ok bool) <span class="cov0" title="0">{
        v.mustBe(Chan)
        v.mustBeExported()
        return v.recv(true)
}</span>

// TrySend attempts to send x on the channel v but will not block.
// It panics if v's Kind is not Chan.
// It reports whether the value was sent.
// As in Go, x's value must be assignable to the channel's element type.
func (v Value) TrySend(x Value) bool <span class="cov0" title="0">{
        v.mustBe(Chan)
        v.mustBeExported()
        return v.send(x, true)
}</span>

// Type returns v's type.
func (v Value) Type() Type <span class="cov0" title="0">{
        f := v.flag
        if f == 0 </span><span class="cov0" title="0">{
                panic(&amp;ValueError{"reflect.Value.Type", Invalid})</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if f&amp;flagMethod == 0 </span><span class="cov0" title="0">{
                // Easy case
                return v.typ
        }</span><span class="cov0" title="0">
</span>
        // Method value.
        // v.typ describes the receiver, not the method type.
        <span class="cov0" title="0">i := int(v.flag) &gt;&gt; flagMethodShift
        if v.typ.Kind() == Interface </span><span class="cov0" title="0">{
                // Method on interface.
                tt := (*interfaceType)(unsafe.Pointer(v.typ))
                if uint(i) &gt;= uint(len(tt.methods)) </span><span class="cov0" title="0">{
                        panic("reflect: internal error: invalid method index")</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">m := &amp;tt.methods[i]
                return v.typ.typeOff(m.typ)</span>
        }<span class="cov0" title="0">
</span>        // Method on concrete type.
        <span class="cov0" title="0">ms := v.typ.exportedMethods()
        if uint(i) &gt;= uint(len(ms)) </span><span class="cov0" title="0">{
                panic("reflect: internal error: invalid method index")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">m := ms[i]
        return v.typ.typeOff(m.mtyp)</span>
}

// Uint returns v's underlying value, as a uint64.
// It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.
func (v Value) Uint() uint64 <span class="cov0" title="0">{
        k := v.kind()
        p := v.ptr
        switch k </span>{
        <span class="cov0" title="0">case Uint:
                return uint64(*(*uint)(p))</span>
        <span class="cov0" title="0">case Uint8:
                return uint64(*(*uint8)(p))</span>
        <span class="cov0" title="0">case Uint16:
                return uint64(*(*uint16)(p))</span>
        <span class="cov0" title="0">case Uint32:
                return uint64(*(*uint32)(p))</span>
        <span class="cov0" title="0">case Uint64:
                return *(*uint64)(p)</span>
        <span class="cov0" title="0">case Uintptr:
                return uint64(*(*uintptr)(p))</span>
        }
        <span class="cov0" title="0">panic(&amp;ValueError{"reflect.Value.Uint", v.kind()})</span>
}

//go:nocheckptr
// This prevents inlining Value.UnsafeAddr when -d=checkptr is enabled,
// which ensures cmd/compile can recognize unsafe.Pointer(v.UnsafeAddr())
// and make an exception.

// UnsafeAddr returns a pointer to v's data.
// It is for advanced clients that also import the "unsafe" package.
// It panics if v is not addressable.
func (v Value) UnsafeAddr() uintptr <span class="cov0" title="0">{
        // TODO: deprecate
        if v.typ == nil </span><span class="cov0" title="0">{
                panic(&amp;ValueError{"reflect.Value.UnsafeAddr", Invalid})</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if v.flag&amp;flagAddr == 0 </span><span class="cov0" title="0">{
                panic("reflect.Value.UnsafeAddr of unaddressable value")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">return uintptr(v.ptr)</span>
}

// StringHeader is the runtime representation of a string.
// It cannot be used safely or portably and its representation may
// change in a later release.
// Moreover, the Data field is not sufficient to guarantee the data
// it references will not be garbage collected, so programs must keep
// a separate, correctly typed pointer to the underlying data.
type StringHeader struct {
        Data uintptr
        Len  int
}

// SliceHeader is the runtime representation of a slice.
// It cannot be used safely or portably and its representation may
// change in a later release.
// Moreover, the Data field is not sufficient to guarantee the data
// it references will not be garbage collected, so programs must keep
// a separate, correctly typed pointer to the underlying data.
type SliceHeader struct {
        Data uintptr
        Len  int
        Cap  int
}

func typesMustMatch(what string, t1, t2 Type) <span class="cov0" title="0">{
        if t1 != t2 </span><span class="cov0" title="0">{
                panic(what + ": " + t1.String() + " != " + t2.String())</span>
        }<span class="cov0" title="0">
</span>}

// arrayAt returns the i-th element of p,
// an array whose elements are eltSize bytes wide.
// The array pointed at by p must have at least i+1 elements:
// it is invalid (but impossible to check here) to pass i &gt;= len,
// because then the result will point outside the array.
// whySafe must explain why i &lt; len. (Passing "i &lt; len" is fine;
// the benefit is to surface this assumption at the call site.)
func arrayAt(p unsafe.Pointer, i int, eltSize uintptr, whySafe string) unsafe.Pointer <span class="cov0" title="0">{
        return add(p, uintptr(i)*eltSize, "i &lt; len")
}</span>

// grow grows the slice s so that it can hold extra more values, allocating
// more capacity if needed. It also returns the old and new slice lengths.
func grow(s Value, extra int) (Value, int, int) <span class="cov0" title="0">{
        i0 := s.Len()
        i1 := i0 + extra
        if i1 &lt; i0 </span><span class="cov0" title="0">{
                panic("reflect.Append: slice overflow")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">m := s.Cap()
        if i1 &lt;= m </span><span class="cov0" title="0">{
                return s.Slice(0, i1), i0, i1
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if m == 0 </span><span class="cov0" title="0">{
                m = extra
        }</span><span class="cov0" title="0"> else {
                for m &lt; i1 </span><span class="cov0" title="0">{
                        if i0 &lt; 1024 </span><span class="cov0" title="0">{
                                m += m
                        }</span><span class="cov0" title="0"> else {
                                m += m / 4
                        }</span>
                }
        }
        <span class="cov0" title="0">t := MakeSlice(s.Type(), i1, m)
        Copy(t, s)
        return t, i0, i1</span>
}

// Append appends the values x to a slice s and returns the resulting slice.
// As in Go, each x's value must be assignable to the slice's element type.
func Append(s Value, x ...Value) Value <span class="cov0" title="0">{
        s.mustBe(Slice)
        s, i0, i1 := grow(s, len(x))
        for i, j := i0, 0; i &lt; i1; i, j = i+1, j+1 </span><span class="cov0" title="0">{
                s.Index(i).Set(x[j])
        }</span>
        <span class="cov0" title="0">return s</span>
}

// AppendSlice appends a slice t to a slice s and returns the resulting slice.
// The slices s and t must have the same element type.
func AppendSlice(s, t Value) Value <span class="cov0" title="0">{
        s.mustBe(Slice)
        t.mustBe(Slice)
        typesMustMatch("reflect.AppendSlice", s.Type().Elem(), t.Type().Elem())
        s, i0, i1 := grow(s, t.Len())
        Copy(s.Slice(i0, i1), t)
        return s
}</span>

// Copy copies the contents of src into dst until either
// dst has been filled or src has been exhausted.
// It returns the number of elements copied.
// Dst and src each must have kind Slice or Array, and
// dst and src must have the same element type.
//
// As a special case, src can have kind String if the element type of dst is kind Uint8.
func Copy(dst, src Value) int <span class="cov0" title="0">{
        dk := dst.kind()
        if dk != Array &amp;&amp; dk != Slice </span><span class="cov0" title="0">{
                panic(&amp;ValueError{"reflect.Copy", dk})</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if dk == Array </span><span class="cov0" title="0">{
                dst.mustBeAssignable()
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">dst.mustBeExported()

        sk := src.kind()
        var stringCopy bool
        if sk != Array &amp;&amp; sk != Slice </span><span class="cov0" title="0">{
                stringCopy = sk == String &amp;&amp; dst.typ.Elem().Kind() == Uint8
                if !stringCopy </span><span class="cov0" title="0">{
                        panic(&amp;ValueError{"reflect.Copy", sk})</span>
                }<span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">src.mustBeExported()

        de := dst.typ.Elem()
        if !stringCopy </span><span class="cov0" title="0">{
                se := src.typ.Elem()
                typesMustMatch("reflect.Copy", de, se)
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">var ds, ss unsafeheader.Slice
        if dk == Array </span><span class="cov0" title="0">{
                ds.Data = dst.ptr
                ds.Len = dst.Len()
                ds.Cap = ds.Len
        }</span><span class="cov0" title="0"> else {
                ds = *(*unsafeheader.Slice)(dst.ptr)
        }</span>
        <span class="cov0" title="0">if sk == Array </span><span class="cov0" title="0">{
                ss.Data = src.ptr
                ss.Len = src.Len()
                ss.Cap = ss.Len
        }</span><span class="cov0" title="0"> else if sk == Slice </span><span class="cov0" title="0">{
                ss = *(*unsafeheader.Slice)(src.ptr)
        }</span><span class="cov0" title="0"> else {
                sh := *(*unsafeheader.String)(src.ptr)
                ss.Data = sh.Data
                ss.Len = sh.Len
                ss.Cap = sh.Len
        }</span>

        <span class="cov0" title="0">return typedslicecopy(de.common(), ds, ss)</span>
}

// A runtimeSelect is a single case passed to rselect.
// This must match ../runtime/select.go:/runtimeSelect
type runtimeSelect struct {
        dir SelectDir      // SelectSend, SelectRecv or SelectDefault
        typ *rtype         // channel type
        ch  unsafe.Pointer // channel
        val unsafe.Pointer // ptr to data (SendDir) or ptr to receive buffer (RecvDir)
}

// rselect runs a select. It returns the index of the chosen case.
// If the case was a receive, val is filled in with the received value.
// The conventional OK bool indicates whether the receive corresponds
// to a sent value.
//go:noescape
func rselect([]runtimeSelect) (chosen int, recvOK bool)

// A SelectDir describes the communication direction of a select case.
type SelectDir int

// NOTE: These values must match ../runtime/select.go:/selectDir.

const (
        _             SelectDir = iota
        SelectSend              // case Chan &lt;- Send
        SelectRecv              // case &lt;-Chan:
        SelectDefault           // default
)

// A SelectCase describes a single case in a select operation.
// The kind of case depends on Dir, the communication direction.
//
// If Dir is SelectDefault, the case represents a default case.
// Chan and Send must be zero Values.
//
// If Dir is SelectSend, the case represents a send operation.
// Normally Chan's underlying value must be a channel, and Send's underlying value must be
// assignable to the channel's element type. As a special case, if Chan is a zero Value,
// then the case is ignored, and the field Send will also be ignored and may be either zero
// or non-zero.
//
// If Dir is SelectRecv, the case represents a receive operation.
// Normally Chan's underlying value must be a channel and Send must be a zero Value.
// If Chan is a zero Value, then the case is ignored, but Send must still be a zero Value.
// When a receive operation is selected, the received Value is returned by Select.
//
type SelectCase struct {
        Dir  SelectDir // direction of case
        Chan Value     // channel to use (for send or receive)
        Send Value     // value to send (for send)
}

// Select executes a select operation described by the list of cases.
// Like the Go select statement, it blocks until at least one of the cases
// can proceed, makes a uniform pseudo-random choice,
// and then executes that case. It returns the index of the chosen case
// and, if that case was a receive operation, the value received and a
// boolean indicating whether the value corresponds to a send on the channel
// (as opposed to a zero value received because the channel is closed).
// Select supports a maximum of 65536 cases.
func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool) <span class="cov0" title="0">{
        if len(cases) &gt; 65536 </span><span class="cov0" title="0">{
                panic("reflect.Select: too many cases (max 65536)")</span>
        }<span class="cov0" title="0">
</span>        // NOTE: Do not trust that caller is not modifying cases data underfoot.
        // The range is safe because the caller cannot modify our copy of the len
        // and each iteration makes its own copy of the value c.
        <span class="cov0" title="0">var runcases []runtimeSelect
        if len(cases) &gt; 4 </span><span class="cov8" title="1">{
                // Slice is heap allocated due to runtime dependent capacity.
                runcases = make([]runtimeSelect, len(cases))
        }</span><span class="cov0" title="0"> else {
                // Slice can be stack allocated due to constant capacity.
                runcases = make([]runtimeSelect, len(cases), 4)
        }</span>

        <span class="cov0" title="0">haveDefault := false
        for i, c := range cases </span><span class="cov0" title="0">{
                rc := &amp;runcases[i]
                rc.dir = c.Dir
                switch c.Dir </span>{
                <span class="cov0" title="0">default:
                        panic("reflect.Select: invalid Dir")</span>

                <span class="cov0" title="0">case SelectDefault: // default
                        if haveDefault </span><span class="cov0" title="0">{
                                panic("reflect.Select: multiple default cases")</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">haveDefault = true
                        if c.Chan.IsValid() </span><span class="cov0" title="0">{
                                panic("reflect.Select: default case has Chan value")</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">if c.Send.IsValid() </span><span class="cov0" title="0">{
                                panic("reflect.Select: default case has Send value")</span>
                        }<span class="cov0" title="0">
</span>
                <span class="cov0" title="0">case SelectSend:
                        ch := c.Chan
                        if !ch.IsValid() </span><span class="cov0" title="0">{
                                break</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">ch.mustBe(Chan)
                        ch.mustBeExported()
                        tt := (*chanType)(unsafe.Pointer(ch.typ))
                        if ChanDir(tt.dir)&amp;SendDir == 0 </span><span class="cov0" title="0">{
                                panic("reflect.Select: SendDir case using recv-only channel")</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">rc.ch = ch.pointer()
                        rc.typ = &amp;tt.rtype
                        v := c.Send
                        if !v.IsValid() </span><span class="cov0" title="0">{
                                panic("reflect.Select: SendDir case missing Send value")</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">v.mustBeExported()
                        v = v.assignTo("reflect.Select", tt.elem, nil)
                        if v.flag&amp;flagIndir != 0 </span><span class="cov0" title="0">{
                                rc.val = v.ptr
                        }</span><span class="cov0" title="0"> else {
                                rc.val = unsafe.Pointer(&amp;v.ptr)
                        }</span>

                <span class="cov0" title="0">case SelectRecv:
                        if c.Send.IsValid() </span><span class="cov0" title="0">{
                                panic("reflect.Select: RecvDir case has Send value")</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">ch := c.Chan
                        if !ch.IsValid() </span><span class="cov0" title="0">{
                                break</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">ch.mustBe(Chan)
                        ch.mustBeExported()
                        tt := (*chanType)(unsafe.Pointer(ch.typ))
                        if ChanDir(tt.dir)&amp;RecvDir == 0 </span><span class="cov0" title="0">{
                                panic("reflect.Select: RecvDir case using send-only channel")</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov8" title="1">rc.ch = ch.pointer()
                        rc.typ = &amp;tt.rtype
                        rc.val = unsafe_New(tt.elem)</span>
                }
        }

        <span class="cov0" title="0">chosen, recvOK = rselect(runcases)
        if runcases[chosen].dir == SelectRecv </span><span class="cov0" title="0">{
                tt := (*chanType)(unsafe.Pointer(runcases[chosen].typ))
                t := tt.elem
                p := runcases[chosen].val
                fl := flag(t.Kind())
                if ifaceIndir(t) </span><span class="cov0" title="0">{
                        recv = Value{t, p, fl | flagIndir}
                }</span><span class="cov0" title="0"> else {
                        recv = Value{t, *(*unsafe.Pointer)(p), fl}
                }</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">return chosen, recv, recvOK</span>
}

/*
 * constructors
 */

// implemented in package runtime
func unsafe_New(*rtype) unsafe.Pointer
func unsafe_NewArray(*rtype, int) unsafe.Pointer

// MakeSlice creates a new zero-initialized slice value
// for the specified slice type, length, and capacity.
func MakeSlice(typ Type, len, cap int) Value <span class="cov0" title="0">{
        if typ.Kind() != Slice </span><span class="cov0" title="0">{
                panic("reflect.MakeSlice of non-slice type")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov8" title="1">if len &lt; 0 </span><span class="cov0" title="0">{
                panic("reflect.MakeSlice: negative len")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if cap &lt; 0 </span><span class="cov0" title="0">{
                panic("reflect.MakeSlice: negative cap")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if len &gt; cap </span><span class="cov0" title="0">{
                panic("reflect.MakeSlice: len &gt; cap")</span>
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">s := unsafeheader.Slice{Data: unsafe_NewArray(typ.Elem().(*rtype), cap), Len: len, Cap: cap}
        return Value{typ.(*rtype), unsafe.Pointer(&amp;s), flagIndir | flag(Slice)}</span>
}

// MakeChan creates a new channel with the specified type and buffer size.
func MakeChan(typ Type, buffer int) Value <span class="cov0" title="0">{
        if typ.Kind() != Chan </span><span class="cov0" title="0">{
                panic("reflect.MakeChan of non-chan type")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if buffer &lt; 0 </span><span class="cov0" title="0">{
                panic("reflect.MakeChan: negative buffer size")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if typ.ChanDir() != BothDir </span><span class="cov0" title="0">{
                panic("reflect.MakeChan: unidirectional channel type")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">t := typ.(*rtype)
        ch := makechan(t, buffer)
        return Value{t, ch, flag(Chan)}</span>
}

// MakeMap creates a new map with the specified type.
func MakeMap(typ Type) Value <span class="cov0" title="0">{
        return MakeMapWithSize(typ, 0)
}</span>

// MakeMapWithSize creates a new map with the specified type
// and initial space for approximately n elements.
func MakeMapWithSize(typ Type, n int) Value <span class="cov0" title="0">{
        if typ.Kind() != Map </span><span class="cov0" title="0">{
                panic("reflect.MakeMapWithSize of non-map type")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">t := typ.(*rtype)
        m := makemap(t, n)
        return Value{t, m, flag(Map)}</span>
}

// Indirect returns the value that v points to.
// If v is a nil pointer, Indirect returns a zero Value.
// If v is not a pointer, Indirect returns v.
func Indirect(v Value) Value <span class="cov0" title="0">{
        if v.Kind() != Ptr </span><span class="cov0" title="0">{
                return v
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return v.Elem()</span>
}

// ValueOf returns a new Value initialized to the concrete value
// stored in the interface i. ValueOf(nil) returns the zero Value.
func ValueOf(i interface{}) Value <span class="cov0" title="0">{
        if i == nil </span><span class="cov0" title="0">{
                return Value{}
        }</span><span class="cov0" title="0">
</span>
        // TODO: Maybe allow contents of a Value to live on the stack.
        // For now we make the contents always escape to the heap. It
        // makes life easier in a few places (see chanrecv/mapassign
        // comment below).
        <span class="cov0" title="0">escapes(i)

        return unpackEface(i)</span>
}

// Zero returns a Value representing the zero value for the specified type.
// The result is different from the zero value of the Value struct,
// which represents no value at all.
// For example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0.
// The returned value is neither addressable nor settable.
func Zero(typ Type) Value <span class="cov0" title="0">{
        if typ == nil </span><span class="cov0" title="0">{
                panic("reflect: Zero(nil)")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">t := typ.(*rtype)
        fl := flag(t.Kind())
        if ifaceIndir(t) </span><span class="cov0" title="0">{
                return Value{t, unsafe_New(t), fl | flagIndir}
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return Value{t, nil, fl}</span>
}

// New returns a Value representing a pointer to a new zero value
// for the specified type. That is, the returned Value's Type is PtrTo(typ).
func New(typ Type) Value <span class="cov0" title="0">{
        if typ == nil </span><span class="cov0" title="0">{
                panic("reflect: New(nil)")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">t := typ.(*rtype)
        ptr := unsafe_New(t)
        fl := flag(Ptr)
        return Value{t.ptrTo(), ptr, fl}</span>
}

// NewAt returns a Value representing a pointer to a value of the
// specified type, using p as that pointer.
func NewAt(typ Type, p unsafe.Pointer) Value <span class="cov0" title="0">{
        fl := flag(Ptr)
        t := typ.(*rtype)
        return Value{t.ptrTo(), p, fl}
}</span>

// assignTo returns a value v that can be assigned directly to typ.
// It panics if v is not assignable to typ.
// For a conversion to an interface type, target is a suggested scratch space to use.
// target must be initialized memory (or nil).
func (v Value) assignTo(context string, dst *rtype, target unsafe.Pointer) Value <span class="cov0" title="0">{
        if v.flag&amp;flagMethod != 0 </span><span class="cov0" title="0">{
                v = makeMethodValue(context, v)
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">switch </span>{
        <span class="cov0" title="0">case directlyAssignable(dst, v.typ):
                // Overwrite type so that they match.
                // Same memory layout, so no harm done.
                fl := v.flag&amp;(flagAddr|flagIndir) | v.flag.ro()
                fl |= flag(dst.Kind())
                return Value{dst, v.ptr, fl}</span>

        <span class="cov0" title="0">case implements(dst, v.typ):
                if target == nil </span><span class="cov0" title="0">{
                        target = unsafe_New(dst)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if v.Kind() == Interface &amp;&amp; v.IsNil() </span><span class="cov0" title="0">{
                        // A nil ReadWriter passed to nil Reader is OK,
                        // but using ifaceE2I below will panic.
                        // Avoid the panic by returning a nil dst (e.g., Reader) explicitly.
                        return Value{dst, nil, flag(Interface)}
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">x := valueInterface(v, false)
                if dst.NumMethod() == 0 </span><span class="cov0" title="0">{
                        *(*interface{})(target) = x
                }</span><span class="cov0" title="0"> else {
                        ifaceE2I(dst, x, target)
                }</span>
                <span class="cov0" title="0">return Value{dst, target, flagIndir | flag(Interface)}</span>
        }

        // Failed.
        <span class="cov0" title="0">panic(context + ": value of type " + v.typ.String() + " is not assignable to type " + dst.String())</span>
}

// Convert returns the value v converted to type t.
// If the usual Go conversion rules do not allow conversion
// of the value v to type t, Convert panics.
func (v Value) Convert(t Type) Value <span class="cov0" title="0">{
        if v.flag&amp;flagMethod != 0 </span><span class="cov0" title="0">{
                v = makeMethodValue("Convert", v)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">op := convertOp(t.common(), v.typ)
        if op == nil </span><span class="cov0" title="0">{
                panic("reflect.Value.Convert: value of type " + v.typ.String() + " cannot be converted to type " + t.String())</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">return op(v, t)</span>
}

// convertOp returns the function to convert a value of type src
// to a value of type dst. If the conversion is illegal, convertOp returns nil.
func convertOp(dst, src *rtype) func(Value, Type) Value <span class="cov0" title="0">{
        switch src.Kind() </span>{
        <span class="cov0" title="0">case Int, Int8, Int16, Int32, Int64:
                switch dst.Kind() </span>{
                <span class="cov0" title="0">case Int, Int8, Int16, Int32, Int64, Uint, Uint8, Uint16, Uint32, Uint64, Uintptr:
                        return cvtInt</span>
                <span class="cov0" title="0">case Float32, Float64:
                        return cvtIntFloat</span>
                <span class="cov0" title="0">case String:
                        return cvtIntString</span>
                }

        <span class="cov0" title="0">case Uint, Uint8, Uint16, Uint32, Uint64, Uintptr:
                switch dst.Kind() </span>{
                <span class="cov0" title="0">case Int, Int8, Int16, Int32, Int64, Uint, Uint8, Uint16, Uint32, Uint64, Uintptr:
                        return cvtUint</span>
                <span class="cov0" title="0">case Float32, Float64:
                        return cvtUintFloat</span>
                <span class="cov0" title="0">case String:
                        return cvtUintString</span>
                }

        <span class="cov0" title="0">case Float32, Float64:
                switch dst.Kind() </span>{
                <span class="cov0" title="0">case Int, Int8, Int16, Int32, Int64:
                        return cvtFloatInt</span>
                <span class="cov0" title="0">case Uint, Uint8, Uint16, Uint32, Uint64, Uintptr:
                        return cvtFloatUint</span>
                <span class="cov0" title="0">case Float32, Float64:
                        return cvtFloat</span>
                }

        <span class="cov0" title="0">case Complex64, Complex128:
                switch dst.Kind() </span>{
                <span class="cov0" title="0">case Complex64, Complex128:
                        return cvtComplex</span>
                }

        <span class="cov0" title="0">case String:
                if dst.Kind() == Slice &amp;&amp; dst.Elem().PkgPath() == "" </span><span class="cov0" title="0">{
                        switch dst.Elem().Kind() </span>{
                        <span class="cov0" title="0">case Uint8:
                                return cvtStringBytes</span>
                        <span class="cov0" title="0">case Int32:
                                return cvtStringRunes</span>
                        }
                }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">case Slice:
                if dst.Kind() == String &amp;&amp; src.Elem().PkgPath() == "" </span><span class="cov0" title="0">{
                        switch src.Elem().Kind() </span>{
                        <span class="cov0" title="0">case Uint8:
                                return cvtBytesString</span>
                        <span class="cov0" title="0">case Int32:
                                return cvtRunesString</span>
                        }
                }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">case Chan:
                if dst.Kind() == Chan &amp;&amp; specialChannelAssignability(dst, src) </span><span class="cov0" title="0">{
                        return cvtDirect
                }</span><span class="cov0" title="0">
</span>        }

        // dst and src have same underlying type.
        <span class="cov0" title="0">if haveIdenticalUnderlyingType(dst, src, false) </span><span class="cov0" title="0">{
                return cvtDirect
        }</span><span class="cov0" title="0">
</span>
        // dst and src are non-defined pointer types with same underlying base type.
        <span class="cov0" title="0">if dst.Kind() == Ptr &amp;&amp; dst.Name() == "" &amp;&amp;
                src.Kind() == Ptr &amp;&amp; src.Name() == "" &amp;&amp;
                haveIdenticalUnderlyingType(dst.Elem().common(), src.Elem().common(), false) </span><span class="cov0" title="0">{
                return cvtDirect
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if implements(dst, src) </span><span class="cov0" title="0">{
                if src.Kind() == Interface </span><span class="cov0" title="0">{
                        return cvtI2I
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return cvtT2I</span>
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">return nil</span>
}

// makeInt returns a Value of type t equal to bits (possibly truncated),
// where t is a signed or unsigned int type.
func makeInt(f flag, bits uint64, t Type) Value <span class="cov0" title="0">{
        typ := t.common()
        ptr := unsafe_New(typ)
        switch typ.size </span>{
        <span class="cov0" title="0">case 1:
                *(*uint8)(ptr) = uint8(bits)</span>
        <span class="cov0" title="0">case 2:
                *(*uint16)(ptr) = uint16(bits)</span>
        <span class="cov0" title="0">case 4:
                *(*uint32)(ptr) = uint32(bits)</span>
        <span class="cov0" title="0">case 8:
                *(*uint64)(ptr) = bits</span>
        }
        <span class="cov0" title="0">return Value{typ, ptr, f | flagIndir | flag(typ.Kind())}</span>
}

// makeFloat returns a Value of type t equal to v (possibly truncated to float32),
// where t is a float32 or float64 type.
func makeFloat(f flag, v float64, t Type) Value <span class="cov0" title="0">{
        typ := t.common()
        ptr := unsafe_New(typ)
        switch typ.size </span>{
        <span class="cov0" title="0">case 4:
                *(*float32)(ptr) = float32(v)</span>
        <span class="cov0" title="0">case 8:
                *(*float64)(ptr) = v</span>
        }
        <span class="cov0" title="0">return Value{typ, ptr, f | flagIndir | flag(typ.Kind())}</span>
}

// makeFloat returns a Value of type t equal to v, where t is a float32 type.
func makeFloat32(f flag, v float32, t Type) Value <span class="cov0" title="0">{
        typ := t.common()
        ptr := unsafe_New(typ)
        *(*float32)(ptr) = v
        return Value{typ, ptr, f | flagIndir | flag(typ.Kind())}
}</span>

// makeComplex returns a Value of type t equal to v (possibly truncated to complex64),
// where t is a complex64 or complex128 type.
func makeComplex(f flag, v complex128, t Type) Value <span class="cov0" title="0">{
        typ := t.common()
        ptr := unsafe_New(typ)
        switch typ.size </span>{
        <span class="cov0" title="0">case 8:
                *(*complex64)(ptr) = complex64(v)</span>
        <span class="cov0" title="0">case 16:
                *(*complex128)(ptr) = v</span>
        }
        <span class="cov0" title="0">return Value{typ, ptr, f | flagIndir | flag(typ.Kind())}</span>
}

func makeString(f flag, v string, t Type) Value <span class="cov0" title="0">{
        ret := New(t).Elem()
        ret.SetString(v)
        ret.flag = ret.flag&amp;^flagAddr | f
        return ret
}</span>

func makeBytes(f flag, v []byte, t Type) Value <span class="cov0" title="0">{
        ret := New(t).Elem()
        ret.SetBytes(v)
        ret.flag = ret.flag&amp;^flagAddr | f
        return ret
}</span>

func makeRunes(f flag, v []rune, t Type) Value <span class="cov0" title="0">{
        ret := New(t).Elem()
        ret.setRunes(v)
        ret.flag = ret.flag&amp;^flagAddr | f
        return ret
}</span>

// These conversion functions are returned by convertOp
// for classes of conversions. For example, the first function, cvtInt,
// takes any value v of signed int type and returns the value converted
// to type t, where t is any signed or unsigned int type.

// convertOp: intXX -&gt; [u]intXX
func cvtInt(v Value, t Type) Value <span class="cov0" title="0">{
        return makeInt(v.flag.ro(), uint64(v.Int()), t)
}</span>

// convertOp: uintXX -&gt; [u]intXX
func cvtUint(v Value, t Type) Value <span class="cov0" title="0">{
        return makeInt(v.flag.ro(), v.Uint(), t)
}</span>

// convertOp: floatXX -&gt; intXX
func cvtFloatInt(v Value, t Type) Value <span class="cov0" title="0">{
        return makeInt(v.flag.ro(), uint64(int64(v.Float())), t)
}</span>

// convertOp: floatXX -&gt; uintXX
func cvtFloatUint(v Value, t Type) Value <span class="cov0" title="0">{
        return makeInt(v.flag.ro(), uint64(v.Float()), t)
}</span>

// convertOp: intXX -&gt; floatXX
func cvtIntFloat(v Value, t Type) Value <span class="cov0" title="0">{
        return makeFloat(v.flag.ro(), float64(v.Int()), t)
}</span>

// convertOp: uintXX -&gt; floatXX
func cvtUintFloat(v Value, t Type) Value <span class="cov0" title="0">{
        return makeFloat(v.flag.ro(), float64(v.Uint()), t)
}</span>

// convertOp: floatXX -&gt; floatXX
func cvtFloat(v Value, t Type) Value <span class="cov0" title="0">{
        if v.Type().Kind() == Float32 &amp;&amp; t.Kind() == Float32 </span><span class="cov0" title="0">{
                // Don't do any conversion if both types have underlying type float32.
                // This avoids converting to float64 and back, which will
                // convert a signaling NaN to a quiet NaN. See issue 36400.
                return makeFloat32(v.flag.ro(), *(*float32)(v.ptr), t)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return makeFloat(v.flag.ro(), v.Float(), t)</span>
}

// convertOp: complexXX -&gt; complexXX
func cvtComplex(v Value, t Type) Value <span class="cov0" title="0">{
        return makeComplex(v.flag.ro(), v.Complex(), t)
}</span>

// convertOp: intXX -&gt; string
func cvtIntString(v Value, t Type) Value <span class="cov0" title="0">{
        return makeString(v.flag.ro(), string(rune(v.Int())), t)
}</span>

// convertOp: uintXX -&gt; string
func cvtUintString(v Value, t Type) Value <span class="cov8" title="1">{
        return makeString(v.flag.ro(), string(rune(v.Uint())), t)
}</span>

// convertOp: []byte -&gt; string
func cvtBytesString(v Value, t Type) Value <span class="cov0" title="0">{
        return makeString(v.flag.ro(), string(v.Bytes()), t)
}</span>

// convertOp: string -&gt; []byte
func cvtStringBytes(v Value, t Type) Value <span class="cov0" title="0">{
        return makeBytes(v.flag.ro(), []byte(v.String()), t)
}</span>

// convertOp: []rune -&gt; string
func cvtRunesString(v Value, t Type) Value <span class="cov0" title="0">{
        return makeString(v.flag.ro(), string(v.runes()), t)
}</span>

// convertOp: string -&gt; []rune
func cvtStringRunes(v Value, t Type) Value <span class="cov0" title="0">{
        return makeRunes(v.flag.ro(), []rune(v.String()), t)
}</span>

// convertOp: direct copy
func cvtDirect(v Value, typ Type) Value <span class="cov0" title="0">{
        f := v.flag
        t := typ.common()
        ptr := v.ptr
        if f&amp;flagAddr != 0 </span><span class="cov0" title="0">{
                // indirect, mutable word - make a copy
                c := unsafe_New(t)
                typedmemmove(t, c, ptr)
                ptr = c
                f &amp;^= flagAddr
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return Value{t, ptr, v.flag.ro() | f}</span> // v.flag.ro()|f == f?
}

// convertOp: concrete -&gt; interface
func cvtT2I(v Value, typ Type) Value <span class="cov0" title="0">{
        target := unsafe_New(typ.common())
        x := valueInterface(v, false)
        if typ.NumMethod() == 0 </span><span class="cov0" title="0">{
                *(*interface{})(target) = x
        }</span><span class="cov0" title="0"> else {
                ifaceE2I(typ.(*rtype), x, target)
        }</span>
        <span class="cov0" title="0">return Value{typ.common(), target, v.flag.ro() | flagIndir | flag(Interface)}</span>
}

// convertOp: interface -&gt; interface
func cvtI2I(v Value, typ Type) Value <span class="cov0" title="0">{
        if v.IsNil() </span><span class="cov0" title="0">{
                ret := Zero(typ)
                ret.flag |= v.flag.ro()
                return ret
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return cvtT2I(v.Elem(), typ)</span>
}

// implemented in ../runtime
func chancap(ch unsafe.Pointer) int
func chanclose(ch unsafe.Pointer)
func chanlen(ch unsafe.Pointer) int

// Note: some of the noescape annotations below are technically a lie,
// but safe in the context of this package. Functions like chansend
// and mapassign don't escape the referent, but may escape anything
// the referent points to (they do shallow copies of the referent).
// It is safe in this package because the referent may only point
// to something a Value may point to, and that is always in the heap
// (due to the escapes() call in ValueOf).

//go:noescape
func chanrecv(ch unsafe.Pointer, nb bool, val unsafe.Pointer) (selected, received bool)

//go:noescape
func chansend(ch unsafe.Pointer, val unsafe.Pointer, nb bool) bool

func makechan(typ *rtype, size int) (ch unsafe.Pointer)
func makemap(t *rtype, cap int) (m unsafe.Pointer)

//go:noescape
func mapaccess(t *rtype, m unsafe.Pointer, key unsafe.Pointer) (val unsafe.Pointer)

//go:noescape
func mapassign(t *rtype, m unsafe.Pointer, key, val unsafe.Pointer)

//go:noescape
func mapdelete(t *rtype, m unsafe.Pointer, key unsafe.Pointer)

// m escapes into the return value, but the caller of mapiterinit
// doesn't let the return value escape.
//go:noescape
func mapiterinit(t *rtype, m unsafe.Pointer) unsafe.Pointer

//go:noescape
func mapiterkey(it unsafe.Pointer) (key unsafe.Pointer)

//go:noescape
func mapiterelem(it unsafe.Pointer) (elem unsafe.Pointer)

//go:noescape
func mapiternext(it unsafe.Pointer)

//go:noescape
func maplen(m unsafe.Pointer) int

// call calls fn with a copy of the n argument bytes pointed at by arg.
// After fn returns, reflectcall copies n-retoffset result bytes
// back into arg+retoffset before returning. If copying result bytes back,
// the caller must pass the argument frame type as argtype, so that
// call can execute appropriate write barriers during the copy.
//
//go:linkname call runtime.reflectcall
func call(argtype *rtype, fn, arg unsafe.Pointer, n uint32, retoffset uint32)

func ifaceE2I(t *rtype, src interface{}, dst unsafe.Pointer)

// memmove copies size bytes to dst from src. No write barriers are used.
//go:noescape
func memmove(dst, src unsafe.Pointer, size uintptr)

// typedmemmove copies a value of type t to dst from src.
//go:noescape
func typedmemmove(t *rtype, dst, src unsafe.Pointer)

// typedmemmovepartial is like typedmemmove but assumes that
// dst and src point off bytes into the value and only copies size bytes.
//go:noescape
func typedmemmovepartial(t *rtype, dst, src unsafe.Pointer, off, size uintptr)

// typedmemclr zeros the value at ptr of type t.
//go:noescape
func typedmemclr(t *rtype, ptr unsafe.Pointer)

// typedmemclrpartial is like typedmemclr but assumes that
// dst points off bytes into the value and only clears size bytes.
//go:noescape
func typedmemclrpartial(t *rtype, ptr unsafe.Pointer, off, size uintptr)

// typedslicecopy copies a slice of elemType values from src to dst,
// returning the number of elements copied.
//go:noescape
func typedslicecopy(elemType *rtype, dst, src unsafeheader.Slice) int

//go:noescape
func typehash(t *rtype, p unsafe.Pointer, h uintptr) uintptr

// Dummy annotation marking that the value x escapes,
// for use in cases where the reflect code is so clever that
// the compiler cannot follow.
func escapes(x interface{}) <span class="cov0" title="0">{
        if dummy.b </span><span class="cov0" title="0">{
                dummy.x = x
        }</span><span class="cov0" title="0">
</span>}

var dummy struct {
        b bool
        x interface{}
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate go run genzfunc.go

// Package sort provides primitives for sorting slices and user-defined
// collections.
package sort

// A type, typically a collection, that satisfies sort.Interface can be
// sorted by the routines in this package. The methods require that the
// elements of the collection be enumerated by an integer index.
type Interface interface {
        // Len is the number of elements in the collection.
        Len() int
        // Less reports whether the element with
        // index i should sort before the element with index j.
        Less(i, j int) bool
        // Swap swaps the elements with indexes i and j.
        Swap(i, j int)
}

// Insertion sort
func insertionSort(data Interface, a, b int) <span class="cov0" title="0">{
        for i := a + 1; i &lt; b; i++ </span><span class="cov0" title="0">{
                for j := i; j &gt; a &amp;&amp; data.Less(j, j-1); j-- </span><span class="cov0" title="0">{
                        data.Swap(j, j-1)
                }</span>
        }
}

// siftDown implements the heap property on data[lo, hi).
// first is an offset into the array where the root of the heap lies.
func siftDown(data Interface, lo, hi, first int) <span class="cov0" title="0">{
        root := lo
        for </span><span class="cov0" title="0">{
                child := 2*root + 1
                if child &gt;= hi </span><span class="cov0" title="0">{
                        break</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">if child+1 &lt; hi &amp;&amp; data.Less(first+child, first+child+1) </span><span class="cov0" title="0">{
                        child++
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if !data.Less(first+root, first+child) </span><span class="cov0" title="0">{
                        return
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">data.Swap(first+root, first+child)
                root = child</span>
        }
}

func heapSort(data Interface, a, b int) <span class="cov0" title="0">{
        first := a
        lo := 0
        hi := b - a

        // Build heap with greatest element at top.
        for i := (hi - 1) / 2; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                siftDown(data, i, hi, first)
        }</span>

        // Pop elements, largest first, into end of data.
        <span class="cov0" title="0">for i := hi - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                data.Swap(first, first+i)
                siftDown(data, lo, i, first)
        }</span>
}

// Quicksort, loosely following Bentley and McIlroy,
// ``Engineering a Sort Function,'' SP&amp;E November 1993.

// medianOfThree moves the median of the three values data[m0], data[m1], data[m2] into data[m1].
func medianOfThree(data Interface, m1, m0, m2 int) <span class="cov0" title="0">{
        // sort 3 elements
        if data.Less(m1, m0) </span><span class="cov0" title="0">{
                data.Swap(m1, m0)
        }</span><span class="cov0" title="0">
</span>        // data[m0] &lt;= data[m1]
        <span class="cov0" title="0">if data.Less(m2, m1) </span><span class="cov0" title="0">{
                data.Swap(m2, m1)
                // data[m0] &lt;= data[m2] &amp;&amp; data[m1] &lt; data[m2]
                if data.Less(m1, m0) </span><span class="cov0" title="0">{
                        data.Swap(m1, m0)
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>        // now data[m0] &lt;= data[m1] &lt;= data[m2]
}

func swapRange(data Interface, a, b, n int) <span class="cov0" title="0">{
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                data.Swap(a+i, b+i)
        }</span>
}

func doPivot(data Interface, lo, hi int) (midlo, midhi int) <span class="cov0" title="0">{
        m := int(uint(lo+hi) &gt;&gt; 1) // Written like this to avoid integer overflow.
        if hi-lo &gt; 40 </span><span class="cov0" title="0">{
                // Tukey's ``Ninther,'' median of three medians of three.
                s := (hi - lo) / 8
                medianOfThree(data, lo, lo+s, lo+2*s)
                medianOfThree(data, m, m-s, m+s)
                medianOfThree(data, hi-1, hi-1-s, hi-1-2*s)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">medianOfThree(data, lo, m, hi-1)

        // Invariants are:
        //        data[lo] = pivot (set up by ChoosePivot)
        //        data[lo &lt; i &lt; a] &lt; pivot
        //        data[a &lt;= i &lt; b] &lt;= pivot
        //        data[b &lt;= i &lt; c] unexamined
        //        data[c &lt;= i &lt; hi-1] &gt; pivot
        //        data[hi-1] &gt;= pivot
        pivot := lo
        a, c := lo+1, hi-1

        for ; a &lt; c &amp;&amp; data.Less(a, pivot); a++ </span><span class="cov0" title="0">{
        }</span>
        <span class="cov0" title="0">b := a
        for </span><span class="cov0" title="0">{
                for ; b &lt; c &amp;&amp; !data.Less(pivot, b); b++ </span><span class="cov0" title="0">{ // data[b] &lt;= pivot
                }</span>
                <span class="cov0" title="0">for ; b &lt; c &amp;&amp; data.Less(pivot, c-1); c-- </span><span class="cov0" title="0">{ // data[c-1] &gt; pivot
                }</span>
                <span class="cov0" title="0">if b &gt;= c </span><span class="cov0" title="0">{
                        break</span>
                }<span class="cov0" title="0">
</span>                // data[b] &gt; pivot; data[c-1] &lt;= pivot
                <span class="cov0" title="0">data.Swap(b, c-1)
                b++
                c--</span>
        }
        // If hi-c&lt;3 then there are duplicates (by property of median of nine).
        // Let's be a bit more conservative, and set border to 5.
        <span class="cov0" title="0">protect := hi-c &lt; 5
        if !protect &amp;&amp; hi-c &lt; (hi-lo)/4 </span><span class="cov0" title="0">{
                // Lets test some points for equality to pivot
                dups := 0
                if !data.Less(pivot, hi-1) </span><span class="cov0" title="0">{ // data[hi-1] = pivot
                        data.Swap(c, hi-1)
                        c++
                        dups++
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if !data.Less(b-1, pivot) </span><span class="cov0" title="0">{ // data[b-1] = pivot
                        b--
                        dups++
                }</span><span class="cov0" title="0">
</span>                // m-lo = (hi-lo)/2 &gt; 6
                // b-lo &gt; (hi-lo)*3/4-1 &gt; 8
                // ==&gt; m &lt; b ==&gt; data[m] &lt;= pivot
                <span class="cov0" title="0">if !data.Less(m, pivot) </span><span class="cov0" title="0">{ // data[m] = pivot
                        data.Swap(m, b-1)
                        b--
                        dups++
                }</span><span class="cov0" title="0">
</span>                // if at least 2 points are equal to pivot, assume skewed distribution
                <span class="cov0" title="0">protect = dups &gt; 1</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if protect </span><span class="cov0" title="0">{
                // Protect against a lot of duplicates
                // Add invariant:
                //        data[a &lt;= i &lt; b] unexamined
                //        data[b &lt;= i &lt; c] = pivot
                for </span><span class="cov0" title="0">{
                        for ; a &lt; b &amp;&amp; !data.Less(b-1, pivot); b-- </span><span class="cov0" title="0">{ // data[b] == pivot
                        }</span>
                        <span class="cov0" title="0">for ; a &lt; b &amp;&amp; data.Less(a, pivot); a++ </span><span class="cov0" title="0">{ // data[a] &lt; pivot
                        }</span>
                        <span class="cov0" title="0">if a &gt;= b </span><span class="cov0" title="0">{
                                break</span>
                        }<span class="cov0" title="0">
</span>                        // data[a] == pivot; data[b-1] &lt; pivot
                        <span class="cov0" title="0">data.Swap(a, b-1)
                        a++
                        b--</span>
                }
        }<span class="cov0" title="0">
</span>        // Swap pivot into middle
        <span class="cov0" title="0">data.Swap(pivot, b-1)
        return b - 1, c</span>
}

func quickSort(data Interface, a, b, maxDepth int) <span class="cov0" title="0">{
        for b-a &gt; 12 </span><span class="cov0" title="0">{ // Use ShellSort for slices &lt;= 12 elements
                if maxDepth == 0 </span><span class="cov0" title="0">{
                        heapSort(data, a, b)
                        return
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">maxDepth--
                mlo, mhi := doPivot(data, a, b)
                // Avoiding recursion on the larger subproblem guarantees
                // a stack depth of at most lg(b-a).
                if mlo-a &lt; b-mhi </span><span class="cov0" title="0">{
                        quickSort(data, a, mlo, maxDepth)
                        a = mhi // i.e., quickSort(data, mhi, b)
                }</span><span class="cov0" title="0"> else {
                        quickSort(data, mhi, b, maxDepth)
                        b = mlo // i.e., quickSort(data, a, mlo)
                }</span>
        }
        <span class="cov0" title="0">if b-a &gt; 1 </span><span class="cov0" title="0">{
                // Do ShellSort pass with gap 6
                // It could be written in this simplified form cause b-a &lt;= 12
                for i := a + 6; i &lt; b; i++ </span><span class="cov0" title="0">{
                        if data.Less(i, i-6) </span><span class="cov0" title="0">{
                                data.Swap(i, i-6)
                        }</span><span class="cov0" title="0">
</span>                }
                <span class="cov0" title="0">insertionSort(data, a, b)</span>
        }<span class="cov0" title="0">
</span>}

// Sort sorts data.
// It makes one call to data.Len to determine n, and O(n*log(n)) calls to
// data.Less and data.Swap. The sort is not guaranteed to be stable.
func Sort(data Interface) <span class="cov0" title="0">{
        n := data.Len()
        quickSort(data, 0, n, maxDepth(n))
}</span>

// maxDepth returns a threshold at which quicksort should switch
// to heapsort. It returns 2*ceil(lg(n+1)).
func maxDepth(n int) int <span class="cov0" title="0">{
        var depth int
        for i := n; i &gt; 0; i &gt;&gt;= 1 </span><span class="cov0" title="0">{
                depth++
        }</span>
        <span class="cov0" title="0">return depth * 2</span>
}

// lessSwap is a pair of Less and Swap function for use with the
// auto-generated func-optimized variant of sort.go in
// zfuncversion.go.
type lessSwap struct {
        Less func(i, j int) bool
        Swap func(i, j int)
}

type reverse struct {
        // This embedded Interface permits Reverse to use the methods of
        // another Interface implementation.
        Interface
}

// Less returns the opposite of the embedded implementation's Less method.
func (r reverse) Less(i, j int) bool <span class="cov0" title="0">{
        return r.Interface.Less(j, i)
}</span>

// Reverse returns the reverse order for data.
func Reverse(data Interface) Interface <span class="cov0" title="0">{
        return &amp;reverse{data}
}</span>

// IsSorted reports whether data is sorted.
func IsSorted(data Interface) bool <span class="cov0" title="0">{
        n := data.Len()
        for i := n - 1; i &gt; 0; i-- </span><span class="cov0" title="0">{
                if data.Less(i, i-1) </span><span class="cov0" title="0">{
                        return false
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return true</span>
}

// Convenience types for common cases

// IntSlice attaches the methods of Interface to []int, sorting in increasing order.
type IntSlice []int

func (p IntSlice) Len() int           <span class="cov0" title="0">{ return len(p) }</span>
func (p IntSlice) Less(i, j int) bool <span class="cov0" title="0">{ return p[i] &lt; p[j] }</span>
func (p IntSlice) Swap(i, j int)      <span class="cov0" title="0">{ p[i], p[j] = p[j], p[i] }</span>

// Sort is a convenience method.
func (p IntSlice) Sort() <span class="cov0" title="0">{ Sort(p) }</span>

// Float64Slice attaches the methods of Interface to []float64, sorting in increasing order
// (not-a-number values are treated as less than other values).
type Float64Slice []float64

func (p Float64Slice) Len() int           <span class="cov0" title="0">{ return len(p) }</span>
func (p Float64Slice) Less(i, j int) bool <span class="cov0" title="0">{ return p[i] &lt; p[j] || isNaN(p[i]) &amp;&amp; !isNaN(p[j]) }</span>
func (p Float64Slice) Swap(i, j int)      <span class="cov0" title="0">{ p[i], p[j] = p[j], p[i] }</span>

// isNaN is a copy of math.IsNaN to avoid a dependency on the math package.
func isNaN(f float64) bool <span class="cov0" title="0">{
        return f != f
}</span>

// Sort is a convenience method.
func (p Float64Slice) Sort() <span class="cov0" title="0">{ Sort(p) }</span>

// StringSlice attaches the methods of Interface to []string, sorting in increasing order.
type StringSlice []string

func (p StringSlice) Len() int           <span class="cov0" title="0">{ return len(p) }</span>
func (p StringSlice) Less(i, j int) bool <span class="cov0" title="0">{ return p[i] &lt; p[j] }</span>
func (p StringSlice) Swap(i, j int)      <span class="cov0" title="0">{ p[i], p[j] = p[j], p[i] }</span>

// Sort is a convenience method.
func (p StringSlice) Sort() <span class="cov0" title="0">{ Sort(p) }</span>

// Convenience wrappers for common cases

// Ints sorts a slice of ints in increasing order.
func Ints(a []int) <span class="cov0" title="0">{ Sort(IntSlice(a)) }</span>

// Float64s sorts a slice of float64s in increasing order
// (not-a-number values are treated as less than other values).
func Float64s(a []float64) <span class="cov0" title="0">{ Sort(Float64Slice(a)) }</span>

// Strings sorts a slice of strings in increasing order.
func Strings(a []string) <span class="cov0" title="0">{ Sort(StringSlice(a)) }</span>

// IntsAreSorted tests whether a slice of ints is sorted in increasing order.
func IntsAreSorted(a []int) bool <span class="cov0" title="0">{ return IsSorted(IntSlice(a)) }</span>

// Float64sAreSorted tests whether a slice of float64s is sorted in increasing order
// (not-a-number values are treated as less than other values).
func Float64sAreSorted(a []float64) bool <span class="cov0" title="0">{ return IsSorted(Float64Slice(a)) }</span>

// StringsAreSorted tests whether a slice of strings is sorted in increasing order.
func StringsAreSorted(a []string) bool <span class="cov0" title="0">{ return IsSorted(StringSlice(a)) }</span>

// Notes on stable sorting:
// The used algorithms are simple and provable correct on all input and use
// only logarithmic additional stack space. They perform well if compared
// experimentally to other stable in-place sorting algorithms.
//
// Remarks on other algorithms evaluated:
//  - GCC's 4.6.3 stable_sort with merge_without_buffer from libstdc++:
//    Not faster.
//  - GCC's __rotate for block rotations: Not faster.
//  - "Practical in-place mergesort" from  Jyrki Katajainen, Tomi A. Pasanen
//    and Jukka Teuhola; Nordic Journal of Computing 3,1 (1996), 27-40:
//    The given algorithms are in-place, number of Swap and Assignments
//    grow as n log n but the algorithm is not stable.
//  - "Fast Stable In-Place Sorting with O(n) Data Moves" J.I. Munro and
//    V. Raman in Algorithmica (1996) 16, 115-160:
//    This algorithm either needs additional 2n bits or works only if there
//    are enough different elements available to encode some permutations
//    which have to be undone later (so not stable on any input).
//  - All the optimal in-place sorting/merging algorithms I found are either
//    unstable or rely on enough different elements in each step to encode the
//    performed block rearrangements. See also "In-Place Merging Algorithms",
//    Denham Coates-Evely, Department of Computer Science, Kings College,
//    January 2004 and the references in there.
//  - Often "optimal" algorithms are optimal in the number of assignments
//    but Interface has only Swap as operation.

// Stable sorts data while keeping the original order of equal elements.
//
// It makes one call to data.Len to determine n, O(n*log(n)) calls to
// data.Less and O(n*log(n)*log(n)) calls to data.Swap.
func Stable(data Interface) <span class="cov0" title="0">{
        stable(data, data.Len())
}</span>

func stable(data Interface, n int) <span class="cov0" title="0">{
        blockSize := 20 // must be &gt; 0
        a, b := 0, blockSize
        for b &lt;= n </span><span class="cov8" title="1">{
                insertionSort(data, a, b)
                a = b
                b += blockSize
        }</span>
        <span class="cov0" title="0">insertionSort(data, a, n)

        for blockSize &lt; n </span><span class="cov0" title="0">{
                a, b = 0, 2*blockSize
                for b &lt;= n </span><span class="cov0" title="0">{
                        symMerge(data, a, a+blockSize, b)
                        a = b
                        b += 2 * blockSize
                }</span>
                <span class="cov0" title="0">if m := a + blockSize; m &lt; n </span><span class="cov0" title="0">{
                        symMerge(data, a, m, n)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">blockSize *= 2</span>
        }
}

// SymMerge merges the two sorted subsequences data[a:m] and data[m:b] using
// the SymMerge algorithm from Pok-Son Kim and Arne Kutzner, "Stable Minimum
// Storage Merging by Symmetric Comparisons", in Susanne Albers and Tomasz
// Radzik, editors, Algorithms - ESA 2004, volume 3221 of Lecture Notes in
// Computer Science, pages 714-723. Springer, 2004.
//
// Let M = m-a and N = b-n. Wolog M &lt; N.
// The recursion depth is bound by ceil(log(N+M)).
// The algorithm needs O(M*log(N/M + 1)) calls to data.Less.
// The algorithm needs O((M+N)*log(M)) calls to data.Swap.
//
// The paper gives O((M+N)*log(M)) as the number of assignments assuming a
// rotation algorithm which uses O(M+N+gcd(M+N)) assignments. The argumentation
// in the paper carries through for Swap operations, especially as the block
// swapping rotate uses only O(M+N) Swaps.
//
// symMerge assumes non-degenerate arguments: a &lt; m &amp;&amp; m &lt; b.
// Having the caller check this condition eliminates many leaf recursion calls,
// which improves performance.
func symMerge(data Interface, a, m, b int) <span class="cov0" title="0">{
        // Avoid unnecessary recursions of symMerge
        // by direct insertion of data[a] into data[m:b]
        // if data[a:m] only contains one element.
        if m-a == 1 </span><span class="cov0" title="0">{
                // Use binary search to find the lowest index i
                // such that data[i] &gt;= data[a] for m &lt;= i &lt; b.
                // Exit the search loop with i == b in case no such index exists.
                i := m
                j := b
                for i &lt; j </span><span class="cov0" title="0">{
                        h := int(uint(i+j) &gt;&gt; 1)
                        if data.Less(h, a) </span><span class="cov0" title="0">{
                                i = h + 1
                        }</span><span class="cov0" title="0"> else {
                                j = h
                        }</span>
                }
                // Swap values until data[a] reaches the position before i.
                <span class="cov0" title="0">for k := a; k &lt; i-1; k++ </span><span class="cov0" title="0">{
                        data.Swap(k, k+1)
                }</span>
                <span class="cov0" title="0">return</span>
        }<span class="cov0" title="0">
</span>
        // Avoid unnecessary recursions of symMerge
        // by direct insertion of data[m] into data[a:m]
        // if data[m:b] only contains one element.
        <span class="cov0" title="0">if b-m == 1 </span><span class="cov0" title="0">{
                // Use binary search to find the lowest index i
                // such that data[i] &gt; data[m] for a &lt;= i &lt; m.
                // Exit the search loop with i == m in case no such index exists.
                i := a
                j := m
                for i &lt; j </span><span class="cov0" title="0">{
                        h := int(uint(i+j) &gt;&gt; 1)
                        if !data.Less(m, h) </span><span class="cov0" title="0">{
                                i = h + 1
                        }</span><span class="cov0" title="0"> else {
                                j = h
                        }</span>
                }
                // Swap values until data[m] reaches the position i.
                <span class="cov0" title="0">for k := m; k &gt; i; k-- </span><span class="cov0" title="0">{
                        data.Swap(k, k-1)
                }</span>
                <span class="cov0" title="0">return</span>
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">mid := int(uint(a+b) &gt;&gt; 1)
        n := mid + m
        var start, r int
        if m &gt; mid </span><span class="cov0" title="0">{
                start = n - b
                r = mid
        }</span><span class="cov0" title="0"> else {
                start = a
                r = m
        }</span>
        <span class="cov0" title="0">p := n - 1

        for start &lt; r </span><span class="cov0" title="0">{
                c := int(uint(start+r) &gt;&gt; 1)
                if !data.Less(p-c, c) </span><span class="cov0" title="0">{
                        start = c + 1
                }</span><span class="cov0" title="0"> else {
                        r = c
                }</span>
        }

        <span class="cov0" title="0">end := n - start
        if start &lt; m &amp;&amp; m &lt; end </span><span class="cov0" title="0">{
                rotate(data, start, m, end)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if a &lt; start &amp;&amp; start &lt; mid </span><span class="cov0" title="0">{
                symMerge(data, a, start, mid)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if mid &lt; end &amp;&amp; end &lt; b </span><span class="cov0" title="0">{
                symMerge(data, mid, end, b)
        }</span><span class="cov0" title="0">
</span>}

// Rotate two consecutive blocks u = data[a:m] and v = data[m:b] in data:
// Data of the form 'x u v y' is changed to 'x v u y'.
// Rotate performs at most b-a many calls to data.Swap.
// Rotate assumes non-degenerate arguments: a &lt; m &amp;&amp; m &lt; b.
func rotate(data Interface, a, m, b int) <span class="cov0" title="0">{
        i := m - a
        j := b - m

        for i != j </span><span class="cov0" title="0">{
                if i &gt; j </span><span class="cov0" title="0">{
                        swapRange(data, m-i, m, j)
                        i -= j
                }</span><span class="cov0" title="0"> else {
                        swapRange(data, m-i, m+j-i, i)
                        j -= i
                }</span>
        }
        // i == j
        <span class="cov0" title="0">swapRange(data, m-i, m, i)</span>
}

/*
Complexity of Stable Sorting


Complexity of block swapping rotation

Each Swap puts one new element into its correct, final position.
Elements which reach their final position are no longer moved.
Thus block swapping rotation needs |u|+|v| calls to Swaps.
This is best possible as each element might need a move.

Pay attention when comparing to other optimal algorithms which
typically count the number of assignments instead of swaps:
E.g. the optimal algorithm of Dudzinski and Dydek for in-place
rotations uses O(u + v + gcd(u,v)) assignments which is
better than our O(3 * (u+v)) as gcd(u,v) &lt;= u.


Stable sorting by SymMerge and BlockSwap rotations

SymMerg complexity for same size input M = N:
Calls to Less:  O(M*log(N/M+1)) = O(N*log(2)) = O(N)
Calls to Swap:  O((M+N)*log(M)) = O(2*N*log(N)) = O(N*log(N))

(The following argument does not fuzz over a missing -1 or
other stuff which does not impact the final result).

Let n = data.Len(). Assume n = 2^k.

Plain merge sort performs log(n) = k iterations.
On iteration i the algorithm merges 2^(k-i) blocks, each of size 2^i.

Thus iteration i of merge sort performs:
Calls to Less  O(2^(k-i) * 2^i) = O(2^k) = O(2^log(n)) = O(n)
Calls to Swap  O(2^(k-i) * 2^i * log(2^i)) = O(2^k * i) = O(n*i)

In total k = log(n) iterations are performed; so in total:
Calls to Less O(log(n) * n)
Calls to Swap O(n + 2*n + 3*n + ... + (k-1)*n + k*n)
   = O((k/2) * k * n) = O(n * k^2) = O(n * log^2(n))


Above results should generalize to arbitrary n = 2^k + p
and should not be influenced by the initial insertion sort phase:
Insertion sort is O(n^2) on Swap and Less, thus O(bs^2) per block of
size bs at n/bs blocks:  O(bs*n) Swaps and Less during insertion sort.
Merge sort iterations start at i = log(bs). With t = log(bs) constant:
Calls to Less O((log(n)-t) * n + bs*n) = O(log(n)*n + (bs-t)*n)
   = O(n * log(n))
Calls to Swap O(n * log^2(n) - (t^2+t)/2*n) = O(n * log^2(n))

*/
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package strconv

// decimal to binary floating point conversion.
// Algorithm:
//   1) Store input in multiprecision decimal.
//   2) Multiply/divide decimal by powers of two until in range [0.5, 1)
//   3) Multiply by 2^precision and round to get mantissa.

import "math"

var optimize = true // set to false to force slow-path conversions for testing

// commonPrefixLenIgnoreCase returns the length of the common
// prefix of s and prefix, with the character case of s ignored.
// The prefix argument must be all lower-case.
func commonPrefixLenIgnoreCase(s, prefix string) int <span class="cov0" title="0">{
        n := len(prefix)
        if n &gt; len(s) </span><span class="cov0" title="0">{
                n = len(s)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                c := s[i]
                if 'A' &lt;= c &amp;&amp; c &lt;= 'Z' </span><span class="cov0" title="0">{
                        c += 'a' - 'A'
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if c != prefix[i] </span><span class="cov0" title="0">{
                        return i
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return n</span>
}

// special returns the floating-point value for the special,
// possibly signed floating-point representations inf, infinity,
// and NaN. The result is ok if a prefix of s contains one
// of these representations and n is the length of that prefix.
// The character case is ignored.
func special(s string) (f float64, n int, ok bool) <span class="cov0" title="0">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return 0, 0, false
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">sign := 1
        nsign := 0
        switch s[0] </span>{
        <span class="cov0" title="0">case '+', '-':
                if s[0] == '-' </span><span class="cov0" title="0">{
                        sign = -1
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">nsign = 1
                s = s[1:]
                fallthrough</span>
        <span class="cov0" title="0">case 'i', 'I':
                n := commonPrefixLenIgnoreCase(s, "infinity")
                // Anything longer than "inf" is ok, but if we
                // don't have "infinity", only consume "inf".
                if 3 &lt; n &amp;&amp; n &lt; 8 </span><span class="cov0" title="0">{
                        n = 3
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if n == 3 || n == 8 </span><span class="cov0" title="0">{
                        return math.Inf(sign), nsign + n, true
                }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">case 'n', 'N':
                if commonPrefixLenIgnoreCase(s, "nan") == 3 </span><span class="cov0" title="0">{
                        return math.NaN(), 3, true
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return 0, 0, false</span>
}

func (b *decimal) set(s string) (ok bool) <span class="cov0" title="0">{
        i := 0
        b.neg = false
        b.trunc = false

        // optional sign
        if i &gt;= len(s) </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">switch </span>{
        <span class="cov0" title="0">case s[i] == '+':
                i++</span>
        <span class="cov0" title="0">case s[i] == '-':
                b.neg = true
                i++</span>
        }

        // digits
        <span class="cov0" title="0">sawdot := false
        sawdigits := false
        for ; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                switch </span>{
                <span class="cov0" title="0">case s[i] == '_':
                        // readFloat already checked underscores
                        continue</span>
                <span class="cov0" title="0">case s[i] == '.':
                        if sawdot </span><span class="cov0" title="0">{
                                return
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">sawdot = true
                        b.dp = b.nd
                        continue</span>

                <span class="cov0" title="0">case '0' &lt;= s[i] &amp;&amp; s[i] &lt;= '9':
                        sawdigits = true
                        if s[i] == '0' &amp;&amp; b.nd == 0 </span><span class="cov0" title="0">{ // ignore leading zeros
                                b.dp--
                                continue</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">if b.nd &lt; len(b.d) </span><span class="cov0" title="0">{
                                b.d[b.nd] = s[i]
                                b.nd++
                        }</span><span class="cov0" title="0"> else if s[i] != '0' </span><span class="cov0" title="0">{
                                b.trunc = true
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">break</span>
        }
        <span class="cov0" title="0">if !sawdigits </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if !sawdot </span><span class="cov0" title="0">{
                b.dp = b.nd
        }</span><span class="cov0" title="0">
</span>
        // optional exponent moves decimal point.
        // if we read a very large, very long number,
        // just be sure to move the decimal point by
        // a lot (say, 100000).  it doesn't matter if it's
        // not the exact number.
        <span class="cov0" title="0">if i &lt; len(s) &amp;&amp; lower(s[i]) == 'e' </span><span class="cov0" title="0">{
                i++
                if i &gt;= len(s) </span><span class="cov0" title="0">{
                        return
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">esign := 1
                if s[i] == '+' </span><span class="cov0" title="0">{
                        i++
                }</span><span class="cov0" title="0"> else if s[i] == '-' </span><span class="cov0" title="0">{
                        i++
                        esign = -1
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if i &gt;= len(s) || s[i] &lt; '0' || s[i] &gt; '9' </span><span class="cov0" title="0">{
                        return
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">e := 0
                for ; i &lt; len(s) &amp;&amp; ('0' &lt;= s[i] &amp;&amp; s[i] &lt;= '9' || s[i] == '_'); i++ </span><span class="cov0" title="0">{
                        if s[i] == '_' </span><span class="cov0" title="0">{
                                // readFloat already checked underscores
                                continue</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">if e &lt; 10000 </span><span class="cov0" title="0">{
                                e = e*10 + int(s[i]) - '0'
                        }</span><span class="cov0" title="0">
</span>                }
                <span class="cov0" title="0">b.dp += e * esign</span>
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if i != len(s) </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">ok = true
        return</span>
}

// readFloat reads a decimal or hexadecimal mantissa and exponent from a float
// string representation in s; the number may be followed by other characters.
// readFloat reports the number of bytes consumed (i), and whether the number
// is valid (ok).
func readFloat(s string) (mantissa uint64, exp int, neg, trunc, hex bool, i int, ok bool) <span class="cov0" title="0">{
        underscores := false

        // optional sign
        if i &gt;= len(s) </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">switch </span>{
        <span class="cov0" title="0">case s[i] == '+':
                i++</span>
        <span class="cov0" title="0">case s[i] == '-':
                neg = true
                i++</span>
        }

        // digits
        <span class="cov0" title="0">base := uint64(10)
        maxMantDigits := 19 // 10^19 fits in uint64
        expChar := byte('e')
        if i+2 &lt; len(s) &amp;&amp; s[i] == '0' &amp;&amp; lower(s[i+1]) == 'x' </span><span class="cov0" title="0">{
                base = 16
                maxMantDigits = 16 // 16^16 fits in uint64
                i += 2
                expChar = 'p'
                hex = true
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">sawdot := false
        sawdigits := false
        nd := 0
        ndMant := 0
        dp := 0
loop:
        for ; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                switch c := s[i]; true </span>{
                <span class="cov0" title="0">case c == '_':
                        underscores = true
                        continue</span>

                <span class="cov0" title="0">case c == '.':
                        if sawdot </span><span class="cov0" title="0">{
                                break loop</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">sawdot = true
                        dp = nd
                        continue</span>

                <span class="cov0" title="0">case '0' &lt;= c &amp;&amp; c &lt;= '9':
                        sawdigits = true
                        if c == '0' &amp;&amp; nd == 0 </span><span class="cov0" title="0">{ // ignore leading zeros
                                dp--
                                continue</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">nd++
                        if ndMant &lt; maxMantDigits </span><span class="cov0" title="0">{
                                mantissa *= base
                                mantissa += uint64(c - '0')
                                ndMant++
                        }</span><span class="cov0" title="0"> else if c != '0' </span><span class="cov0" title="0">{
                                trunc = true
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">continue</span>

                <span class="cov0" title="0">case base == 16 &amp;&amp; 'a' &lt;= lower(c) &amp;&amp; lower(c) &lt;= 'f':
                        sawdigits = true
                        nd++
                        if ndMant &lt; maxMantDigits </span><span class="cov0" title="0">{
                                mantissa *= 16
                                mantissa += uint64(lower(c) - 'a' + 10)
                                ndMant++
                        }</span><span class="cov0" title="0"> else {
                                trunc = true
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">break</span>
        }
        <span class="cov0" title="0">if !sawdigits </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if !sawdot </span><span class="cov0" title="0">{
                dp = nd
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if base == 16 </span><span class="cov0" title="0">{
                dp *= 4
                ndMant *= 4
        }</span><span class="cov0" title="0">
</span>
        // optional exponent moves decimal point.
        // if we read a very large, very long number,
        // just be sure to move the decimal point by
        // a lot (say, 100000).  it doesn't matter if it's
        // not the exact number.
        <span class="cov0" title="0">if i &lt; len(s) &amp;&amp; lower(s[i]) == expChar </span><span class="cov0" title="0">{
                i++
                if i &gt;= len(s) </span><span class="cov0" title="0">{
                        return
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">esign := 1
                if s[i] == '+' </span><span class="cov0" title="0">{
                        i++
                }</span><span class="cov0" title="0"> else if s[i] == '-' </span><span class="cov0" title="0">{
                        i++
                        esign = -1
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if i &gt;= len(s) || s[i] &lt; '0' || s[i] &gt; '9' </span><span class="cov0" title="0">{
                        return
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">e := 0
                for ; i &lt; len(s) &amp;&amp; ('0' &lt;= s[i] &amp;&amp; s[i] &lt;= '9' || s[i] == '_'); i++ </span><span class="cov0" title="0">{
                        if s[i] == '_' </span><span class="cov0" title="0">{
                                underscores = true
                                continue</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">if e &lt; 10000 </span><span class="cov0" title="0">{
                                e = e*10 + int(s[i]) - '0'
                        }</span><span class="cov0" title="0">
</span>                }
                <span class="cov0" title="0">dp += e * esign</span>
        }<span class="cov0" title="0"> else if base == 16 </span><span class="cov0" title="0">{
                // Must have exponent.
                return
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if mantissa != 0 </span><span class="cov0" title="0">{
                exp = dp - ndMant
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if underscores &amp;&amp; !underscoreOK(s[:i]) </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">ok = true
        return</span>
}

// decimal power of ten to binary power of two.
var powtab = []int{1, 3, 6, 9, 13, 16, 19, 23, 26}

func (d *decimal) floatBits(flt *floatInfo) (b uint64, overflow bool) <span class="cov0" title="0">{
        var exp int
        var mant uint64

        // Zero is always a special case.
        if d.nd == 0 </span><span class="cov0" title="0">{
                mant = 0
                exp = flt.bias
                goto out</span>
        }<span class="cov0" title="0">
</span>
        // Obvious overflow/underflow.
        // These bounds are for 64-bit floats.
        // Will have to change if we want to support 80-bit floats in the future.
        <span class="cov0" title="0">if d.dp &gt; 310 </span><span class="cov0" title="0">{
                goto overflow</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if d.dp &lt; -330 </span><span class="cov0" title="0">{
                // zero
                mant = 0
                exp = flt.bias
                goto out</span>
        }<span class="cov0" title="0">
</span>
        // Scale by powers of two until in range [0.5, 1.0)
        <span class="cov0" title="0">exp = 0
        for d.dp &gt; 0 </span><span class="cov0" title="0">{
                var n int
                if d.dp &gt;= len(powtab) </span><span class="cov0" title="0">{
                        n = 27
                }</span><span class="cov0" title="0"> else {
                        n = powtab[d.dp]
                }</span>
                <span class="cov0" title="0">d.Shift(-n)
                exp += n</span>
        }
        <span class="cov0" title="0">for d.dp &lt; 0 || d.dp == 0 &amp;&amp; d.d[0] &lt; '5' </span><span class="cov0" title="0">{
                var n int
                if -d.dp &gt;= len(powtab) </span><span class="cov0" title="0">{
                        n = 27
                }</span><span class="cov0" title="0"> else {
                        n = powtab[-d.dp]
                }</span>
                <span class="cov0" title="0">d.Shift(n)
                exp -= n</span>
        }

        // Our range is [0.5,1) but floating point range is [1,2).
        <span class="cov0" title="0">exp--

        // Minimum representable exponent is flt.bias+1.
        // If the exponent is smaller, move it up and
        // adjust d accordingly.
        if exp &lt; flt.bias+1 </span><span class="cov0" title="0">{
                n := flt.bias + 1 - exp
                d.Shift(-n)
                exp += n
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if exp-flt.bias &gt;= 1&lt;&lt;flt.expbits-1 </span><span class="cov0" title="0">{
                goto overflow</span>
        }<span class="cov0" title="0">
</span>
        // Extract 1+flt.mantbits bits.
        <span class="cov0" title="0">d.Shift(int(1 + flt.mantbits))
        mant = d.RoundedInteger()

        // Rounding might have added a bit; shift down.
        if mant == 2&lt;&lt;flt.mantbits </span><span class="cov0" title="0">{
                mant &gt;&gt;= 1
                exp++
                if exp-flt.bias &gt;= 1&lt;&lt;flt.expbits-1 </span><span class="cov0" title="0">{
                        goto overflow</span>
                }<span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>
        // Denormalized?
        <span class="cov0" title="0">if mant&amp;(1&lt;&lt;flt.mantbits) == 0 </span><span class="cov0" title="0">{
                exp = flt.bias
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">goto out</span>

<span class="cov0" title="0">overflow:
        // ±Inf
        mant = 0
        exp = 1&lt;&lt;flt.expbits - 1 + flt.bias
        overflow = true

out:
        // Assemble bits.
        bits := mant &amp; (uint64(1)&lt;&lt;flt.mantbits - 1)
        bits |= uint64((exp-flt.bias)&amp;(1&lt;&lt;flt.expbits-1)) &lt;&lt; flt.mantbits
        if d.neg </span><span class="cov0" title="0">{
                bits |= 1 &lt;&lt; flt.mantbits &lt;&lt; flt.expbits
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return bits, overflow</span>
}

// Exact powers of 10.
var float64pow10 = []float64{
        1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,
        1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,
        1e20, 1e21, 1e22,
}
var float32pow10 = []float32{1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10}

// If possible to convert decimal representation to 64-bit float f exactly,
// entirely in floating-point math, do so, avoiding the expense of decimalToFloatBits.
// Three common cases:
//        value is exact integer
//        value is exact integer * exact power of ten
//        value is exact integer / exact power of ten
// These all produce potentially inexact but correctly rounded answers.
func atof64exact(mantissa uint64, exp int, neg bool) (f float64, ok bool) <span class="cov0" title="0">{
        if mantissa&gt;&gt;float64info.mantbits != 0 </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">f = float64(mantissa)
        if neg </span><span class="cov0" title="0">{
                f = -f
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">switch </span>{
        <span class="cov0" title="0">case exp == 0:
                // an integer.
                return f, true</span>
        // Exact integers are &lt;= 10^15.
        // Exact powers of ten are &lt;= 10^22.
        <span class="cov0" title="0">case exp &gt; 0 &amp;&amp; exp &lt;= 15+22: // int * 10^k
                // If exponent is big but number of digits is not,
                // can move a few zeros into the integer part.
                if exp &gt; 22 </span><span class="cov0" title="0">{
                        f *= float64pow10[exp-22]
                        exp = 22
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if f &gt; 1e15 || f &lt; -1e15 </span><span class="cov0" title="0">{
                        // the exponent was really too large.
                        return
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return f * float64pow10[exp], true</span>
        <span class="cov0" title="0">case exp &lt; 0 &amp;&amp; exp &gt;= -22: // int / 10^k
                return f / float64pow10[-exp], true</span>
        }
        <span class="cov0" title="0">return</span>
}

// If possible to compute mantissa*10^exp to 32-bit float f exactly,
// entirely in floating-point math, do so, avoiding the machinery above.
func atof32exact(mantissa uint64, exp int, neg bool) (f float32, ok bool) <span class="cov0" title="0">{
        if mantissa&gt;&gt;float32info.mantbits != 0 </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">f = float32(mantissa)
        if neg </span><span class="cov0" title="0">{
                f = -f
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">switch </span>{
        <span class="cov0" title="0">case exp == 0:
                return f, true</span>
        // Exact integers are &lt;= 10^7.
        // Exact powers of ten are &lt;= 10^10.
        <span class="cov0" title="0">case exp &gt; 0 &amp;&amp; exp &lt;= 7+10: // int * 10^k
                // If exponent is big but number of digits is not,
                // can move a few zeros into the integer part.
                if exp &gt; 10 </span><span class="cov0" title="0">{
                        f *= float32pow10[exp-10]
                        exp = 10
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if f &gt; 1e7 || f &lt; -1e7 </span><span class="cov0" title="0">{
                        // the exponent was really too large.
                        return
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return f * float32pow10[exp], true</span>
        <span class="cov0" title="0">case exp &lt; 0 &amp;&amp; exp &gt;= -10: // int / 10^k
                return f / float32pow10[-exp], true</span>
        }
        <span class="cov0" title="0">return</span>
}

// atofHex converts the hex floating-point string s
// to a rounded float32 or float64 value (depending on flt==&amp;float32info or flt==&amp;float64info)
// and returns it as a float64.
// The string s has already been parsed into a mantissa, exponent, and sign (neg==true for negative).
// If trunc is true, trailing non-zero bits have been omitted from the mantissa.
func atofHex(s string, flt *floatInfo, mantissa uint64, exp int, neg, trunc bool) (float64, error) <span class="cov0" title="0">{
        maxExp := 1&lt;&lt;flt.expbits + flt.bias - 2
        minExp := flt.bias + 1
        exp += int(flt.mantbits) // mantissa now implicitly divided by 2^mantbits.

        // Shift mantissa and exponent to bring representation into float range.
        // Eventually we want a mantissa with a leading 1-bit followed by mantbits other bits.
        // For rounding, we need two more, where the bottom bit represents
        // whether that bit or any later bit was non-zero.
        // (If the mantissa has already lost non-zero bits, trunc is true,
        // and we OR in a 1 below after shifting left appropriately.)
        for mantissa != 0 &amp;&amp; mantissa&gt;&gt;(flt.mantbits+2) == 0 </span><span class="cov0" title="0">{
                mantissa &lt;&lt;= 1
                exp--
        }</span>
        <span class="cov0" title="0">if trunc </span><span class="cov0" title="0">{
                mantissa |= 1
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">for mantissa&gt;&gt;(1+flt.mantbits+2) != 0 </span><span class="cov0" title="0">{
                mantissa = mantissa&gt;&gt;1 | mantissa&amp;1
                exp++
        }</span>

        // If exponent is too negative,
        // denormalize in hopes of making it representable.
        // (The -2 is for the rounding bits.)
        <span class="cov0" title="0">for mantissa &gt; 1 &amp;&amp; exp &lt; minExp-2 </span><span class="cov0" title="0">{
                mantissa = mantissa&gt;&gt;1 | mantissa&amp;1
                exp++
        }</span>

        // Round using two bottom bits.
        <span class="cov0" title="0">round := mantissa &amp; 3
        mantissa &gt;&gt;= 2
        round |= mantissa &amp; 1 // round to even (round up if mantissa is odd)
        exp += 2
        if round == 3 </span><span class="cov0" title="0">{
                mantissa++
                if mantissa == 1&lt;&lt;(1+flt.mantbits) </span><span class="cov0" title="0">{
                        mantissa &gt;&gt;= 1
                        exp++
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if mantissa&gt;&gt;flt.mantbits == 0 </span><span class="cov0" title="0">{ // Denormal or zero.
                exp = flt.bias
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">var err error
        if exp &gt; maxExp </span><span class="cov0" title="0">{ // infinity and range error
                mantissa = 1 &lt;&lt; flt.mantbits
                exp = maxExp + 1
                err = rangeError(fnParseFloat, s)
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">bits := mantissa &amp; (1&lt;&lt;flt.mantbits - 1)
        bits |= uint64((exp-flt.bias)&amp;(1&lt;&lt;flt.expbits-1)) &lt;&lt; flt.mantbits
        if neg </span><span class="cov0" title="0">{
                bits |= 1 &lt;&lt; flt.mantbits &lt;&lt; flt.expbits
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if flt == &amp;float32info </span><span class="cov0" title="0">{
                return float64(math.Float32frombits(uint32(bits))), err
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return math.Float64frombits(bits), err</span>
}

const fnParseFloat = "ParseFloat"

func atof32(s string) (f float32, n int, err error) <span class="cov0" title="0">{
        if val, n, ok := special(s); ok </span><span class="cov0" title="0">{
                return float32(val), n, nil
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">mantissa, exp, neg, trunc, hex, n, ok := readFloat(s)
        if !ok </span><span class="cov0" title="0">{
                return 0, n, syntaxError(fnParseFloat, s)
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if hex </span><span class="cov0" title="0">{
                f, err := atofHex(s[:n], &amp;float32info, mantissa, exp, neg, trunc)
                return float32(f), n, err
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if optimize </span><span class="cov8" title="1">{
                // Try pure floating-point arithmetic conversion.
                if !trunc </span><span class="cov0" title="0">{
                        if f, ok := atof32exact(mantissa, exp, neg); ok </span><span class="cov0" title="0">{
                                return f, n, nil
                        }</span><span class="cov0" title="0">
</span>                }<span class="cov0" title="0">
</span>                // Try another fast path.
                <span class="cov0" title="0">ext := new(extFloat)
                if ok := ext.AssignDecimal(mantissa, exp, neg, trunc, &amp;float32info); ok </span><span class="cov0" title="0">{
                        b, ovf := ext.floatBits(&amp;float32info)
                        f = math.Float32frombits(uint32(b))
                        if ovf </span><span class="cov0" title="0">{
                                err = rangeError(fnParseFloat, s)
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">return f, n, err</span>
                }<span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>
        // Slow fallback.
        <span class="cov0" title="0">var d decimal
        if !d.set(s[:n]) </span><span class="cov0" title="0">{
                return 0, n, syntaxError(fnParseFloat, s)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">b, ovf := d.floatBits(&amp;float32info)
        f = math.Float32frombits(uint32(b))
        if ovf </span><span class="cov0" title="0">{
                err = rangeError(fnParseFloat, s)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return f, n, err</span>
}

func atof64(s string) (f float64, n int, err error) <span class="cov0" title="0">{
        if val, n, ok := special(s); ok </span><span class="cov0" title="0">{
                return val, n, nil
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">mantissa, exp, neg, trunc, hex, n, ok := readFloat(s)
        if !ok </span><span class="cov0" title="0">{
                return 0, n, syntaxError(fnParseFloat, s)
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if hex </span><span class="cov0" title="0">{
                f, err := atofHex(s[:n], &amp;float64info, mantissa, exp, neg, trunc)
                return f, n, err
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if optimize </span><span class="cov0" title="0">{
                // Try pure floating-point arithmetic conversion.
                if !trunc </span><span class="cov0" title="0">{
                        if f, ok := atof64exact(mantissa, exp, neg); ok </span><span class="cov0" title="0">{
                                return f, n, nil
                        }</span><span class="cov0" title="0">
</span>                }<span class="cov0" title="0">
</span>                // Try another fast path.
                <span class="cov0" title="0">ext := new(extFloat)
                if ok := ext.AssignDecimal(mantissa, exp, neg, trunc, &amp;float64info); ok </span><span class="cov0" title="0">{
                        b, ovf := ext.floatBits(&amp;float64info)
                        f = math.Float64frombits(b)
                        if ovf </span><span class="cov0" title="0">{
                                err = rangeError(fnParseFloat, s)
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">return f, n, err</span>
                }<span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>
        // Slow fallback.
        <span class="cov0" title="0">var d decimal
        if !d.set(s[:n]) </span><span class="cov0" title="0">{
                return 0, n, syntaxError(fnParseFloat, s)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">b, ovf := d.floatBits(&amp;float64info)
        f = math.Float64frombits(b)
        if ovf </span><span class="cov0" title="0">{
                err = rangeError(fnParseFloat, s)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return f, n, err</span>
}

// ParseFloat converts the string s to a floating-point number
// with the precision specified by bitSize: 32 for float32, or 64 for float64.
// When bitSize=32, the result still has type float64, but it will be
// convertible to float32 without changing its value.
//
// ParseFloat accepts decimal and hexadecimal floating-point number syntax.
// If s is well-formed and near a valid floating-point number,
// ParseFloat returns the nearest floating-point number rounded
// using IEEE754 unbiased rounding.
// (Parsing a hexadecimal floating-point value only rounds when
// there are more bits in the hexadecimal representation than
// will fit in the mantissa.)
//
// The errors that ParseFloat returns have concrete type *NumError
// and include err.Num = s.
//
// If s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.
//
// If s is syntactically well-formed but is more than 1/2 ULP
// away from the largest floating point number of the given size,
// ParseFloat returns f = ±Inf, err.Err = ErrRange.
//
// ParseFloat recognizes the strings "NaN", and the (possibly signed) strings "Inf" and "Infinity"
// as their respective special floating point values. It ignores case when matching.
func ParseFloat(s string, bitSize int) (float64, error) <span class="cov0" title="0">{
        f, n, err := parseFloatPrefix(s, bitSize)
        if err == nil &amp;&amp; n != len(s) </span><span class="cov0" title="0">{
                return 0, syntaxError(fnParseFloat, s)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return f, err</span>
}

func parseFloatPrefix(s string, bitSize int) (float64, int, error) <span class="cov0" title="0">{
        if bitSize == 32 </span><span class="cov0" title="0">{
                f, n, err := atof32(s)
                return float64(f), n, err
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return atof64(s)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Multiprecision decimal numbers.
// For floating-point formatting only; not general purpose.
// Only operations are assign and (binary) left/right shift.
// Can do binary floating point in multiprecision decimal precisely
// because 2 divides 10; cannot do decimal floating point
// in multiprecision binary precisely.

package strconv

type decimal struct {
        d     [800]byte // digits, big-endian representation
        nd    int       // number of digits used
        dp    int       // decimal point
        neg   bool      // negative flag
        trunc bool      // discarded nonzero digits beyond d[:nd]
}

func (a *decimal) String() string <span class="cov0" title="0">{
        n := 10 + a.nd
        if a.dp &gt; 0 </span><span class="cov0" title="0">{
                n += a.dp
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if a.dp &lt; 0 </span><span class="cov0" title="0">{
                n += -a.dp
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">buf := make([]byte, n)
        w := 0
        switch </span>{
        <span class="cov0" title="0">case a.nd == 0:
                return "0"</span>

        <span class="cov0" title="0">case a.dp &lt;= 0:
                // zeros fill space between decimal point and digits
                buf[w] = '0'
                w++
                buf[w] = '.'
                w++
                w += digitZero(buf[w : w+-a.dp])
                w += copy(buf[w:], a.d[0:a.nd])</span>

        <span class="cov0" title="0">case a.dp &lt; a.nd:
                // decimal point in middle of digits
                w += copy(buf[w:], a.d[0:a.dp])
                buf[w] = '.'
                w++
                w += copy(buf[w:], a.d[a.dp:a.nd])</span>

        <span class="cov0" title="0">default:
                // zeros fill space between digits and decimal point
                w += copy(buf[w:], a.d[0:a.nd])
                w += digitZero(buf[w : w+a.dp-a.nd])</span>
        }
        <span class="cov0" title="0">return string(buf[0:w])</span>
}

func digitZero(dst []byte) int <span class="cov0" title="0">{
        for i := range dst </span><span class="cov0" title="0">{
                dst[i] = '0'
        }</span>
        <span class="cov0" title="0">return len(dst)</span>
}

// trim trailing zeros from number.
// (They are meaningless; the decimal point is tracked
// independent of the number of digits.)
func trim(a *decimal) <span class="cov0" title="0">{
        for a.nd &gt; 0 &amp;&amp; a.d[a.nd-1] == '0' </span><span class="cov0" title="0">{
                a.nd--
        }</span>
        <span class="cov0" title="0">if a.nd == 0 </span><span class="cov0" title="0">{
                a.dp = 0
        }</span><span class="cov0" title="0">
</span>}

// Assign v to a.
func (a *decimal) Assign(v uint64) <span class="cov0" title="0">{
        var buf [24]byte

        // Write reversed decimal in buf.
        n := 0
        for v &gt; 0 </span><span class="cov0" title="0">{
                v1 := v / 10
                v -= 10 * v1
                buf[n] = byte(v + '0')
                n++
                v = v1
        }</span>

        // Reverse again to produce forward decimal in a.d.
        <span class="cov0" title="0">a.nd = 0
        for n--; n &gt;= 0; n-- </span><span class="cov0" title="0">{
                a.d[a.nd] = buf[n]
                a.nd++
        }</span>
        <span class="cov0" title="0">a.dp = a.nd
        trim(a)</span>
}

// Maximum shift that we can do in one pass without overflow.
// A uint has 32 or 64 bits, and we have to be able to accommodate 9&lt;&lt;k.
const uintSize = 32 &lt;&lt; (^uint(0) &gt;&gt; 63)
const maxShift = uintSize - 4

// Binary shift right (/ 2) by k bits.  k &lt;= maxShift to avoid overflow.
func rightShift(a *decimal, k uint) <span class="cov0" title="0">{
        r := 0 // read pointer
        w := 0 // write pointer

        // Pick up enough leading digits to cover first shift.
        var n uint
        for ; n&gt;&gt;k == 0; r++ </span><span class="cov0" title="0">{
                if r &gt;= a.nd </span><span class="cov0" title="0">{
                        if n == 0 </span><span class="cov0" title="0">{
                                // a == 0; shouldn't get here, but handle anyway.
                                a.nd = 0
                                return
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">for n&gt;&gt;k == 0 </span><span class="cov0" title="0">{
                                n = n * 10
                                r++
                        }</span>
                        <span class="cov0" title="0">break</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">c := uint(a.d[r])
                n = n*10 + c - '0'</span>
        }
        <span class="cov0" title="0">a.dp -= r - 1

        var mask uint = (1 &lt;&lt; k) - 1

        // Pick up a digit, put down a digit.
        for ; r &lt; a.nd; r++ </span><span class="cov0" title="0">{
                c := uint(a.d[r])
                dig := n &gt;&gt; k
                n &amp;= mask
                a.d[w] = byte(dig + '0')
                w++
                n = n*10 + c - '0'
        }</span>

        // Put down extra digits.
        <span class="cov0" title="0">for n &gt; 0 </span><span class="cov0" title="0">{
                dig := n &gt;&gt; k
                n &amp;= mask
                if w &lt; len(a.d) </span><span class="cov0" title="0">{
                        a.d[w] = byte(dig + '0')
                        w++
                }</span><span class="cov0" title="0"> else if dig &gt; 0 </span><span class="cov0" title="0">{
                        a.trunc = true
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">n = n * 10</span>
        }

        <span class="cov0" title="0">a.nd = w
        trim(a)</span>
}

// Cheat sheet for left shift: table indexed by shift count giving
// number of new digits that will be introduced by that shift.
//
// For example, leftcheats[4] = {2, "625"}.  That means that
// if we are shifting by 4 (multiplying by 16), it will add 2 digits
// when the string prefix is "625" through "999", and one fewer digit
// if the string prefix is "000" through "624".
//
// Credit for this trick goes to Ken.

type leftCheat struct {
        delta  int    // number of new digits
        cutoff string // minus one digit if original &lt; a.
}

var leftcheats = []leftCheat{
        // Leading digits of 1/2^i = 5^i.
        // 5^23 is not an exact 64-bit floating point number,
        // so have to use bc for the math.
        // Go up to 60 to be large enough for 32bit and 64bit platforms.
        /*
                seq 60 | sed 's/^/5^/' | bc |
                awk 'BEGIN{ print "\t{ 0, \"\" }," }
                {
                        log2 = log(2)/log(10)
                        printf("\t{ %d, \"%s\" },\t// * %d\n",
                                int(log2*NR+1), $0, 2**NR)
                }'
        */
        {0, ""},
        {1, "5"},                                           // * 2
        {1, "25"},                                          // * 4
        {1, "125"},                                         // * 8
        {2, "625"},                                         // * 16
        {2, "3125"},                                        // * 32
        {2, "15625"},                                       // * 64
        {3, "78125"},                                       // * 128
        {3, "390625"},                                      // * 256
        {3, "1953125"},                                     // * 512
        {4, "9765625"},                                     // * 1024
        {4, "48828125"},                                    // * 2048
        {4, "244140625"},                                   // * 4096
        {4, "1220703125"},                                  // * 8192
        {5, "6103515625"},                                  // * 16384
        {5, "30517578125"},                                 // * 32768
        {5, "152587890625"},                                // * 65536
        {6, "762939453125"},                                // * 131072
        {6, "3814697265625"},                               // * 262144
        {6, "19073486328125"},                              // * 524288
        {7, "95367431640625"},                              // * 1048576
        {7, "476837158203125"},                             // * 2097152
        {7, "2384185791015625"},                            // * 4194304
        {7, "11920928955078125"},                           // * 8388608
        {8, "59604644775390625"},                           // * 16777216
        {8, "298023223876953125"},                          // * 33554432
        {8, "1490116119384765625"},                         // * 67108864
        {9, "7450580596923828125"},                         // * 134217728
        {9, "37252902984619140625"},                        // * 268435456
        {9, "186264514923095703125"},                       // * 536870912
        {10, "931322574615478515625"},                      // * 1073741824
        {10, "4656612873077392578125"},                     // * 2147483648
        {10, "23283064365386962890625"},                    // * 4294967296
        {10, "116415321826934814453125"},                   // * 8589934592
        {11, "582076609134674072265625"},                   // * 17179869184
        {11, "2910383045673370361328125"},                  // * 34359738368
        {11, "14551915228366851806640625"},                 // * 68719476736
        {12, "72759576141834259033203125"},                 // * 137438953472
        {12, "363797880709171295166015625"},                // * 274877906944
        {12, "1818989403545856475830078125"},               // * 549755813888
        {13, "9094947017729282379150390625"},               // * 1099511627776
        {13, "45474735088646411895751953125"},              // * 2199023255552
        {13, "227373675443232059478759765625"},             // * 4398046511104
        {13, "1136868377216160297393798828125"},            // * 8796093022208
        {14, "5684341886080801486968994140625"},            // * 17592186044416
        {14, "28421709430404007434844970703125"},           // * 35184372088832
        {14, "142108547152020037174224853515625"},          // * 70368744177664
        {15, "710542735760100185871124267578125"},          // * 140737488355328
        {15, "3552713678800500929355621337890625"},         // * 281474976710656
        {15, "17763568394002504646778106689453125"},        // * 562949953421312
        {16, "88817841970012523233890533447265625"},        // * 1125899906842624
        {16, "444089209850062616169452667236328125"},       // * 2251799813685248
        {16, "2220446049250313080847263336181640625"},      // * 4503599627370496
        {16, "11102230246251565404236316680908203125"},     // * 9007199254740992
        {17, "55511151231257827021181583404541015625"},     // * 18014398509481984
        {17, "277555756156289135105907917022705078125"},    // * 36028797018963968
        {17, "1387778780781445675529539585113525390625"},   // * 72057594037927936
        {18, "6938893903907228377647697925567626953125"},   // * 144115188075855872
        {18, "34694469519536141888238489627838134765625"},  // * 288230376151711744
        {18, "173472347597680709441192448139190673828125"}, // * 576460752303423488
        {19, "867361737988403547205962240695953369140625"}, // * 1152921504606846976
}

// Is the leading prefix of b lexicographically less than s?
func prefixIsLessThan(b []byte, s string) bool <span class="cov0" title="0">{
        for i := 0; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                if i &gt;= len(b) </span><span class="cov0" title="0">{
                        return true
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if b[i] != s[i] </span><span class="cov0" title="0">{
                        return b[i] &lt; s[i]
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return false</span>
}

// Binary shift left (* 2) by k bits.  k &lt;= maxShift to avoid overflow.
func leftShift(a *decimal, k uint) <span class="cov0" title="0">{
        delta := leftcheats[k].delta
        if prefixIsLessThan(a.d[0:a.nd], leftcheats[k].cutoff) </span><span class="cov0" title="0">{
                delta--
        }</span><span class="cov8" title="1">
</span>
        <span class="cov0" title="0">r := a.nd         // read index
        w := a.nd + delta // write index

        // Pick up a digit, put down a digit.
        var n uint
        for r--; r &gt;= 0; r-- </span><span class="cov0" title="0">{
                n += (uint(a.d[r]) - '0') &lt;&lt; k
                quo := n / 10
                rem := n - 10*quo
                w--
                if w &lt; len(a.d) </span><span class="cov0" title="0">{
                        a.d[w] = byte(rem + '0')
                }</span><span class="cov0" title="0"> else if rem != 0 </span><span class="cov0" title="0">{
                        a.trunc = true
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">n = quo</span>
        }

        // Put down extra digits.
        <span class="cov0" title="0">for n &gt; 0 </span><span class="cov0" title="0">{
                quo := n / 10
                rem := n - 10*quo
                w--
                if w &lt; len(a.d) </span><span class="cov0" title="0">{
                        a.d[w] = byte(rem + '0')
                }</span><span class="cov0" title="0"> else if rem != 0 </span><span class="cov0" title="0">{
                        a.trunc = true
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">n = quo</span>
        }

        <span class="cov0" title="0">a.nd += delta
        if a.nd &gt;= len(a.d) </span><span class="cov0" title="0">{
                a.nd = len(a.d)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">a.dp += delta
        trim(a)</span>
}

// Binary shift left (k &gt; 0) or right (k &lt; 0).
func (a *decimal) Shift(k int) <span class="cov0" title="0">{
        switch </span>{
        <span class="cov0" title="0">case a.nd == 0:</span>
                // nothing to do: a == 0
        <span class="cov0" title="0">case k &gt; 0:
                for k &gt; maxShift </span><span class="cov0" title="0">{
                        leftShift(a, maxShift)
                        k -= maxShift
                }</span>
                <span class="cov0" title="0">leftShift(a, uint(k))</span>
        <span class="cov0" title="0">case k &lt; 0:
                for k &lt; -maxShift </span><span class="cov0" title="0">{
                        rightShift(a, maxShift)
                        k += maxShift
                }</span>
                <span class="cov0" title="0">rightShift(a, uint(-k))</span>
        }
}

// If we chop a at nd digits, should we round up?
func shouldRoundUp(a *decimal, nd int) bool <span class="cov0" title="0">{
        if nd &lt; 0 || nd &gt;= a.nd </span><span class="cov0" title="0">{
                return false
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if a.d[nd] == '5' &amp;&amp; nd+1 == a.nd </span><span class="cov0" title="0">{ // exactly halfway - round to even
                // if we truncated, a little higher than what's recorded - always round up
                if a.trunc </span><span class="cov0" title="0">{
                        return true
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return nd &gt; 0 &amp;&amp; (a.d[nd-1]-'0')%2 != 0</span>
        }<span class="cov0" title="0">
</span>        // not halfway - digit tells all
        <span class="cov0" title="0">return a.d[nd] &gt;= '5'</span>
}

// Round a to nd digits (or fewer).
// If nd is zero, it means we're rounding
// just to the left of the digits, as in
// 0.09 -&gt; 0.1.
func (a *decimal) Round(nd int) <span class="cov0" title="0">{
        if nd &lt; 0 || nd &gt;= a.nd </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if shouldRoundUp(a, nd) </span><span class="cov0" title="0">{
                a.RoundUp(nd)
        }</span><span class="cov0" title="0"> else {
                a.RoundDown(nd)
        }</span>
}

// Round a down to nd digits (or fewer).
func (a *decimal) RoundDown(nd int) <span class="cov0" title="0">{
        if nd &lt; 0 || nd &gt;= a.nd </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">a.nd = nd
        trim(a)</span>
}

// Round a up to nd digits (or fewer).
func (a *decimal) RoundUp(nd int) <span class="cov0" title="0">{
        if nd &lt; 0 || nd &gt;= a.nd </span><span class="cov0" title="0">{
                return
        }</span><span class="cov0" title="0">
</span>
        // round up
        <span class="cov0" title="0">for i := nd - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                c := a.d[i]
                if c &lt; '9' </span><span class="cov0" title="0">{ // can stop after this digit
                        a.d[i]++
                        a.nd = i + 1
                        return
                }</span><span class="cov0" title="0">
</span>        }

        // Number is all 9s.
        // Change to single 1 with adjusted decimal point.
        <span class="cov0" title="0">a.d[0] = '1'
        a.nd = 1
        a.dp++</span>
}

// Extract integer part, rounded appropriately.
// No guarantees about overflow.
func (a *decimal) RoundedInteger() uint64 <span class="cov0" title="0">{
        if a.dp &gt; 20 </span><span class="cov0" title="0">{
                return 0xFFFFFFFFFFFFFFFF
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">var i int
        n := uint64(0)
        for i = 0; i &lt; a.dp &amp;&amp; i &lt; a.nd; i++ </span><span class="cov0" title="0">{
                n = n*10 + uint64(a.d[i]-'0')
        }</span>
        <span class="cov0" title="0">for ; i &lt; a.dp; i++ </span><span class="cov0" title="0">{
                n *= 10
        }</span>
        <span class="cov0" title="0">if shouldRoundUp(a, a.dp) </span><span class="cov0" title="0">{
                n++
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return n</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Binary to decimal floating point conversion.
// Algorithm:
//   1) store mantissa in multiprecision decimal
//   2) shift decimal by exponent
//   3) read digits out &amp; format

package strconv

import "math"

// TODO: move elsewhere?
type floatInfo struct {
        mantbits uint
        expbits  uint
        bias     int
}

var float32info = floatInfo{23, 8, -127}
var float64info = floatInfo{52, 11, -1023}

// FormatFloat converts the floating-point number f to a string,
// according to the format fmt and precision prec. It rounds the
// result assuming that the original was obtained from a floating-point
// value of bitSize bits (32 for float32, 64 for float64).
//
// The format fmt is one of
// 'b' (-ddddp±ddd, a binary exponent),
// 'e' (-d.dddde±dd, a decimal exponent),
// 'E' (-d.ddddE±dd, a decimal exponent),
// 'f' (-ddd.dddd, no exponent),
// 'g' ('e' for large exponents, 'f' otherwise),
// 'G' ('E' for large exponents, 'f' otherwise),
// 'x' (-0xd.ddddp±ddd, a hexadecimal fraction and binary exponent), or
// 'X' (-0Xd.ddddP±ddd, a hexadecimal fraction and binary exponent).
//
// The precision prec controls the number of digits (excluding the exponent)
// printed by the 'e', 'E', 'f', 'g', 'G', 'x', and 'X' formats.
// For 'e', 'E', 'f', 'x', and 'X', it is the number of digits after the decimal point.
// For 'g' and 'G' it is the maximum number of significant digits (trailing
// zeros are removed).
// The special precision -1 uses the smallest number of digits
// necessary such that ParseFloat will return f exactly.
func FormatFloat(f float64, fmt byte, prec, bitSize int) string <span class="cov0" title="0">{
        return string(genericFtoa(make([]byte, 0, max(prec+4, 24)), f, fmt, prec, bitSize))
}</span>

// AppendFloat appends the string form of the floating-point number f,
// as generated by FormatFloat, to dst and returns the extended buffer.
func AppendFloat(dst []byte, f float64, fmt byte, prec, bitSize int) []byte <span class="cov0" title="0">{
        return genericFtoa(dst, f, fmt, prec, bitSize)
}</span>

func genericFtoa(dst []byte, val float64, fmt byte, prec, bitSize int) []byte <span class="cov0" title="0">{
        var bits uint64
        var flt *floatInfo
        switch bitSize </span>{
        <span class="cov0" title="0">case 32:
                bits = uint64(math.Float32bits(float32(val)))
                flt = &amp;float32info</span>
        <span class="cov0" title="0">case 64:
                bits = math.Float64bits(val)
                flt = &amp;float64info</span>
        <span class="cov0" title="0">default:
                panic("strconv: illegal AppendFloat/FormatFloat bitSize")</span>
        }

        <span class="cov0" title="0">neg := bits&gt;&gt;(flt.expbits+flt.mantbits) != 0
        exp := int(bits&gt;&gt;flt.mantbits) &amp; (1&lt;&lt;flt.expbits - 1)
        mant := bits &amp; (uint64(1)&lt;&lt;flt.mantbits - 1)

        switch exp </span>{
        <span class="cov0" title="0">case 1&lt;&lt;flt.expbits - 1:
                // Inf, NaN
                var s string
                switch </span>{
                <span class="cov0" title="0">case mant != 0:
                        s = "NaN"</span>
                <span class="cov0" title="0">case neg:
                        s = "-Inf"</span>
                <span class="cov0" title="0">default:
                        s = "+Inf"</span>
                }
                <span class="cov0" title="0">return append(dst, s...)</span>

        <span class="cov0" title="0">case 0:
                // denormalized
                exp++</span>

        <span class="cov0" title="0">default:
                // add implicit top bit
                mant |= uint64(1) &lt;&lt; flt.mantbits</span>
        }
        <span class="cov0" title="0">exp += flt.bias

        // Pick off easy binary, hex formats.
        if fmt == 'b' </span><span class="cov0" title="0">{
                return fmtB(dst, neg, mant, exp, flt)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if fmt == 'x' || fmt == 'X' </span><span class="cov0" title="0">{
                return fmtX(dst, prec, fmt, neg, mant, exp, flt)
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if !optimize </span><span class="cov0" title="0">{
                return bigFtoa(dst, prec, fmt, neg, mant, exp, flt)
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">var digs decimalSlice
        ok := false
        // Negative precision means "only as much as needed to be exact."
        shortest := prec &lt; 0
        if shortest </span><span class="cov0" title="0">{
                // Try Grisu3 algorithm.
                f := new(extFloat)
                lower, upper := f.AssignComputeBounds(mant, exp, neg, flt)
                var buf [32]byte
                digs.d = buf[:]
                ok = f.ShortestDecimal(&amp;digs, &amp;lower, &amp;upper)
                if !ok </span><span class="cov0" title="0">{
                        return bigFtoa(dst, prec, fmt, neg, mant, exp, flt)
                }</span><span class="cov0" title="0">
</span>                // Precision for shortest representation mode.
                <span class="cov0" title="0">switch fmt </span>{
                <span class="cov0" title="0">case 'e', 'E':
                        prec = max(digs.nd-1, 0)</span>
                <span class="cov0" title="0">case 'f':
                        prec = max(digs.nd-digs.dp, 0)</span>
                <span class="cov0" title="0">case 'g', 'G':
                        prec = digs.nd</span>
                }
        }<span class="cov0" title="0"> else if fmt != 'f' </span><span class="cov0" title="0">{
                // Fixed number of digits.
                digits := prec
                switch fmt </span>{
                <span class="cov0" title="0">case 'e', 'E':
                        digits++</span>
                <span class="cov0" title="0">case 'g', 'G':
                        if prec == 0 </span><span class="cov0" title="0">{
                                prec = 1
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">digits = prec</span>
                }
                <span class="cov0" title="0">if digits &lt;= 15 </span><span class="cov0" title="0">{
                        // try fast algorithm when the number of digits is reasonable.
                        var buf [24]byte
                        digs.d = buf[:]
                        f := extFloat{mant, exp - int(flt.mantbits), neg}
                        ok = f.FixedDecimal(&amp;digs, digits)
                }</span><span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                return bigFtoa(dst, prec, fmt, neg, mant, exp, flt)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return formatDigits(dst, shortest, neg, digs, prec, fmt)</span>
}

// bigFtoa uses multiprecision computations to format a float.
func bigFtoa(dst []byte, prec int, fmt byte, neg bool, mant uint64, exp int, flt *floatInfo) []byte <span class="cov0" title="0">{
        d := new(decimal)
        d.Assign(mant)
        d.Shift(exp - int(flt.mantbits))
        var digs decimalSlice
        shortest := prec &lt; 0
        if shortest </span><span class="cov0" title="0">{
                roundShortest(d, mant, exp, flt)
                digs = decimalSlice{d: d.d[:], nd: d.nd, dp: d.dp}
                // Precision for shortest representation mode.
                switch fmt </span>{
                <span class="cov0" title="0">case 'e', 'E':
                        prec = digs.nd - 1</span>
                <span class="cov0" title="0">case 'f':
                        prec = max(digs.nd-digs.dp, 0)</span>
                <span class="cov0" title="0">case 'g', 'G':
                        prec = digs.nd</span>
                }
        }<span class="cov0" title="0"> else {
                // Round appropriately.
                switch fmt </span>{
                <span class="cov0" title="0">case 'e', 'E':
                        d.Round(prec + 1)</span>
                <span class="cov0" title="0">case 'f':
                        d.Round(d.dp + prec)</span>
                <span class="cov0" title="0">case 'g', 'G':
                        if prec == 0 </span><span class="cov0" title="0">{
                                prec = 1
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">d.Round(prec)</span>
                }
                <span class="cov0" title="0">digs = decimalSlice{d: d.d[:], nd: d.nd, dp: d.dp}</span>
        }
        <span class="cov8" title="1">return formatDigits(dst, shortest, neg, digs, prec, fmt)</span>
}

func formatDigits(dst []byte, shortest bool, neg bool, digs decimalSlice, prec int, fmt byte) []byte <span class="cov0" title="0">{
        switch fmt </span>{
        <span class="cov0" title="0">case 'e', 'E':
                return fmtE(dst, neg, digs, prec, fmt)</span>
        <span class="cov0" title="0">case 'f':
                return fmtF(dst, neg, digs, prec)</span>
        <span class="cov0" title="0">case 'g', 'G':
                // trailing fractional zeros in 'e' form will be trimmed.
                eprec := prec
                if eprec &gt; digs.nd &amp;&amp; digs.nd &gt;= digs.dp </span><span class="cov0" title="0">{
                        eprec = digs.nd
                }</span><span class="cov0" title="0">
</span>                // %e is used if the exponent from the conversion
                // is less than -4 or greater than or equal to the precision.
                // if precision was the shortest possible, use precision 6 for this decision.
                <span class="cov0" title="0">if shortest </span><span class="cov0" title="0">{
                        eprec = 6
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">exp := digs.dp - 1
                if exp &lt; -4 || exp &gt;= eprec </span><span class="cov0" title="0">{
                        if prec &gt; digs.nd </span><span class="cov0" title="0">{
                                prec = digs.nd
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">return fmtE(dst, neg, digs, prec-1, fmt+'e'-'g')</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">if prec &gt; digs.dp </span><span class="cov0" title="0">{
                        prec = digs.nd
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return fmtF(dst, neg, digs, max(prec-digs.dp, 0))</span>
        }

        // unknown format
        <span class="cov0" title="0">return append(dst, '%', fmt)</span>
}

// roundShortest rounds d (= mant * 2^exp) to the shortest number of digits
// that will let the original floating point value be precisely reconstructed.
func roundShortest(d *decimal, mant uint64, exp int, flt *floatInfo) <span class="cov0" title="0">{
        // If mantissa is zero, the number is zero; stop now.
        if mant == 0 </span><span class="cov0" title="0">{
                d.nd = 0
                return
        }</span><span class="cov0" title="0">
</span>
        // Compute upper and lower such that any decimal number
        // between upper and lower (possibly inclusive)
        // will round to the original floating point number.

        // We may see at once that the number is already shortest.
        //
        // Suppose d is not denormal, so that 2^exp &lt;= d &lt; 10^dp.
        // The closest shorter number is at least 10^(dp-nd) away.
        // The lower/upper bounds computed below are at distance
        // at most 2^(exp-mantbits).
        //
        // So the number is already shortest if 10^(dp-nd) &gt; 2^(exp-mantbits),
        // or equivalently log2(10)*(dp-nd) &gt; exp-mantbits.
        // It is true if 332/100*(dp-nd) &gt;= exp-mantbits (log2(10) &gt; 3.32).
        <span class="cov0" title="0">minexp := flt.bias + 1 // minimum possible exponent
        if exp &gt; minexp &amp;&amp; 332*(d.dp-d.nd) &gt;= 100*(exp-int(flt.mantbits)) </span><span class="cov0" title="0">{
                // The number is already shortest.
                return
        }</span><span class="cov0" title="0">
</span>
        // d = mant &lt;&lt; (exp - mantbits)
        // Next highest floating point number is mant+1 &lt;&lt; exp-mantbits.
        // Our upper bound is halfway between, mant*2+1 &lt;&lt; exp-mantbits-1.
        <span class="cov0" title="0">upper := new(decimal)
        upper.Assign(mant*2 + 1)
        upper.Shift(exp - int(flt.mantbits) - 1)

        // d = mant &lt;&lt; (exp - mantbits)
        // Next lowest floating point number is mant-1 &lt;&lt; exp-mantbits,
        // unless mant-1 drops the significant bit and exp is not the minimum exp,
        // in which case the next lowest is mant*2-1 &lt;&lt; exp-mantbits-1.
        // Either way, call it mantlo &lt;&lt; explo-mantbits.
        // Our lower bound is halfway between, mantlo*2+1 &lt;&lt; explo-mantbits-1.
        var mantlo uint64
        var explo int
        if mant &gt; 1&lt;&lt;flt.mantbits || exp == minexp </span><span class="cov0" title="0">{
                mantlo = mant - 1
                explo = exp
        }</span><span class="cov0" title="0"> else {
                mantlo = mant*2 - 1
                explo = exp - 1
        }</span>
        <span class="cov0" title="0">lower := new(decimal)
        lower.Assign(mantlo*2 + 1)
        lower.Shift(explo - int(flt.mantbits) - 1)

        // The upper and lower bounds are possible outputs only if
        // the original mantissa is even, so that IEEE round-to-even
        // would round to the original mantissa and not the neighbors.
        inclusive := mant%2 == 0

        // As we walk the digits we want to know whether rounding up would fall
        // within the upper bound. This is tracked by upperdelta:
        //
        // If upperdelta == 0, the digits of d and upper are the same so far.
        //
        // If upperdelta == 1, we saw a difference of 1 between d and upper on a
        // previous digit and subsequently only 9s for d and 0s for upper.
        // (Thus rounding up may fall outside the bound, if it is exclusive.)
        //
        // If upperdelta == 2, then the difference is greater than 1
        // and we know that rounding up falls within the bound.
        var upperdelta uint8

        // Now we can figure out the minimum number of digits required.
        // Walk along until d has distinguished itself from upper and lower.
        for ui := 0; ; ui++ </span><span class="cov0" title="0">{
                // lower, d, and upper may have the decimal points at different
                // places. In this case upper is the longest, so we iterate from
                // ui==0 and start li and mi at (possibly) -1.
                mi := ui - upper.dp + d.dp
                if mi &gt;= d.nd </span><span class="cov0" title="0">{
                        break</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">li := ui - upper.dp + lower.dp
                l := byte('0') // lower digit
                if li &gt;= 0 &amp;&amp; li &lt; lower.nd </span><span class="cov0" title="0">{
                        l = lower.d[li]
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">m := byte('0') // middle digit
                if mi &gt;= 0 </span><span class="cov0" title="0">{
                        m = d.d[mi]
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">u := byte('0') // upper digit
                if ui &lt; upper.nd </span><span class="cov0" title="0">{
                        u = upper.d[ui]
                }</span><span class="cov0" title="0">
</span>
                // Okay to round down (truncate) if lower has a different digit
                // or if lower is inclusive and is exactly the result of rounding
                // down (i.e., and we have reached the final digit of lower).
                <span class="cov0" title="0">okdown := l != m || inclusive &amp;&amp; li+1 == lower.nd

                switch </span>{
                <span class="cov0" title="0">case upperdelta == 0 &amp;&amp; m+1 &lt; u:
                        // Example:
                        // m = 12345xxx
                        // u = 12347xxx
                        upperdelta = 2</span>
                <span class="cov0" title="0">case upperdelta == 0 &amp;&amp; m != u:
                        // Example:
                        // m = 12345xxx
                        // u = 12346xxx
                        upperdelta = 1</span>
                <span class="cov0" title="0">case upperdelta == 1 &amp;&amp; (m != '9' || u != '0'):
                        // Example:
                        // m = 1234598x
                        // u = 1234600x
                        upperdelta = 2</span>
                }
                // Okay to round up if upper has a different digit and either upper
                // is inclusive or upper is bigger than the result of rounding up.
                <span class="cov0" title="0">okup := upperdelta &gt; 0 &amp;&amp; (inclusive || upperdelta &gt; 1 || ui+1 &lt; upper.nd)

                // If it's okay to do either, then round to the nearest one.
                // If it's okay to do only one, do it.
                switch </span>{
                <span class="cov0" title="0">case okdown &amp;&amp; okup:
                        d.Round(mi + 1)
                        return</span>
                <span class="cov0" title="0">case okdown:
                        d.RoundDown(mi + 1)
                        return</span>
                <span class="cov0" title="0">case okup:
                        d.RoundUp(mi + 1)
                        return</span>
                }
        }
}

type decimalSlice struct {
        d      []byte
        nd, dp int
        neg    bool
}

// %e: -d.ddddde±dd
func fmtE(dst []byte, neg bool, d decimalSlice, prec int, fmt byte) []byte <span class="cov0" title="0">{
        // sign
        if neg </span><span class="cov0" title="0">{
                dst = append(dst, '-')
        }</span><span class="cov0" title="0">
</span>
        // first digit
        <span class="cov0" title="0">ch := byte('0')
        if d.nd != 0 </span><span class="cov0" title="0">{
                ch = d.d[0]
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">dst = append(dst, ch)

        // .moredigits
        if prec &gt; 0 </span><span class="cov0" title="0">{
                dst = append(dst, '.')
                i := 1
                m := min(d.nd, prec+1)
                if i &lt; m </span><span class="cov0" title="0">{
                        dst = append(dst, d.d[i:m]...)
                        i = m
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">for ; i &lt;= prec; i++ </span><span class="cov0" title="0">{
                        dst = append(dst, '0')
                }</span>
        }<span class="cov0" title="0">
</span>
        // e±
        <span class="cov0" title="0">dst = append(dst, fmt)
        exp := d.dp - 1
        if d.nd == 0 </span><span class="cov0" title="0">{ // special case: 0 has exponent 0
                exp = 0
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if exp &lt; 0 </span><span class="cov0" title="0">{
                ch = '-'
                exp = -exp
        }</span><span class="cov0" title="0"> else {
                ch = '+'
        }</span>
        <span class="cov0" title="0">dst = append(dst, ch)

        // dd or ddd
        switch </span>{
        <span class="cov0" title="0">case exp &lt; 10:
                dst = append(dst, '0', byte(exp)+'0')</span>
        <span class="cov0" title="0">case exp &lt; 100:
                dst = append(dst, byte(exp/10)+'0', byte(exp%10)+'0')</span>
        <span class="cov0" title="0">default:
                dst = append(dst, byte(exp/100)+'0', byte(exp/10)%10+'0', byte(exp%10)+'0')</span>
        }

        <span class="cov0" title="0">return dst</span>
}

// %f: -ddddddd.ddddd
func fmtF(dst []byte, neg bool, d decimalSlice, prec int) []byte <span class="cov0" title="0">{
        // sign
        if neg </span><span class="cov0" title="0">{
                dst = append(dst, '-')
        }</span><span class="cov0" title="0">
</span>
        // integer, padded with zeros as needed.
        <span class="cov0" title="0">if d.dp &gt; 0 </span><span class="cov0" title="0">{
                m := min(d.nd, d.dp)
                dst = append(dst, d.d[:m]...)
                for ; m &lt; d.dp; m++ </span><span class="cov0" title="0">{
                        dst = append(dst, '0')
                }</span>
        }<span class="cov0" title="0"> else {
                dst = append(dst, '0')
        }</span>

        // fraction
        <span class="cov0" title="0">if prec &gt; 0 </span><span class="cov0" title="0">{
                dst = append(dst, '.')
                for i := 0; i &lt; prec; i++ </span><span class="cov0" title="0">{
                        ch := byte('0')
                        if j := d.dp + i; 0 &lt;= j &amp;&amp; j &lt; d.nd </span><span class="cov0" title="0">{
                                ch = d.d[j]
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">dst = append(dst, ch)</span>
                }
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">return dst</span>
}

// %b: -ddddddddp±ddd
func fmtB(dst []byte, neg bool, mant uint64, exp int, flt *floatInfo) []byte <span class="cov0" title="0">{
        // sign
        if neg </span><span class="cov0" title="0">{
                dst = append(dst, '-')
        }</span><span class="cov0" title="0">
</span>
        // mantissa
        <span class="cov0" title="0">dst, _ = formatBits(dst, mant, 10, false, true)

        // p
        dst = append(dst, 'p')

        // ±exponent
        exp -= int(flt.mantbits)
        if exp &gt;= 0 </span><span class="cov0" title="0">{
                dst = append(dst, '+')
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">dst, _ = formatBits(dst, uint64(exp), 10, exp &lt; 0, true)

        return dst</span>
}

// %x: -0x1.yyyyyyyyp±ddd or -0x0p+0. (y is hex digit, d is decimal digit)
func fmtX(dst []byte, prec int, fmt byte, neg bool, mant uint64, exp int, flt *floatInfo) []byte <span class="cov0" title="0">{
        if mant == 0 </span><span class="cov0" title="0">{
                exp = 0
        }</span><span class="cov0" title="0">
</span>
        // Shift digits so leading 1 (if any) is at bit 1&lt;&lt;60.
        <span class="cov0" title="0">mant &lt;&lt;= 60 - flt.mantbits
        for mant != 0 &amp;&amp; mant&amp;(1&lt;&lt;60) == 0 </span><span class="cov0" title="0">{
                mant &lt;&lt;= 1
                exp--
        }</span>

        // Round if requested.
        <span class="cov0" title="0">if prec &gt;= 0 &amp;&amp; prec &lt; 15 </span><span class="cov0" title="0">{
                shift := uint(prec * 4)
                extra := (mant &lt;&lt; shift) &amp; (1&lt;&lt;60 - 1)
                mant &gt;&gt;= 60 - shift
                if extra|(mant&amp;1) &gt; 1&lt;&lt;59 </span><span class="cov0" title="0">{
                        mant++
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">mant &lt;&lt;= 60 - shift
                if mant&amp;(1&lt;&lt;61) != 0 </span><span class="cov0" title="0">{
                        // Wrapped around.
                        mant &gt;&gt;= 1
                        exp++
                }</span><span class="cov8" title="1">
</span>        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">hex := lowerhex
        if fmt == 'X' </span><span class="cov0" title="0">{
                hex = upperhex
        }</span><span class="cov0" title="0">
</span>
        // sign, 0x, leading digit
        <span class="cov0" title="0">if neg </span><span class="cov0" title="0">{
                dst = append(dst, '-')
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">dst = append(dst, '0', fmt, '0'+byte((mant&gt;&gt;60)&amp;1))

        // .fraction
        mant &lt;&lt;= 4 // remove leading 0 or 1
        if prec &lt; 0 &amp;&amp; mant != 0 </span><span class="cov0" title="0">{
                dst = append(dst, '.')
                for mant != 0 </span><span class="cov0" title="0">{
                        dst = append(dst, hex[(mant&gt;&gt;60)&amp;15])
                        mant &lt;&lt;= 4
                }</span>
        }<span class="cov0" title="0"> else if prec &gt; 0 </span><span class="cov0" title="0">{
                dst = append(dst, '.')
                for i := 0; i &lt; prec; i++ </span><span class="cov0" title="0">{
                        dst = append(dst, hex[(mant&gt;&gt;60)&amp;15])
                        mant &lt;&lt;= 4
                }</span>
        }<span class="cov0" title="0">
</span>
        // p±
        <span class="cov0" title="0">ch := byte('P')
        if fmt == lower(fmt) </span><span class="cov0" title="0">{
                ch = 'p'
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">dst = append(dst, ch)
        if exp &lt; 0 </span><span class="cov0" title="0">{
                ch = '-'
                exp = -exp
        }</span><span class="cov0" title="0"> else {
                ch = '+'
        }</span>
        <span class="cov0" title="0">dst = append(dst, ch)

        // dd or ddd or dddd
        switch </span>{
        <span class="cov0" title="0">case exp &lt; 100:
                dst = append(dst, byte(exp/10)+'0', byte(exp%10)+'0')</span>
        <span class="cov0" title="0">case exp &lt; 1000:
                dst = append(dst, byte(exp/100)+'0', byte((exp/10)%10)+'0', byte(exp%10)+'0')</span>
        <span class="cov0" title="0">default:
                dst = append(dst, byte(exp/1000)+'0', byte(exp/100)%10+'0', byte((exp/10)%10)+'0', byte(exp%10)+'0')</span>
        }

        <span class="cov0" title="0">return dst</span>
}

func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return b</span>
}

func max(a, b int) int <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package strconv

import "math/bits"

const fastSmalls = true // enable fast path for small integers

// FormatUint returns the string representation of i in the given base,
// for 2 &lt;= base &lt;= 36. The result uses the lower-case letters 'a' to 'z'
// for digit values &gt;= 10.
func FormatUint(i uint64, base int) string <span class="cov0" title="0">{
        if fastSmalls &amp;&amp; i &lt; nSmalls &amp;&amp; base == 10 </span><span class="cov0" title="0">{
                return small(int(i))
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">_, s := formatBits(nil, i, base, false, false)
        return s</span>
}

// FormatInt returns the string representation of i in the given base,
// for 2 &lt;= base &lt;= 36. The result uses the lower-case letters 'a' to 'z'
// for digit values &gt;= 10.
func FormatInt(i int64, base int) string <span class="cov0" title="0">{
        if fastSmalls &amp;&amp; 0 &lt;= i &amp;&amp; i &lt; nSmalls &amp;&amp; base == 10 </span><span class="cov0" title="0">{
                return small(int(i))
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">_, s := formatBits(nil, uint64(i), base, i &lt; 0, false)
        return s</span>
}

// Itoa is equivalent to FormatInt(int64(i), 10).
func Itoa(i int) string <span class="cov0" title="0">{
        return FormatInt(int64(i), 10)
}</span>

// AppendInt appends the string form of the integer i,
// as generated by FormatInt, to dst and returns the extended buffer.
func AppendInt(dst []byte, i int64, base int) []byte <span class="cov0" title="0">{
        if fastSmalls &amp;&amp; 0 &lt;= i &amp;&amp; i &lt; nSmalls &amp;&amp; base == 10 </span><span class="cov0" title="0">{
                return append(dst, small(int(i))...)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">dst, _ = formatBits(dst, uint64(i), base, i &lt; 0, true)
        return dst</span>
}

// AppendUint appends the string form of the unsigned integer i,
// as generated by FormatUint, to dst and returns the extended buffer.
func AppendUint(dst []byte, i uint64, base int) []byte <span class="cov0" title="0">{
        if fastSmalls &amp;&amp; i &lt; nSmalls &amp;&amp; base == 10 </span><span class="cov0" title="0">{
                return append(dst, small(int(i))...)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">dst, _ = formatBits(dst, i, base, false, true)
        return dst</span>
}

// small returns the string for an i with 0 &lt;= i &lt; nSmalls.
func small(i int) string <span class="cov0" title="0">{
        if i &lt; 10 </span><span class="cov0" title="0">{
                return digits[i : i+1]
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return smallsString[i*2 : i*2+2]</span>
}

const nSmalls = 100

const smallsString = "00010203040506070809" +
        "10111213141516171819" +
        "20212223242526272829" +
        "30313233343536373839" +
        "40414243444546474849" +
        "50515253545556575859" +
        "60616263646566676869" +
        "70717273747576777879" +
        "80818283848586878889" +
        "90919293949596979899"

const host32bit = ^uint(0)&gt;&gt;32 == 0

const digits = "0123456789abcdefghijklmnopqrstuvwxyz"

// formatBits computes the string representation of u in the given base.
// If neg is set, u is treated as negative int64 value. If append_ is
// set, the string is appended to dst and the resulting byte slice is
// returned as the first result value; otherwise the string is returned
// as the second result value.
//
func formatBits(dst []byte, u uint64, base int, neg, append_ bool) (d []byte, s string) <span class="cov0" title="0">{
        if base &lt; 2 || base &gt; len(digits) </span><span class="cov0" title="0">{
                panic("strconv: illegal AppendInt/FormatInt base")</span>
        }<span class="cov0" title="0">
</span>        // 2 &lt;= base &amp;&amp; base &lt;= len(digits)

        <span class="cov0" title="0">var a [64 + 1]byte // +1 for sign of 64bit value in base 2
        i := len(a)

        if neg </span><span class="cov0" title="0">{
                u = -u
        }</span><span class="cov0" title="0">
</span>
        // convert bits
        // We use uint values where we can because those will
        // fit into a single register even on a 32bit machine.
        <span class="cov0" title="0">if base == 10 </span><span class="cov0" title="0">{
                // common case: use constants for / because
                // the compiler can optimize it into a multiply+shift

                if host32bit </span><span class="cov0" title="0">{
                        // convert the lower digits using 32bit operations
                        for u &gt;= 1e9 </span><span class="cov0" title="0">{
                                // Avoid using r = a%b in addition to q = a/b
                                // since 64bit division and modulo operations
                                // are calculated by runtime functions on 32bit machines.
                                q := u / 1e9
                                us := uint(u - q*1e9) // u % 1e9 fits into a uint
                                for j := 4; j &gt; 0; j-- </span><span class="cov0" title="0">{
                                        is := us % 100 * 2
                                        us /= 100
                                        i -= 2
                                        a[i+1] = smallsString[is+1]
                                        a[i+0] = smallsString[is+0]
                                }</span>

                                // us &lt; 10, since it contains the last digit
                                // from the initial 9-digit us.
                                <span class="cov0" title="0">i--
                                a[i] = smallsString[us*2+1]

                                u = q</span>
                        }
                        // u &lt; 1e9
                }<span class="cov0" title="0">
</span>
                // u guaranteed to fit into a uint
                <span class="cov0" title="0">us := uint(u)
                for us &gt;= 100 </span><span class="cov0" title="0">{
                        is := us % 100 * 2
                        us /= 100
                        i -= 2
                        a[i+1] = smallsString[is+1]
                        a[i+0] = smallsString[is+0]
                }</span>

                // us &lt; 100
                <span class="cov8" title="1">is := us * 2
                i--
                a[i] = smallsString[is+1]
                if us &gt;= 10 </span><span class="cov0" title="0">{
                        i--
                        a[i] = smallsString[is]
                }</span><span class="cov0" title="0">
</span>
        }<span class="cov0" title="0"> else if isPowerOfTwo(base) </span><span class="cov0" title="0">{
                // Use shifts and masks instead of / and %.
                // Base is a power of 2 and 2 &lt;= base &lt;= len(digits) where len(digits) is 36.
                // The largest power of 2 below or equal to 36 is 32, which is 1 &lt;&lt; 5;
                // i.e., the largest possible shift count is 5. By &amp;-ind that value with
                // the constant 7 we tell the compiler that the shift count is always
                // less than 8 which is smaller than any register width. This allows
                // the compiler to generate better code for the shift operation.
                shift := uint(bits.TrailingZeros(uint(base))) &amp; 7
                b := uint64(base)
                m := uint(base) - 1 // == 1&lt;&lt;shift - 1
                for u &gt;= b </span><span class="cov0" title="0">{
                        i--
                        a[i] = digits[uint(u)&amp;m]
                        u &gt;&gt;= shift
                }</span>
                // u &lt; base
                <span class="cov0" title="0">i--
                a[i] = digits[uint(u)]</span>
        }<span class="cov0" title="0"> else {
                // general case
                b := uint64(base)
                for u &gt;= b </span><span class="cov0" title="0">{
                        i--
                        // Avoid using r = a%b in addition to q = a/b
                        // since 64bit division and modulo operations
                        // are calculated by runtime functions on 32bit machines.
                        q := u / b
                        a[i] = digits[uint(u-q*b)]
                        u = q
                }</span>
                // u &lt; base
                <span class="cov0" title="0">i--
                a[i] = digits[uint(u)]</span>
        }

        // add sign, if any
        <span class="cov0" title="0">if neg </span><span class="cov0" title="0">{
                i--
                a[i] = '-'
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if append_ </span><span class="cov0" title="0">{
                d = append(dst, a[i:]...)
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">s = string(a[i:])
        return</span>
}

func isPowerOfTwo(x int) bool <span class="cov0" title="0">{
        return x&amp;(x-1) == 0
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate go run makeisprint.go -output isprint.go

package strconv

import (
        "internal/bytealg"
        "unicode/utf8"
)

const (
        lowerhex = "0123456789abcdef"
        upperhex = "0123456789ABCDEF"
)

func quoteWith(s string, quote byte, ASCIIonly, graphicOnly bool) string <span class="cov0" title="0">{
        return string(appendQuotedWith(make([]byte, 0, 3*len(s)/2), s, quote, ASCIIonly, graphicOnly))
}</span>

func quoteRuneWith(r rune, quote byte, ASCIIonly, graphicOnly bool) string <span class="cov0" title="0">{
        return string(appendQuotedRuneWith(nil, r, quote, ASCIIonly, graphicOnly))
}</span>

func appendQuotedWith(buf []byte, s string, quote byte, ASCIIonly, graphicOnly bool) []byte <span class="cov8" title="1">{
        // Often called with big strings, so preallocate. If there's quoting,
        // this is conservative but still helps a lot.
        if cap(buf)-len(buf) &lt; len(s) </span><span class="cov0" title="0">{
                nBuf := make([]byte, len(buf), len(buf)+1+len(s)+1)
                copy(nBuf, buf)
                buf = nBuf
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">buf = append(buf, quote)
        for width := 0; len(s) &gt; 0; s = s[width:] </span><span class="cov8" title="1">{
                r := rune(s[0])
                width = 1
                if r &gt;= utf8.RuneSelf </span><span class="cov8" title="1">{
                        r, width = utf8.DecodeRuneInString(s)
                }</span><span class="cov8" title="1">
</span>                <span class="cov8" title="1">if width == 1 &amp;&amp; r == utf8.RuneError </span><span class="cov8" title="1">{
                        buf = append(buf, `\x`...)
                        buf = append(buf, lowerhex[s[0]&gt;&gt;4])
                        buf = append(buf, lowerhex[s[0]&amp;0xF])
                        continue</span>
                }<span class="cov8" title="1">
</span>                <span class="cov8" title="1">buf = appendEscapedRune(buf, r, quote, ASCIIonly, graphicOnly)</span>
        }
        <span class="cov8" title="1">buf = append(buf, quote)
        return buf</span>
}

func appendQuotedRuneWith(buf []byte, r rune, quote byte, ASCIIonly, graphicOnly bool) []byte <span class="cov0" title="0">{
        buf = append(buf, quote)
        if !utf8.ValidRune(r) </span><span class="cov0" title="0">{
                r = utf8.RuneError
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">buf = appendEscapedRune(buf, r, quote, ASCIIonly, graphicOnly)
        buf = append(buf, quote)
        return buf</span>
}

func appendEscapedRune(buf []byte, r rune, quote byte, ASCIIonly, graphicOnly bool) []byte <span class="cov8" title="1">{
        var runeTmp [utf8.UTFMax]byte
        if r == rune(quote) || r == '\\' </span><span class="cov0" title="0">{ // always backslashed
                buf = append(buf, '\\')
                buf = append(buf, byte(r))
                return buf
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">if ASCIIonly </span><span class="cov0" title="0">{
                if r &lt; utf8.RuneSelf &amp;&amp; IsPrint(r) </span><span class="cov0" title="0">{
                        buf = append(buf, byte(r))
                        return buf
                }</span><span class="cov0" title="0">
</span>        }<span class="cov8" title="1"> else if IsPrint(r) || graphicOnly &amp;&amp; isInGraphicList(r) </span><span class="cov8" title="1">{
                n := utf8.EncodeRune(runeTmp[:], r)
                buf = append(buf, runeTmp[:n]...)
                return buf
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">switch r </span>{
        <span class="cov0" title="0">case '\a':
                buf = append(buf, `\a`...)</span>
        <span class="cov8" title="1">case '\b':
                buf = append(buf, `\b`...)</span>
        <span class="cov0" title="0">case '\f':
                buf = append(buf, `\f`...)</span>
        <span class="cov0" title="0">case '\n':
                buf = append(buf, `\n`...)</span>
        <span class="cov0" title="0">case '\r':
                buf = append(buf, `\r`...)</span>
        <span class="cov0" title="0">case '\t':
                buf = append(buf, `\t`...)</span>
        <span class="cov0" title="0">case '\v':
                buf = append(buf, `\v`...)</span>
        <span class="cov0" title="0">default:
                switch </span>{
                <span class="cov0" title="0">case r &lt; ' ':
                        buf = append(buf, `\x`...)
                        buf = append(buf, lowerhex[byte(r)&gt;&gt;4])
                        buf = append(buf, lowerhex[byte(r)&amp;0xF])</span>
                <span class="cov0" title="0">case r &gt; utf8.MaxRune:
                        r = 0xFFFD
                        fallthrough</span>
                <span class="cov0" title="0">case r &lt; 0x10000:
                        buf = append(buf, `\u`...)
                        for s := 12; s &gt;= 0; s -= 4 </span><span class="cov0" title="0">{
                                buf = append(buf, lowerhex[r&gt;&gt;uint(s)&amp;0xF])
                        }</span>
                <span class="cov0" title="0">default:
                        buf = append(buf, `\U`...)
                        for s := 28; s &gt;= 0; s -= 4 </span><span class="cov0" title="0">{
                                buf = append(buf, lowerhex[r&gt;&gt;uint(s)&amp;0xF])
                        }</span>
                }
        }
        <span class="cov0" title="0">return buf</span>
}

// Quote returns a double-quoted Go string literal representing s. The
// returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for
// control characters and non-printable characters as defined by
// IsPrint.
func Quote(s string) string <span class="cov0" title="0">{
        return quoteWith(s, '"', false, false)
}</span>

// AppendQuote appends a double-quoted Go string literal representing s,
// as generated by Quote, to dst and returns the extended buffer.
func AppendQuote(dst []byte, s string) []byte <span class="cov8" title="1">{
        return appendQuotedWith(dst, s, '"', false, false)
}</span>

// QuoteToASCII returns a double-quoted Go string literal representing s.
// The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for
// non-ASCII characters and non-printable characters as defined by IsPrint.
func QuoteToASCII(s string) string <span class="cov0" title="0">{
        return quoteWith(s, '"', true, false)
}</span>

// AppendQuoteToASCII appends a double-quoted Go string literal representing s,
// as generated by QuoteToASCII, to dst and returns the extended buffer.
func AppendQuoteToASCII(dst []byte, s string) []byte <span class="cov0" title="0">{
        return appendQuotedWith(dst, s, '"', true, false)
}</span>

// QuoteToGraphic returns a double-quoted Go string literal representing s.
// The returned string leaves Unicode graphic characters, as defined by
// IsGraphic, unchanged and uses Go escape sequences (\t, \n, \xFF, \u0100)
// for non-graphic characters.
func QuoteToGraphic(s string) string <span class="cov0" title="0">{
        return quoteWith(s, '"', false, true)
}</span>

// AppendQuoteToGraphic appends a double-quoted Go string literal representing s,
// as generated by QuoteToGraphic, to dst and returns the extended buffer.
func AppendQuoteToGraphic(dst []byte, s string) []byte <span class="cov0" title="0">{
        return appendQuotedWith(dst, s, '"', false, true)
}</span>

// QuoteRune returns a single-quoted Go character literal representing the
// rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100)
// for control characters and non-printable characters as defined by IsPrint.
func QuoteRune(r rune) string <span class="cov0" title="0">{
        return quoteRuneWith(r, '\'', false, false)
}</span>

// AppendQuoteRune appends a single-quoted Go character literal representing the rune,
// as generated by QuoteRune, to dst and returns the extended buffer.
func AppendQuoteRune(dst []byte, r rune) []byte <span class="cov0" title="0">{
        return appendQuotedRuneWith(dst, r, '\'', false, false)
}</span>

// QuoteRuneToASCII returns a single-quoted Go character literal representing
// the rune. The returned string uses Go escape sequences (\t, \n, \xFF,
// \u0100) for non-ASCII characters and non-printable characters as defined
// by IsPrint.
func QuoteRuneToASCII(r rune) string <span class="cov0" title="0">{
        return quoteRuneWith(r, '\'', true, false)
}</span>

// AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune,
// as generated by QuoteRuneToASCII, to dst and returns the extended buffer.
func AppendQuoteRuneToASCII(dst []byte, r rune) []byte <span class="cov0" title="0">{
        return appendQuotedRuneWith(dst, r, '\'', true, false)
}</span>

// QuoteRuneToGraphic returns a single-quoted Go character literal representing
// the rune. If the rune is not a Unicode graphic character,
// as defined by IsGraphic, the returned string will use a Go escape sequence
// (\t, \n, \xFF, \u0100).
func QuoteRuneToGraphic(r rune) string <span class="cov0" title="0">{
        return quoteRuneWith(r, '\'', false, true)
}</span>

// AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune,
// as generated by QuoteRuneToGraphic, to dst and returns the extended buffer.
func AppendQuoteRuneToGraphic(dst []byte, r rune) []byte <span class="cov0" title="0">{
        return appendQuotedRuneWith(dst, r, '\'', false, true)
}</span>

// CanBackquote reports whether the string s can be represented
// unchanged as a single-line backquoted string without control
// characters other than tab.
func CanBackquote(s string) bool <span class="cov0" title="0">{
        for len(s) &gt; 0 </span><span class="cov0" title="0">{
                r, wid := utf8.DecodeRuneInString(s)
                s = s[wid:]
                if wid &gt; 1 </span><span class="cov8" title="1">{
                        if r == '\ufeff' </span><span class="cov0" title="0">{
                                return false // BOMs are invisible and should not be quoted.
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">continue</span> // All other multibyte runes are correctly encoded and assumed printable.
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">if r == utf8.RuneError </span><span class="cov0" title="0">{
                        return false
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if (r &lt; ' ' &amp;&amp; r != '\t') || r == '`' || r == '\u007F' </span><span class="cov0" title="0">{
                        return false
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return true</span>
}

func unhex(b byte) (v rune, ok bool) <span class="cov0" title="0">{
        c := rune(b)
        switch </span>{
        <span class="cov0" title="0">case '0' &lt;= c &amp;&amp; c &lt;= '9':
                return c - '0', true</span>
        <span class="cov0" title="0">case 'a' &lt;= c &amp;&amp; c &lt;= 'f':
                return c - 'a' + 10, true</span>
        <span class="cov0" title="0">case 'A' &lt;= c &amp;&amp; c &lt;= 'F':
                return c - 'A' + 10, true</span>
        }
        <span class="cov0" title="0">return</span>
}

// UnquoteChar decodes the first character or byte in the escaped string
// or character literal represented by the string s.
// It returns four values:
//
//        1) value, the decoded Unicode code point or byte value;
//        2) multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;
//        3) tail, the remainder of the string after the character; and
//        4) an error that will be nil if the character is syntactically valid.
//
// The second argument, quote, specifies the type of literal being parsed
// and therefore which escaped quote character is permitted.
// If set to a single quote, it permits the sequence \' and disallows unescaped '.
// If set to a double quote, it permits \" and disallows unescaped ".
// If set to zero, it does not permit either escape and allows both quote characters to appear unescaped.
func UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error) <span class="cov0" title="0">{
        // easy cases
        if len(s) == 0 </span><span class="cov0" title="0">{
                err = ErrSyntax
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">switch c := s[0]; </span>{
        <span class="cov0" title="0">case c == quote &amp;&amp; (quote == '\'' || quote == '"'):
                err = ErrSyntax
                return</span>
        <span class="cov0" title="0">case c &gt;= utf8.RuneSelf:
                r, size := utf8.DecodeRuneInString(s)
                return r, true, s[size:], nil</span>
        <span class="cov0" title="0">case c != '\\':
                return rune(s[0]), false, s[1:], nil</span>
        }

        // hard case: c is backslash
        <span class="cov0" title="0">if len(s) &lt;= 1 </span><span class="cov0" title="0">{
                err = ErrSyntax
                return
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">c := s[1]
        s = s[2:]

        switch c </span>{
        <span class="cov0" title="0">case 'a':
                value = '\a'</span>
        <span class="cov0" title="0">case 'b':
                value = '\b'</span>
        <span class="cov0" title="0">case 'f':
                value = '\f'</span>
        <span class="cov0" title="0">case 'n':
                value = '\n'</span>
        <span class="cov0" title="0">case 'r':
                value = '\r'</span>
        <span class="cov0" title="0">case 't':
                value = '\t'</span>
        <span class="cov0" title="0">case 'v':
                value = '\v'</span>
        <span class="cov0" title="0">case 'x', 'u', 'U':
                n := 0
                switch c </span>{
                <span class="cov0" title="0">case 'x':
                        n = 2</span>
                <span class="cov0" title="0">case 'u':
                        n = 4</span>
                <span class="cov0" title="0">case 'U':
                        n = 8</span>
                }
                <span class="cov0" title="0">var v rune
                if len(s) &lt; n </span><span class="cov0" title="0">{
                        err = ErrSyntax
                        return
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">for j := 0; j &lt; n; j++ </span><span class="cov0" title="0">{
                        x, ok := unhex(s[j])
                        if !ok </span><span class="cov0" title="0">{
                                err = ErrSyntax
                                return
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">v = v&lt;&lt;4 | x</span>
                }
                <span class="cov0" title="0">s = s[n:]
                if c == 'x' </span><span class="cov0" title="0">{
                        // single-byte string, possibly not UTF-8
                        value = v
                        break</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">if v &gt; utf8.MaxRune </span><span class="cov0" title="0">{
                        err = ErrSyntax
                        return
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">value = v
                multibyte = true</span>
        <span class="cov0" title="0">case '0', '1', '2', '3', '4', '5', '6', '7':
                v := rune(c) - '0'
                if len(s) &lt; 2 </span><span class="cov0" title="0">{
                        err = ErrSyntax
                        return
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">for j := 0; j &lt; 2; j++ </span><span class="cov0" title="0">{ // one digit already; two more
                        x := rune(s[j]) - '0'
                        if x &lt; 0 || x &gt; 7 </span><span class="cov0" title="0">{
                                err = ErrSyntax
                                return
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">v = (v &lt;&lt; 3) | x</span>
                }
                <span class="cov0" title="0">s = s[2:]
                if v &gt; 255 </span><span class="cov0" title="0">{
                        err = ErrSyntax
                        return
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">value = v</span>
        <span class="cov0" title="0">case '\\':
                value = '\\'</span>
        <span class="cov0" title="0">case '\'', '"':
                if c != quote </span><span class="cov0" title="0">{
                        err = ErrSyntax
                        return
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">value = rune(c)</span>
        <span class="cov0" title="0">default:
                err = ErrSyntax
                return</span>
        }
        <span class="cov0" title="0">tail = s
        return</span>
}

// Unquote interprets s as a single-quoted, double-quoted,
// or backquoted Go string literal, returning the string value
// that s quotes.  (If s is single-quoted, it would be a Go
// character literal; Unquote returns the corresponding
// one-character string.)
func Unquote(s string) (string, error) <span class="cov0" title="0">{
        n := len(s)
        if n &lt; 2 </span><span class="cov0" title="0">{
                return "", ErrSyntax
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">quote := s[0]
        if quote != s[n-1] </span><span class="cov0" title="0">{
                return "", ErrSyntax
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">s = s[1 : n-1]

        if quote == '`' </span><span class="cov0" title="0">{
                if contains(s, '`') </span><span class="cov0" title="0">{
                        return "", ErrSyntax
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if contains(s, '\r') </span><span class="cov0" title="0">{
                        // -1 because we know there is at least one \r to remove.
                        buf := make([]byte, 0, len(s)-1)
                        for i := 0; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                                if s[i] != '\r' </span><span class="cov0" title="0">{
                                        buf = append(buf, s[i])
                                }</span><span class="cov0" title="0">
</span>                        }
                        <span class="cov0" title="0">return string(buf), nil</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">return s, nil</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if quote != '"' &amp;&amp; quote != '\'' </span><span class="cov0" title="0">{
                return "", ErrSyntax
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if contains(s, '\n') </span><span class="cov0" title="0">{
                return "", ErrSyntax
        }</span><span class="cov0" title="0">
</span>
        // Is it trivial? Avoid allocation.
        <span class="cov0" title="0">if !contains(s, '\\') &amp;&amp; !contains(s, quote) </span><span class="cov0" title="0">{
                switch quote </span>{
                <span class="cov0" title="0">case '"':
                        if utf8.ValidString(s) </span><span class="cov0" title="0">{
                                return s, nil
                        }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">case '\'':
                        r, size := utf8.DecodeRuneInString(s)
                        if size == len(s) &amp;&amp; (r != utf8.RuneError || size != 1) </span><span class="cov0" title="0">{
                                return s, nil
                        }</span><span class="cov0" title="0">
</span>                }
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">var runeTmp [utf8.UTFMax]byte
        buf := make([]byte, 0, 3*len(s)/2) // Try to avoid more allocations.
        for len(s) &gt; 0 </span><span class="cov0" title="0">{
                c, multibyte, ss, err := UnquoteChar(s, quote)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">s = ss
                if c &lt; utf8.RuneSelf || !multibyte </span><span class="cov0" title="0">{
                        buf = append(buf, byte(c))
                }</span><span class="cov0" title="0"> else {
                        n := utf8.EncodeRune(runeTmp[:], c)
                        buf = append(buf, runeTmp[:n]...)
                }</span>
                <span class="cov0" title="0">if quote == '\'' &amp;&amp; len(s) != 0 </span><span class="cov0" title="0">{
                        // single-quoted must be single character
                        return "", ErrSyntax
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return string(buf), nil</span>
}

// contains reports whether the string contains the byte c.
func contains(s string, c byte) bool <span class="cov0" title="0">{
        return bytealg.IndexByteString(s, c) != -1
}</span>

// bsearch16 returns the smallest i such that a[i] &gt;= x.
// If there is no such i, bsearch16 returns len(a).
func bsearch16(a []uint16, x uint16) int <span class="cov8" title="1">{
        i, j := 0, len(a)
        for i &lt; j </span><span class="cov8" title="1">{
                h := i + (j-i)/2
                if a[h] &lt; x </span><span class="cov8" title="1">{
                        i = h + 1
                }</span><span class="cov8" title="1"> else {
                        j = h
                }</span>
        }
        <span class="cov8" title="1">return i</span>
}

// bsearch32 returns the smallest i such that a[i] &gt;= x.
// If there is no such i, bsearch32 returns len(a).
func bsearch32(a []uint32, x uint32) int <span class="cov0" title="0">{
        i, j := 0, len(a)
        for i &lt; j </span><span class="cov0" title="0">{
                h := i + (j-i)/2
                if a[h] &lt; x </span><span class="cov0" title="0">{
                        i = h + 1
                }</span><span class="cov0" title="0"> else {
                        j = h
                }</span>
        }
        <span class="cov0" title="0">return i</span>
}

// TODO: IsPrint is a local implementation of unicode.IsPrint, verified by the tests
// to give the same answer. It allows this package not to depend on unicode,
// and therefore not pull in all the Unicode tables. If the linker were better
// at tossing unused tables, we could get rid of this implementation.
// That would be nice.

// IsPrint reports whether the rune is defined as printable by Go, with
// the same definition as unicode.IsPrint: letters, numbers, punctuation,
// symbols and ASCII space.
func IsPrint(r rune) bool <span class="cov8" title="1">{
        // Fast check for Latin-1
        if r &lt;= 0xFF </span><span class="cov8" title="1">{
                if 0x20 &lt;= r &amp;&amp; r &lt;= 0x7E </span><span class="cov8" title="1">{
                        // All the ASCII is printable from space through DEL-1.
                        return true
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if 0xA1 &lt;= r &amp;&amp; r &lt;= 0xFF </span><span class="cov0" title="0">{
                        // Similarly for ¡ through ÿ...
                        return r != 0xAD // ...except for the bizarre soft hyphen.
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return false</span>
        }<span class="cov8" title="1">
</span>
        // Same algorithm, either on uint16 or uint32 value.
        // First, find first i such that isPrint[i] &gt;= x.
        // This is the index of either the start or end of a pair that might span x.
        // The start is even (isPrint[i&amp;^1]) and the end is odd (isPrint[i|1]).
        // If we find x in a range, make sure x is not in isNotPrint list.

        <span class="cov8" title="1">if 0 &lt;= r &amp;&amp; r &lt; 1&lt;&lt;16 </span><span class="cov8" title="1">{
                rr, isPrint, isNotPrint := uint16(r), isPrint16, isNotPrint16
                i := bsearch16(isPrint, rr)
                if i &gt;= len(isPrint) || rr &lt; isPrint[i&amp;^1] || isPrint[i|1] &lt; rr </span><span class="cov0" title="0">{
                        return false
                }</span><span class="cov8" title="1">
</span>                <span class="cov8" title="1">j := bsearch16(isNotPrint, rr)
                return j &gt;= len(isNotPrint) || isNotPrint[j] != rr</span>
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">rr, isPrint, isNotPrint := uint32(r), isPrint32, isNotPrint32
        i := bsearch32(isPrint, rr)
        if i &gt;= len(isPrint) || rr &lt; isPrint[i&amp;^1] || isPrint[i|1] &lt; rr </span><span class="cov0" title="0">{
                return false
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if r &gt;= 0x20000 </span><span class="cov0" title="0">{
                return true
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">r -= 0x10000
        j := bsearch16(isNotPrint, uint16(r))
        return j &gt;= len(isNotPrint) || isNotPrint[j] != uint16(r)</span>
}

// IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such
// characters include letters, marks, numbers, punctuation, symbols, and
// spaces, from categories L, M, N, P, S, and Zs.
func IsGraphic(r rune) bool <span class="cov0" title="0">{
        if IsPrint(r) </span><span class="cov0" title="0">{
                return true
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return isInGraphicList(r)</span>
}

// isInGraphicList reports whether the rune is in the isGraphic list. This separation
// from IsGraphic allows quoteWith to avoid two calls to IsPrint.
// Should be called only if IsPrint fails.
func isInGraphicList(r rune) bool <span class="cov0" title="0">{
        // We know r must fit in 16 bits - see makeisprint.go.
        if r &gt; 0xFFFF </span><span class="cov0" title="0">{
                return false
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">rr := uint16(r)
        i := bsearch16(isGraphic, rr)
        return i &lt; len(isGraphic) &amp;&amp; rr == isGraphic[i]</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package strings

import (
        "unicode/utf8"
        "unsafe"
)

// A Builder is used to efficiently build a string using Write methods.
// It minimizes memory copying. The zero value is ready to use.
// Do not copy a non-zero Builder.
type Builder struct {
        addr *Builder // of receiver, to detect copies by value
        buf  []byte
}

// noescape hides a pointer from escape analysis.  noescape is
// the identity function but escape analysis doesn't think the
// output depends on the input. noescape is inlined and currently
// compiles down to zero instructions.
// USE CAREFULLY!
// This was copied from the runtime; see issues 23382 and 7921.
//go:nosplit
//go:nocheckptr
func noescape(p unsafe.Pointer) unsafe.Pointer <span class="cov8" title="1">{
        x := uintptr(p)
        return unsafe.Pointer(x ^ 0)
}</span>

func (b *Builder) copyCheck() <span class="cov8" title="1">{
        if b.addr == nil </span><span class="cov8" title="1">{
                // This hack works around a failing of Go's escape analysis
                // that was causing b to escape and be heap allocated.
                // See issue 23382.
                // TODO: once issue 7921 is fixed, this should be reverted to
                // just "b.addr = b".
                b.addr = (*Builder)(noescape(unsafe.Pointer(b)))
        }</span><span class="cov8" title="1"> else if b.addr != b </span><span class="cov0" title="0">{
                panic("strings: illegal use of non-zero Builder copied by value")</span>
        }<span class="cov8" title="1">
</span>}

// String returns the accumulated string.
func (b *Builder) String() string <span class="cov8" title="1">{
        return *(*string)(unsafe.Pointer(&amp;b.buf))
}</span>

// Len returns the number of accumulated bytes; b.Len() == len(b.String()).
func (b *Builder) Len() int <span class="cov8" title="1">{ return len(b.buf) }</span>

// Cap returns the capacity of the builder's underlying byte slice. It is the
// total space allocated for the string being built and includes any bytes
// already written.
func (b *Builder) Cap() int <span class="cov0" title="0">{ return cap(b.buf) }</span>

// Reset resets the Builder to be empty.
func (b *Builder) Reset() <span class="cov0" title="0">{
        b.addr = nil
        b.buf = nil
}</span>

// grow copies the buffer to a new, larger buffer so that there are at least n
// bytes of capacity beyond len(b.buf).
func (b *Builder) grow(n int) <span class="cov8" title="1">{
        buf := make([]byte, len(b.buf), 2*cap(b.buf)+n)
        copy(buf, b.buf)
        b.buf = buf
}</span>

// Grow grows b's capacity, if necessary, to guarantee space for
// another n bytes. After Grow(n), at least n bytes can be written to b
// without another allocation. If n is negative, Grow panics.
func (b *Builder) Grow(n int) <span class="cov8" title="1">{
        b.copyCheck()
        if n &lt; 0 </span><span class="cov0" title="0">{
                panic("strings.Builder.Grow: negative count")</span>
        }<span class="cov8" title="1">
</span>        <span class="cov8" title="1">if cap(b.buf)-len(b.buf) &lt; n </span><span class="cov8" title="1">{
                b.grow(n)
        }</span><span class="cov0" title="0">
</span>}

// Write appends the contents of p to b's buffer.
// Write always returns len(p), nil.
func (b *Builder) Write(p []byte) (int, error) <span class="cov0" title="0">{
        b.copyCheck()
        b.buf = append(b.buf, p...)
        return len(p), nil
}</span>

// WriteByte appends the byte c to b's buffer.
// The returned error is always nil.
func (b *Builder) WriteByte(c byte) error <span class="cov8" title="1">{
        b.copyCheck()
        b.buf = append(b.buf, c)
        return nil
}</span>

// WriteRune appends the UTF-8 encoding of Unicode code point r to b's buffer.
// It returns the length of r and a nil error.
func (b *Builder) WriteRune(r rune) (int, error) <span class="cov0" title="0">{
        b.copyCheck()
        if r &lt; utf8.RuneSelf </span><span class="cov0" title="0">{
                b.buf = append(b.buf, byte(r))
                return 1, nil
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">l := len(b.buf)
        if cap(b.buf)-l &lt; utf8.UTFMax </span><span class="cov0" title="0">{
                b.grow(utf8.UTFMax)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">n := utf8.EncodeRune(b.buf[l:l+utf8.UTFMax], r)
        b.buf = b.buf[:l+n]
        return n, nil</span>
}

// WriteString appends the contents of s to b's buffer.
// It returns the length of s and a nil error.
func (b *Builder) WriteString(s string) (int, error) <span class="cov8" title="1">{
        b.copyCheck()
        b.buf = append(b.buf, s...)
        return len(s), nil
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package strings

import (
        "io"
        "sync"
)

// Replacer replaces a list of strings with replacements.
// It is safe for concurrent use by multiple goroutines.
type Replacer struct {
        once   sync.Once // guards buildOnce method
        r      replacer
        oldnew []string
}

// replacer is the interface that a replacement algorithm needs to implement.
type replacer interface {
        Replace(s string) string
        WriteString(w io.Writer, s string) (n int, err error)
}

// NewReplacer returns a new Replacer from a list of old, new string
// pairs. Replacements are performed in the order they appear in the
// target string, without overlapping matches. The old string
// comparisons are done in argument order.
//
// NewReplacer panics if given an odd number of arguments.
func NewReplacer(oldnew ...string) *Replacer <span class="cov0" title="0">{
        if len(oldnew)%2 == 1 </span><span class="cov0" title="0">{
                panic("strings.NewReplacer: odd argument count")</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">return &amp;Replacer{oldnew: append([]string(nil), oldnew...)}</span>
}

func (r *Replacer) buildOnce() <span class="cov0" title="0">{
        r.r = r.build()
        r.oldnew = nil
}</span>

func (b *Replacer) build() replacer <span class="cov0" title="0">{
        oldnew := b.oldnew
        if len(oldnew) == 2 &amp;&amp; len(oldnew[0]) &gt; 1 </span><span class="cov0" title="0">{
                return makeSingleStringReplacer(oldnew[0], oldnew[1])
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">allNewBytes := true
        for i := 0; i &lt; len(oldnew); i += 2 </span><span class="cov0" title="0">{
                if len(oldnew[i]) != 1 </span><span class="cov8" title="1">{
                        return makeGenericReplacer(oldnew)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if len(oldnew[i+1]) != 1 </span><span class="cov0" title="0">{
                        allNewBytes = false
                }</span><span class="cov0" title="0">
</span>        }

        <span class="cov0" title="0">if allNewBytes </span><span class="cov0" title="0">{
                r := byteReplacer{}
                for i := range r </span><span class="cov0" title="0">{
                        r[i] = byte(i)
                }</span>
                // The first occurrence of old-&gt;new map takes precedence
                // over the others with the same old string.
                <span class="cov0" title="0">for i := len(oldnew) - 2; i &gt;= 0; i -= 2 </span><span class="cov0" title="0">{
                        o := oldnew[i][0]
                        n := oldnew[i+1][0]
                        r[o] = n
                }</span>
                <span class="cov0" title="0">return &amp;r</span>
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">r := byteStringReplacer{toReplace: make([]string, 0, len(oldnew)/2)}
        // The first occurrence of old-&gt;new map takes precedence
        // over the others with the same old string.
        for i := len(oldnew) - 2; i &gt;= 0; i -= 2 </span><span class="cov0" title="0">{
                o := oldnew[i][0]
                n := oldnew[i+1]
                // To avoid counting repetitions multiple times.
                if r.replacements[o] == nil </span><span class="cov0" title="0">{
                        // We need to use string([]byte{o}) instead of string(o),
                        // to avoid utf8 encoding of o.
                        // E. g. byte(150) produces string of length 2.
                        r.toReplace = append(r.toReplace, string([]byte{o}))
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">r.replacements[o] = []byte(n)</span>

        }
        <span class="cov0" title="0">return &amp;r</span>
}

// Replace returns a copy of s with all replacements performed.
func (r *Replacer) Replace(s string) string <span class="cov0" title="0">{
        r.once.Do(r.buildOnce)
        return r.r.Replace(s)
}</span>

// WriteString writes s to w with all replacements performed.
func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error) <span class="cov8" title="1">{
        r.once.Do(r.buildOnce)
        return r.r.WriteString(w, s)
}</span>

// trieNode is a node in a lookup trie for prioritized key/value pairs. Keys
// and values may be empty. For example, the trie containing keys "ax", "ay",
// "bcbc", "x" and "xy" could have eight nodes:
//
//  n0  -
//  n1  a-
//  n2  .x+
//  n3  .y+
//  n4  b-
//  n5  .cbc+
//  n6  x+
//  n7  .y+
//
// n0 is the root node, and its children are n1, n4 and n6; n1's children are
// n2 and n3; n4's child is n5; n6's child is n7. Nodes n0, n1 and n4 (marked
// with a trailing "-") are partial keys, and nodes n2, n3, n5, n6 and n7
// (marked with a trailing "+") are complete keys.
type trieNode struct {
        // value is the value of the trie node's key/value pair. It is empty if
        // this node is not a complete key.
        value string
        // priority is the priority (higher is more important) of the trie node's
        // key/value pair; keys are not necessarily matched shortest- or longest-
        // first. Priority is positive if this node is a complete key, and zero
        // otherwise. In the example above, positive/zero priorities are marked
        // with a trailing "+" or "-".
        priority int

        // A trie node may have zero, one or more child nodes:
        //  * if the remaining fields are zero, there are no children.
        //  * if prefix and next are non-zero, there is one child in next.
        //  * if table is non-zero, it defines all the children.
        //
        // Prefixes are preferred over tables when there is one child, but the
        // root node always uses a table for lookup efficiency.

        // prefix is the difference in keys between this trie node and the next.
        // In the example above, node n4 has prefix "cbc" and n4's next node is n5.
        // Node n5 has no children and so has zero prefix, next and table fields.
        prefix string
        next   *trieNode

        // table is a lookup table indexed by the next byte in the key, after
        // remapping that byte through genericReplacer.mapping to create a dense
        // index. In the example above, the keys only use 'a', 'b', 'c', 'x' and
        // 'y', which remap to 0, 1, 2, 3 and 4. All other bytes remap to 5, and
        // genericReplacer.tableSize will be 5. Node n0's table will be
        // []*trieNode{ 0:n1, 1:n4, 3:n6 }, where the 0, 1 and 3 are the remapped
        // 'a', 'b' and 'x'.
        table []*trieNode
}

func (t *trieNode) add(key, val string, priority int, r *genericReplacer) <span class="cov0" title="0">{
        if key == "" </span><span class="cov0" title="0">{
                if t.priority == 0 </span><span class="cov0" title="0">{
                        t.value = val
                        t.priority = priority
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return</span>
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">if t.prefix != "" </span><span class="cov0" title="0">{
                // Need to split the prefix among multiple nodes.
                var n int // length of the longest common prefix
                for ; n &lt; len(t.prefix) &amp;&amp; n &lt; len(key); n++ </span><span class="cov0" title="0">{
                        if t.prefix[n] != key[n] </span><span class="cov0" title="0">{
                                break</span>
                        }<span class="cov0" title="0">
</span>                }
                <span class="cov0" title="0">if n == len(t.prefix) </span><span class="cov0" title="0">{
                        t.next.add(key[n:], val, priority, r)
                }</span><span class="cov0" title="0"> else if n == 0 </span><span class="cov0" title="0">{
                        // First byte differs, start a new lookup table here. Looking up
                        // what is currently t.prefix[0] will lead to prefixNode, and
                        // looking up key[0] will lead to keyNode.
                        var prefixNode *trieNode
                        if len(t.prefix) == 1 </span><span class="cov0" title="0">{
                                prefixNode = t.next
                        }</span><span class="cov0" title="0"> else {
                                prefixNode = &amp;trieNode{
                                        prefix: t.prefix[1:],
                                        next:   t.next,
                                }
                        }</span>
                        <span class="cov0" title="0">keyNode := new(trieNode)
                        t.table = make([]*trieNode, r.tableSize)
                        t.table[r.mapping[t.prefix[0]]] = prefixNode
                        t.table[r.mapping[key[0]]] = keyNode
                        t.prefix = ""
                        t.next = nil
                        keyNode.add(key[1:], val, priority, r)</span>
                }<span class="cov0" title="0"> else {
                        // Insert new node after the common section of the prefix.
                        next := &amp;trieNode{
                                prefix: t.prefix[n:],
                                next:   t.next,
                        }
                        t.prefix = t.prefix[:n]
                        t.next = next
                        next.add(key[n:], val, priority, r)
                }</span>
        }<span class="cov0" title="0"> else if t.table != nil </span><span class="cov0" title="0">{
                // Insert into existing table.
                m := r.mapping[key[0]]
                if t.table[m] == nil </span><span class="cov0" title="0">{
                        t.table[m] = new(trieNode)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">t.table[m].add(key[1:], val, priority, r)</span>
        }<span class="cov0" title="0"> else {
                t.prefix = key
                t.next = new(trieNode)
                t.next.add("", val, priority, r)
        }</span>
}

func (r *genericReplacer) lookup(s string, ignoreRoot bool) (val string, keylen int, found bool) <span class="cov0" title="0">{
        // Iterate down the trie to the end, and grab the value and keylen with
        // the highest priority.
        bestPriority := 0
        node := &amp;r.root
        n := 0
        for node != nil </span><span class="cov0" title="0">{
                if node.priority &gt; bestPriority &amp;&amp; !(ignoreRoot &amp;&amp; node == &amp;r.root) </span><span class="cov0" title="0">{
                        bestPriority = node.priority
                        val = node.value
                        keylen = n
                        found = true
                }</span><span class="cov0" title="0">
</span>
                <span class="cov0" title="0">if s == "" </span><span class="cov0" title="0">{
                        break</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">if node.table != nil </span><span class="cov0" title="0">{
                        index := r.mapping[s[0]]
                        if int(index) == r.tableSize </span><span class="cov0" title="0">{
                                break</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">node = node.table[index]
                        s = s[1:]
                        n++</span>
                }<span class="cov0" title="0"> else if node.prefix != "" &amp;&amp; HasPrefix(s, node.prefix) </span><span class="cov0" title="0">{
                        n += len(node.prefix)
                        s = s[len(node.prefix):]
                        node = node.next
                }</span><span class="cov0" title="0"> else {
                        break</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

// genericReplacer is the fully generic algorithm.
// It's used as a fallback when nothing faster can be used.
type genericReplacer struct {
        root trieNode
        // tableSize is the size of a trie node's lookup table. It is the number
        // of unique key bytes.
        tableSize int
        // mapping maps from key bytes to a dense index for trieNode.table.
        mapping [256]byte
}

func makeGenericReplacer(oldnew []string) *genericReplacer <span class="cov0" title="0">{
        r := new(genericReplacer)
        // Find each byte used, then assign them each an index.
        for i := 0; i &lt; len(oldnew); i += 2 </span><span class="cov0" title="0">{
                key := oldnew[i]
                for j := 0; j &lt; len(key); j++ </span><span class="cov0" title="0">{
                        r.mapping[key[j]] = 1
                }</span>
        }

        <span class="cov0" title="0">for _, b := range r.mapping </span><span class="cov0" title="0">{
                r.tableSize += int(b)
        }</span>

        <span class="cov0" title="0">var index byte
        for i, b := range r.mapping </span><span class="cov0" title="0">{
                if b == 0 </span><span class="cov0" title="0">{
                        r.mapping[i] = byte(r.tableSize)
                }</span><span class="cov0" title="0"> else {
                        r.mapping[i] = index
                        index++
                }</span>
        }
        // Ensure root node uses a lookup table (for performance).
        <span class="cov0" title="0">r.root.table = make([]*trieNode, r.tableSize)

        for i := 0; i &lt; len(oldnew); i += 2 </span><span class="cov0" title="0">{
                r.root.add(oldnew[i], oldnew[i+1], len(oldnew)-i, r)
        }</span>
        <span class="cov0" title="0">return r</span>
}

type appendSliceWriter []byte

// Write writes to the buffer to satisfy io.Writer.
func (w *appendSliceWriter) Write(p []byte) (int, error) <span class="cov0" title="0">{
        *w = append(*w, p...)
        return len(p), nil
}</span>

// WriteString writes to the buffer without string-&gt;[]byte-&gt;string allocations.
func (w *appendSliceWriter) WriteString(s string) (int, error) <span class="cov0" title="0">{
        *w = append(*w, s...)
        return len(s), nil
}</span>

type stringWriter struct {
        w io.Writer
}

func (w stringWriter) WriteString(s string) (int, error) <span class="cov0" title="0">{
        return w.w.Write([]byte(s))
}</span>

func getStringWriter(w io.Writer) io.StringWriter <span class="cov0" title="0">{
        sw, ok := w.(io.StringWriter)
        if !ok </span><span class="cov0" title="0">{
                sw = stringWriter{w}
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return sw</span>
}

func (r *genericReplacer) Replace(s string) string <span class="cov0" title="0">{
        buf := make(appendSliceWriter, 0, len(s))
        r.WriteString(&amp;buf, s)
        return string(buf)
}</span>

func (r *genericReplacer) WriteString(w io.Writer, s string) (n int, err error) <span class="cov0" title="0">{
        sw := getStringWriter(w)
        var last, wn int
        var prevMatchEmpty bool
        for i := 0; i &lt;= len(s); </span><span class="cov0" title="0">{
                // Fast path: s[i] is not a prefix of any pattern.
                if i != len(s) &amp;&amp; r.root.priority == 0 </span><span class="cov0" title="0">{
                        index := int(r.mapping[s[i]])
                        if index == r.tableSize || r.root.table[index] == nil </span><span class="cov0" title="0">{
                                i++
                                continue</span>
                        }<span class="cov0" title="0">
</span>                }<span class="cov0" title="0">
</span>
                // Ignore the empty match iff the previous loop found the empty match.
                <span class="cov0" title="0">val, keylen, match := r.lookup(s[i:], prevMatchEmpty)
                prevMatchEmpty = match &amp;&amp; keylen == 0
                if match </span><span class="cov0" title="0">{
                        wn, err = sw.WriteString(s[last:i])
                        n += wn
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">wn, err = sw.WriteString(val)
                        n += wn
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">i += keylen
                        last = i
                        continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">i++</span>
        }
        <span class="cov0" title="0">if last != len(s) </span><span class="cov0" title="0">{
                wn, err = sw.WriteString(s[last:])
                n += wn
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return</span>
}

// singleStringReplacer is the implementation that's used when there is only
// one string to replace (and that string has more than one byte).
type singleStringReplacer struct {
        finder *stringFinder
        // value is the new string that replaces that pattern when it's found.
        value string
}

func makeSingleStringReplacer(pattern string, value string) *singleStringReplacer <span class="cov0" title="0">{
        return &amp;singleStringReplacer{finder: makeStringFinder(pattern), value: value}
}</span>

func (r *singleStringReplacer) Replace(s string) string <span class="cov0" title="0">{
        var buf []byte
        i, matched := 0, false
        for </span><span class="cov0" title="0">{
                match := r.finder.next(s[i:])
                if match == -1 </span><span class="cov0" title="0">{
                        break</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">matched = true
                buf = append(buf, s[i:i+match]...)
                buf = append(buf, r.value...)
                i += match + len(r.finder.pattern)</span>
        }
        <span class="cov0" title="0">if !matched </span><span class="cov0" title="0">{
                return s
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">buf = append(buf, s[i:]...)
        return string(buf)</span>
}

func (r *singleStringReplacer) WriteString(w io.Writer, s string) (n int, err error) <span class="cov0" title="0">{
        sw := getStringWriter(w)
        var i, wn int
        for </span><span class="cov0" title="0">{
                match := r.finder.next(s[i:])
                if match == -1 </span><span class="cov0" title="0">{
                        break</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">wn, err = sw.WriteString(s[i : i+match])
                n += wn
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">wn, err = sw.WriteString(r.value)
                n += wn
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">i += match + len(r.finder.pattern)</span>
        }
        <span class="cov0" title="0">wn, err = sw.WriteString(s[i:])
        n += wn
        return</span>
}

// byteReplacer is the implementation that's used when all the "old"
// and "new" values are single ASCII bytes.
// The array contains replacement bytes indexed by old byte.
type byteReplacer [256]byte

func (r *byteReplacer) Replace(s string) string <span class="cov0" title="0">{
        var buf []byte // lazily allocated
        for i := 0; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                b := s[i]
                if r[b] != b </span><span class="cov0" title="0">{
                        if buf == nil </span><span class="cov0" title="0">{
                                buf = []byte(s)
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">buf[i] = r[b]</span>
                }<span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">if buf == nil </span><span class="cov0" title="0">{
                return s
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return string(buf)</span>
}

func (r *byteReplacer) WriteString(w io.Writer, s string) (n int, err error) <span class="cov0" title="0">{
        // TODO(bradfitz): use io.WriteString with slices of s, avoiding allocation.
        bufsize := 32 &lt;&lt; 10
        if len(s) &lt; bufsize </span><span class="cov0" title="0">{
                bufsize = len(s)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">buf := make([]byte, bufsize)

        for len(s) &gt; 0 </span><span class="cov0" title="0">{
                ncopy := copy(buf, s)
                s = s[ncopy:]
                for i, b := range buf[:ncopy] </span><span class="cov0" title="0">{
                        buf[i] = r[b]
                }</span>
                <span class="cov0" title="0">wn, err := w.Write(buf[:ncopy])
                n += wn
                if err != nil </span><span class="cov0" title="0">{
                        return n, err
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return n, nil</span>
}

// byteStringReplacer is the implementation that's used when all the
// "old" values are single ASCII bytes but the "new" values vary in size.
type byteStringReplacer struct {
        // replacements contains replacement byte slices indexed by old byte.
        // A nil []byte means that the old byte should not be replaced.
        replacements [256][]byte
        // toReplace keeps a list of bytes to replace. Depending on length of toReplace
        // and length of target string it may be faster to use Count, or a plain loop.
        // We store single byte as a string, because Count takes a string.
        toReplace []string
}

// countCutOff controls the ratio of a string length to a number of replacements
// at which (*byteStringReplacer).Replace switches algorithms.
// For strings with higher ration of length to replacements than that value,
// we call Count, for each replacement from toReplace.
// For strings, with a lower ratio we use simple loop, because of Count overhead.
// countCutOff is an empirically determined overhead multiplier.
// TODO(tocarip) revisit once we have register-based abi/mid-stack inlining.
const countCutOff = 8

func (r *byteStringReplacer) Replace(s string) string <span class="cov0" title="0">{
        newSize := len(s)
        anyChanges := false
        // Is it faster to use Count?
        if len(r.toReplace)*countCutOff &lt;= len(s) </span><span class="cov0" title="0">{
                for _, x := range r.toReplace </span><span class="cov0" title="0">{
                        if c := Count(s, x); c != 0 </span><span class="cov0" title="0">{
                                // The -1 is because we are replacing 1 byte with len(replacements[b]) bytes.
                                newSize += c * (len(r.replacements[x[0]]) - 1)
                                anyChanges = true
                        }</span><span class="cov0" title="0">
</span>
                }
        }<span class="cov0" title="0"> else {
                for i := 0; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                        b := s[i]
                        if r.replacements[b] != nil </span><span class="cov0" title="0">{
                                // See above for explanation of -1
                                newSize += len(r.replacements[b]) - 1
                                anyChanges = true
                        }</span><span class="cov0" title="0">
</span>                }
        }
        <span class="cov8" title="1">if !anyChanges </span><span class="cov0" title="0">{
                return s
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">buf := make([]byte, newSize)
        j := 0
        for i := 0; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                b := s[i]
                if r.replacements[b] != nil </span><span class="cov0" title="0">{
                        j += copy(buf[j:], r.replacements[b])
                }</span><span class="cov0" title="0"> else {
                        buf[j] = b
                        j++
                }</span>
        }
        <span class="cov0" title="0">return string(buf)</span>
}

func (r *byteStringReplacer) WriteString(w io.Writer, s string) (n int, err error) <span class="cov0" title="0">{
        sw := getStringWriter(w)
        last := 0
        for i := 0; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                b := s[i]
                if r.replacements[b] == nil </span><span class="cov0" title="0">{
                        continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">if last != i </span><span class="cov0" title="0">{
                        nw, err := sw.WriteString(s[last:i])
                        n += nw
                        if err != nil </span><span class="cov0" title="0">{
                                return n, err
                        }</span><span class="cov0" title="0">
</span>                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">last = i + 1
                nw, err := w.Write(r.replacements[b])
                n += nw
                if err != nil </span><span class="cov0" title="0">{
                        return n, err
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">if last != len(s) </span><span class="cov0" title="0">{
                var nw int
                nw, err = sw.WriteString(s[last:])
                n += nw
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package strings implements simple functions to manipulate UTF-8 encoded strings.
//
// For information about UTF-8 strings in Go, see https://blog.golang.org/strings.
package strings

import (
        "internal/bytealg"
        "unicode"
        "unicode/utf8"
)

// explode splits s into a slice of UTF-8 strings,
// one string per Unicode character up to a maximum of n (n &lt; 0 means no limit).
// Invalid UTF-8 sequences become correct encodings of U+FFFD.
func explode(s string, n int) []string <span class="cov8" title="1">{
        l := utf8.RuneCountInString(s)
        if n &lt; 0 || n &gt; l </span><span class="cov0" title="0">{
                n = l
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">a := make([]string, n)
        for i := 0; i &lt; n-1; i++ </span><span class="cov0" title="0">{
                ch, size := utf8.DecodeRuneInString(s)
                a[i] = s[:size]
                s = s[size:]
                if ch == utf8.RuneError </span><span class="cov0" title="0">{
                        a[i] = string(utf8.RuneError)
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">if n &gt; 0 </span><span class="cov0" title="0">{
                a[n-1] = s
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return a</span>
}

// Count counts the number of non-overlapping instances of substr in s.
// If substr is an empty string, Count returns 1 + the number of Unicode code points in s.
func Count(s, substr string) int <span class="cov8" title="1">{
        // special case
        if len(substr) == 0 </span><span class="cov0" title="0">{
                return utf8.RuneCountInString(s) + 1
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">if len(substr) == 1 </span><span class="cov8" title="1">{
                return bytealg.CountString(s, substr[0])
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">n := 0
        for </span><span class="cov0" title="0">{
                i := Index(s, substr)
                if i == -1 </span><span class="cov0" title="0">{
                        return n
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">n++
                s = s[i+len(substr):]</span>
        }
}

// Contains reports whether substr is within s.
func Contains(s, substr string) bool <span class="cov8" title="1">{
        return Index(s, substr) &gt;= 0
}</span>

// ContainsAny reports whether any Unicode code points in chars are within s.
func ContainsAny(s, chars string) bool <span class="cov0" title="0">{
        return IndexAny(s, chars) &gt;= 0
}</span>

// ContainsRune reports whether the Unicode code point r is within s.
func ContainsRune(s string, r rune) bool <span class="cov0" title="0">{
        return IndexRune(s, r) &gt;= 0
}</span>

// LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.
func LastIndex(s, substr string) int <span class="cov8" title="1">{
        n := len(substr)
        switch </span>{
        <span class="cov0" title="0">case n == 0:
                return len(s)</span>
        <span class="cov8" title="1">case n == 1:
                return LastIndexByte(s, substr[0])</span>
        <span class="cov0" title="0">case n == len(s):
                if substr == s </span><span class="cov0" title="0">{
                        return 0
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return -1</span>
        <span class="cov0" title="0">case n &gt; len(s):
                return -1</span>
        }
        // Rabin-Karp search from the end of the string
        <span class="cov0" title="0">hashss, pow := bytealg.HashStrRev(substr)
        last := len(s) - n
        var h uint32
        for i := len(s) - 1; i &gt;= last; i-- </span><span class="cov0" title="0">{
                h = h*bytealg.PrimeRK + uint32(s[i])
        }</span>
        <span class="cov0" title="0">if h == hashss &amp;&amp; s[last:] == substr </span><span class="cov0" title="0">{
                return last
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">for i := last - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                h *= bytealg.PrimeRK
                h += uint32(s[i])
                h -= pow * uint32(s[i+n])
                if h == hashss &amp;&amp; s[i:i+n] == substr </span><span class="cov0" title="0">{
                        return i
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return -1</span>
}

// IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.
func IndexByte(s string, c byte) int <span class="cov8" title="1">{
        return bytealg.IndexByteString(s, c)
}</span>

// IndexRune returns the index of the first instance of the Unicode code point
// r, or -1 if rune is not present in s.
// If r is utf8.RuneError, it returns the first instance of any
// invalid UTF-8 byte sequence.
func IndexRune(s string, r rune) int <span class="cov0" title="0">{
        switch </span>{
        <span class="cov0" title="0">case 0 &lt;= r &amp;&amp; r &lt; utf8.RuneSelf:
                return IndexByte(s, byte(r))</span>
        <span class="cov0" title="0">case r == utf8.RuneError:
                for i, r := range s </span><span class="cov0" title="0">{
                        if r == utf8.RuneError </span><span class="cov0" title="0">{
                                return i
                        }</span><span class="cov0" title="0">
</span>                }
                <span class="cov0" title="0">return -1</span>
        <span class="cov0" title="0">case !utf8.ValidRune(r):
                return -1</span>
        <span class="cov0" title="0">default:
                return Index(s, string(r))</span>
        }
}

// IndexAny returns the index of the first instance of any Unicode code point
// from chars in s, or -1 if no Unicode code point from chars is present in s.
func IndexAny(s, chars string) int <span class="cov0" title="0">{
        if chars == "" </span><span class="cov0" title="0">{
                // Avoid scanning all of s.
                return -1
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if len(chars) == 1 </span><span class="cov0" title="0">{
                // Avoid scanning all of s.
                r := rune(chars[0])
                if r &gt;= utf8.RuneSelf </span><span class="cov0" title="0">{
                        r = utf8.RuneError
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return IndexRune(s, r)</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if len(s) &gt; 8 </span><span class="cov0" title="0">{
                if as, isASCII := makeASCIISet(chars); isASCII </span><span class="cov0" title="0">{
                        for i := 0; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                                if as.contains(s[i]) </span><span class="cov0" title="0">{
                                        return i
                                }</span><span class="cov0" title="0">
</span>                        }
                        <span class="cov0" title="0">return -1</span>
                }<span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">for i, c := range s </span><span class="cov0" title="0">{
                if IndexRune(chars, c) &gt;= 0 </span><span class="cov0" title="0">{
                        return i
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return -1</span>
}

// LastIndexAny returns the index of the last instance of any Unicode code
// point from chars in s, or -1 if no Unicode code point from chars is
// present in s.
func LastIndexAny(s, chars string) int <span class="cov0" title="0">{
        if chars == "" </span><span class="cov0" title="0">{
                // Avoid scanning all of s.
                return -1
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if len(s) == 1 </span><span class="cov0" title="0">{
                rc := rune(s[0])
                if rc &gt;= utf8.RuneSelf </span><span class="cov0" title="0">{
                        rc = utf8.RuneError
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if IndexRune(chars, rc) &gt;= 0 </span><span class="cov0" title="0">{
                        return 0
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return -1</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if len(s) &gt; 8 </span><span class="cov0" title="0">{
                if as, isASCII := makeASCIISet(chars); isASCII </span><span class="cov0" title="0">{
                        for i := len(s) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                                if as.contains(s[i]) </span><span class="cov0" title="0">{
                                        return i
                                }</span><span class="cov0" title="0">
</span>                        }
                        <span class="cov0" title="0">return -1</span>
                }<span class="cov0" title="0">
</span>        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if len(chars) == 1 </span><span class="cov0" title="0">{
                rc := rune(chars[0])
                if rc &gt;= utf8.RuneSelf </span><span class="cov0" title="0">{
                        rc = utf8.RuneError
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">for i := len(s); i &gt; 0; </span><span class="cov0" title="0">{
                        r, size := utf8.DecodeLastRuneInString(s[:i])
                        i -= size
                        if rc == r </span><span class="cov0" title="0">{
                                return i
                        }</span><span class="cov0" title="0">
</span>                }
                <span class="cov0" title="0">return -1</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">for i := len(s); i &gt; 0; </span><span class="cov0" title="0">{
                r, size := utf8.DecodeLastRuneInString(s[:i])
                i -= size
                if IndexRune(chars, r) &gt;= 0 </span><span class="cov0" title="0">{
                        return i
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return -1</span>
}

// LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.
func LastIndexByte(s string, c byte) int <span class="cov8" title="1">{
        for i := len(s) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if s[i] == c </span><span class="cov8" title="1">{
                        return i
                }</span><span class="cov8" title="1">
</span>        }
        <span class="cov8" title="1">return -1</span>
}

// Generic split: splits after each instance of sep,
// including sepSave bytes of sep in the subarrays.
func genSplit(s, sep string, sepSave, n int) []string <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                return nil
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if sep == "" </span><span class="cov0" title="0">{
                return explode(s, n)
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if n &lt; 0 </span><span class="cov0" title="0">{
                n = Count(s, sep) + 1
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">a := make([]string, n)
        n--
        i := 0
        for i &lt; n </span><span class="cov0" title="0">{
                m := Index(s, sep)
                if m &lt; 0 </span><span class="cov0" title="0">{
                        break</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">a[i] = s[:m+sepSave]
                s = s[m+len(sep):]
                i++</span>
        }
        <span class="cov0" title="0">a[i] = s
        return a[:i+1]</span>
}

// SplitN slices s into substrings separated by sep and returns a slice of
// the substrings between those separators.
//
// The count determines the number of substrings to return:
//   n &gt; 0: at most n substrings; the last substring will be the unsplit remainder.
//   n == 0: the result is nil (zero substrings)
//   n &lt; 0: all substrings
//
// Edge cases for s and sep (for example, empty strings) are handled
// as described in the documentation for Split.
func SplitN(s, sep string, n int) []string <span class="cov0" title="0">{ return genSplit(s, sep, 0, n) }</span>

// SplitAfterN slices s into substrings after each instance of sep and
// returns a slice of those substrings.
//
// The count determines the number of substrings to return:
//   n &gt; 0: at most n substrings; the last substring will be the unsplit remainder.
//   n == 0: the result is nil (zero substrings)
//   n &lt; 0: all substrings
//
// Edge cases for s and sep (for example, empty strings) are handled
// as described in the documentation for SplitAfter.
func SplitAfterN(s, sep string, n int) []string <span class="cov0" title="0">{
        return genSplit(s, sep, len(sep), n)
}</span>

// Split slices s into all substrings separated by sep and returns a slice of
// the substrings between those separators.
//
// If s does not contain sep and sep is not empty, Split returns a
// slice of length 1 whose only element is s.
//
// If sep is empty, Split splits after each UTF-8 sequence. If both s
// and sep are empty, Split returns an empty slice.
//
// It is equivalent to SplitN with a count of -1.
func Split(s, sep string) []string <span class="cov0" title="0">{ return genSplit(s, sep, 0, -1) }</span>

// SplitAfter slices s into all substrings after each instance of sep and
// returns a slice of those substrings.
//
// If s does not contain sep and sep is not empty, SplitAfter returns
// a slice of length 1 whose only element is s.
//
// If sep is empty, SplitAfter splits after each UTF-8 sequence. If
// both s and sep are empty, SplitAfter returns an empty slice.
//
// It is equivalent to SplitAfterN with a count of -1.
func SplitAfter(s, sep string) []string <span class="cov0" title="0">{
        return genSplit(s, sep, len(sep), -1)
}</span>

var asciiSpace = [256]uint8{'\t': 1, '\n': 1, '\v': 1, '\f': 1, '\r': 1, ' ': 1}

// Fields splits the string s around each instance of one or more consecutive white space
// characters, as defined by unicode.IsSpace, returning a slice of substrings of s or an
// empty slice if s contains only white space.
func Fields(s string) []string <span class="cov0" title="0">{
        // First count the fields.
        // This is an exact count if s is ASCII, otherwise it is an approximation.
        n := 0
        wasSpace := 1
        // setBits is used to track which bits are set in the bytes of s.
        setBits := uint8(0)
        for i := 0; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                r := s[i]
                setBits |= r
                isSpace := int(asciiSpace[r])
                n += wasSpace &amp; ^isSpace
                wasSpace = isSpace
        }</span>

        <span class="cov0" title="0">if setBits &gt;= utf8.RuneSelf </span><span class="cov0" title="0">{
                // Some runes in the input string are not ASCII.
                return FieldsFunc(s, unicode.IsSpace)
        }</span><span class="cov8" title="1">
</span>        // ASCII fast path
        <span class="cov0" title="0">a := make([]string, n)
        na := 0
        fieldStart := 0
        i := 0
        // Skip spaces in the front of the input.
        for i &lt; len(s) &amp;&amp; asciiSpace[s[i]] != 0 </span><span class="cov0" title="0">{
                i++
        }</span>
        <span class="cov0" title="0">fieldStart = i
        for i &lt; len(s) </span><span class="cov0" title="0">{
                if asciiSpace[s[i]] == 0 </span><span class="cov0" title="0">{
                        i++
                        continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">a[na] = s[fieldStart:i]
                na++
                i++
                // Skip spaces in between fields.
                for i &lt; len(s) &amp;&amp; asciiSpace[s[i]] != 0 </span><span class="cov0" title="0">{
                        i++
                }</span>
                <span class="cov0" title="0">fieldStart = i</span>
        }
        <span class="cov0" title="0">if fieldStart &lt; len(s) </span><span class="cov0" title="0">{ // Last field might end at EOF.
                a[na] = s[fieldStart:]
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return a</span>
}

// FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c)
// and returns an array of slices of s. If all code points in s satisfy f(c) or the
// string is empty, an empty slice is returned.
//
// FieldsFunc makes no guarantees about the order in which it calls f(c)
// and assumes that f always returns the same value for a given c.
func FieldsFunc(s string, f func(rune) bool) []string <span class="cov0" title="0">{
        // A span is used to record a slice of s of the form s[start:end].
        // The start index is inclusive and the end index is exclusive.
        type span struct {
                start int
                end   int
        }
        spans := make([]span, 0, 32)

        // Find the field start and end indices.
        // Doing this in a separate pass (rather than slicing the string s
        // and collecting the result substrings right away) is significantly
        // more efficient, possibly due to cache effects.
        start := -1 // valid span start if &gt;= 0
        for end, rune := range s </span><span class="cov0" title="0">{
                if f(rune) </span><span class="cov0" title="0">{
                        if start &gt;= 0 </span><span class="cov0" title="0">{
                                spans = append(spans, span{start, end})
                                // Set start to a negative value.
                                // Note: using -1 here consistently and reproducibly
                                // slows down this code by a several percent on amd64.
                                start = ^start
                        }</span><span class="cov0" title="0">
</span>                }<span class="cov0" title="0"> else {
                        if start &lt; 0 </span><span class="cov0" title="0">{
                                start = end
                        }</span><span class="cov0" title="0">
</span>                }
        }

        // Last field might end at EOF.
        <span class="cov0" title="0">if start &gt;= 0 </span><span class="cov0" title="0">{
                spans = append(spans, span{start, len(s)})
        }</span><span class="cov0" title="0">
</span>
        // Create strings from recorded field indices.
        <span class="cov0" title="0">a := make([]string, len(spans))
        for i, span := range spans </span><span class="cov0" title="0">{
                a[i] = s[span.start:span.end]
        }</span>

        <span class="cov0" title="0">return a</span>
}

// Join concatenates the elements of its first argument to create a single string. The separator
// string sep is placed between elements in the resulting string.
func Join(elems []string, sep string) string <span class="cov0" title="0">{
        switch len(elems) </span>{
        <span class="cov0" title="0">case 0:
                return ""</span>
        <span class="cov0" title="0">case 1:
                return elems[0]</span>
        }
        <span class="cov0" title="0">n := len(sep) * (len(elems) - 1)
        for i := 0; i &lt; len(elems); i++ </span><span class="cov0" title="0">{
                n += len(elems[i])
        }</span>

        <span class="cov0" title="0">var b Builder
        b.Grow(n)
        b.WriteString(elems[0])
        for _, s := range elems[1:] </span><span class="cov0" title="0">{
                b.WriteString(sep)
                b.WriteString(s)
        }</span>
        <span class="cov0" title="0">return b.String()</span>
}

// HasPrefix tests whether the string s begins with prefix.
func HasPrefix(s, prefix string) bool <span class="cov8" title="1">{
        return len(s) &gt;= len(prefix) &amp;&amp; s[0:len(prefix)] == prefix
}</span>

// HasSuffix tests whether the string s ends with suffix.
func HasSuffix(s, suffix string) bool <span class="cov8" title="1">{
        return len(s) &gt;= len(suffix) &amp;&amp; s[len(s)-len(suffix):] == suffix
}</span>

// Map returns a copy of the string s with all its characters modified
// according to the mapping function. If mapping returns a negative value, the character is
// dropped from the string with no replacement.
func Map(mapping func(rune) rune, s string) string <span class="cov0" title="0">{
        // In the worst case, the string can grow when mapped, making
        // things unpleasant. But it's so rare we barge in assuming it's
        // fine. It could also shrink but that falls out naturally.

        // The output buffer b is initialized on demand, the first
        // time a character differs.
        var b Builder

        for i, c := range s </span><span class="cov0" title="0">{
                r := mapping(c)
                if r == c &amp;&amp; c != utf8.RuneError </span><span class="cov0" title="0">{
                        continue</span>
                }<span class="cov0" title="0">
</span>
                <span class="cov0" title="0">var width int
                if c == utf8.RuneError </span><span class="cov0" title="0">{
                        c, width = utf8.DecodeRuneInString(s[i:])
                        if width != 1 &amp;&amp; r == c </span><span class="cov0" title="0">{
                                continue</span>
                        }<span class="cov0" title="0">
</span>                }<span class="cov0" title="0"> else {
                        width = utf8.RuneLen(c)
                }</span>

                <span class="cov0" title="0">b.Grow(len(s) + utf8.UTFMax)
                b.WriteString(s[:i])
                if r &gt;= 0 </span><span class="cov0" title="0">{
                        b.WriteRune(r)
                }</span><span class="cov0" title="0">
</span>
                <span class="cov0" title="0">s = s[i+width:]
                break</span>
        }

        // Fast path for unchanged input
        <span class="cov0" title="0">if b.Cap() == 0 </span><span class="cov0" title="0">{ // didn't call b.Grow above
                return s
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">for _, c := range s </span><span class="cov0" title="0">{
                r := mapping(c)

                if r &gt;= 0 </span><span class="cov0" title="0">{
                        // common case
                        // Due to inlining, it is more performant to determine if WriteByte should be
                        // invoked rather than always call WriteRune
                        if r &lt; utf8.RuneSelf </span><span class="cov0" title="0">{
                                b.WriteByte(byte(r))
                        }</span><span class="cov0" title="0"> else {
                                // r is not a ASCII rune.
                                b.WriteRune(r)
                        }</span>
                }<span class="cov0" title="0">
</span>        }

        <span class="cov0" title="0">return b.String()</span>
}

// Repeat returns a new string consisting of count copies of the string s.
//
// It panics if count is negative or if
// the result of (len(s) * count) overflows.
func Repeat(s string, count int) string <span class="cov0" title="0">{
        if count == 0 </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov0" title="0">
</span>
        // Since we cannot return an error on overflow,
        // we should panic if the repeat will generate
        // an overflow.
        // See Issue golang.org/issue/16237
        <span class="cov0" title="0">if count &lt; 0 </span><span class="cov0" title="0">{
                panic("strings: negative Repeat count")</span>
        }<span class="cov0" title="0"> else if len(s)*count/count != len(s) </span><span class="cov0" title="0">{
                panic("strings: Repeat count causes overflow")</span>
        }<span class="cov0" title="0">
</span>
        <span class="cov0" title="0">n := len(s) * count
        var b Builder
        b.Grow(n)
        b.WriteString(s)
        for b.Len() &lt; n </span><span class="cov0" title="0">{
                if b.Len() &lt;= n/2 </span><span class="cov0" title="0">{
                        b.WriteString(b.String())
                }</span><span class="cov0" title="0"> else {
                        b.WriteString(b.String()[:n-b.Len()])
                        break</span>
                }
        }
        <span class="cov0" title="0">return b.String()</span>
}

// ToUpper returns s with all Unicode letters mapped to their upper case.
func ToUpper(s string) string <span class="cov0" title="0">{
        isASCII, hasLower := true, false
        for i := 0; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                c := s[i]
                if c &gt;= utf8.RuneSelf </span><span class="cov0" title="0">{
                        isASCII = false
                        break</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">hasLower = hasLower || ('a' &lt;= c &amp;&amp; c &lt;= 'z')</span>
        }

        <span class="cov0" title="0">if isASCII </span><span class="cov0" title="0">{ // optimize for ASCII-only strings.
                if !hasLower </span><span class="cov0" title="0">{
                        return s
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">var b Builder
                b.Grow(len(s))
                for i := 0; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                        c := s[i]
                        if 'a' &lt;= c &amp;&amp; c &lt;= 'z' </span><span class="cov0" title="0">{
                                c -= 'a' - 'A'
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">b.WriteByte(c)</span>
                }
                <span class="cov0" title="0">return b.String()</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">return Map(unicode.ToUpper, s)</span>
}

// ToLower returns s with all Unicode letters mapped to their lower case.
func ToLower(s string) string <span class="cov8" title="1">{
        isASCII, hasUpper := true, false
        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                c := s[i]
                if c &gt;= utf8.RuneSelf </span><span class="cov0" title="0">{
                        isASCII = false
                        break</span>
                }<span class="cov8" title="1">
</span>                <span class="cov8" title="1">hasUpper = hasUpper || ('A' &lt;= c &amp;&amp; c &lt;= 'Z')</span>
        }

        <span class="cov8" title="1">if isASCII </span><span class="cov8" title="1">{ // optimize for ASCII-only strings.
                if !hasUpper </span><span class="cov8" title="1">{
                        return s
                }</span><span class="cov8" title="1">
</span>                <span class="cov8" title="1">var b Builder
                b.Grow(len(s))
                for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                        c := s[i]
                        if 'A' &lt;= c &amp;&amp; c &lt;= 'Z' </span><span class="cov8" title="1">{
                                c += 'a' - 'A'
                        }</span><span class="cov8" title="1">
</span>                        <span class="cov8" title="1">b.WriteByte(c)</span>
                }
                <span class="cov8" title="1">return b.String()</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">return Map(unicode.ToLower, s)</span>
}

// ToTitle returns a copy of the string s with all Unicode letters mapped to
// their Unicode title case.
func ToTitle(s string) string <span class="cov0" title="0">{ return Map(unicode.ToTitle, s) }</span>

// ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their
// upper case using the case mapping specified by c.
func ToUpperSpecial(c unicode.SpecialCase, s string) string <span class="cov0" title="0">{
        return Map(c.ToUpper, s)
}</span>

// ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their
// lower case using the case mapping specified by c.
func ToLowerSpecial(c unicode.SpecialCase, s string) string <span class="cov0" title="0">{
        return Map(c.ToLower, s)
}</span>

// ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their
// Unicode title case, giving priority to the special casing rules.
func ToTitleSpecial(c unicode.SpecialCase, s string) string <span class="cov0" title="0">{
        return Map(c.ToTitle, s)
}</span>

// ToValidUTF8 returns a copy of the string s with each run of invalid UTF-8 byte sequences
// replaced by the replacement string, which may be empty.
func ToValidUTF8(s, replacement string) string <span class="cov0" title="0">{
        var b Builder

        for i, c := range s </span><span class="cov0" title="0">{
                if c != utf8.RuneError </span><span class="cov0" title="0">{
                        continue</span>
                }<span class="cov0" title="0">
</span>
                <span class="cov0" title="0">_, wid := utf8.DecodeRuneInString(s[i:])
                if wid == 1 </span><span class="cov0" title="0">{
                        b.Grow(len(s) + len(replacement))
                        b.WriteString(s[:i])
                        s = s[i:]
                        break</span>
                }<span class="cov0" title="0">
</span>        }

        // Fast path for unchanged input
        <span class="cov0" title="0">if b.Cap() == 0 </span><span class="cov0" title="0">{ // didn't call b.Grow above
                return s
        }</span><span class="cov0" title="0">
</span>
        <span class="cov0" title="0">invalid := false // previous byte was from an invalid UTF-8 sequence
        for i := 0; i &lt; len(s); </span><span class="cov0" title="0">{
                c := s[i]
                if c &lt; utf8.RuneSelf </span><span class="cov0" title="0">{
                        i++
                        invalid = false
                        b.WriteByte(c)
                        continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">_, wid := utf8.DecodeRuneInString(s[i:])
                if wid == 1 </span><span class="cov0" title="0">{
                        i++
                        if !invalid </span><span class="cov0" title="0">{
                                invalid = true
                                b.WriteString(replacement)
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">invalid = false
                b.WriteString(s[i : i+wid])
                i += wid</span>
        }

        <span class="cov0" title="0">return b.String()</span>
}

// isSeparator reports whether the rune could mark a word boundary.
// TODO: update when package unicode captures more of the properties.
func isSeparator(r rune) bool <span class="cov0" title="0">{
        // ASCII alphanumerics and underscore are not separators
        if r &lt;= 0x7F </span><span class="cov0" title="0">{
                switch </span>{
                <span class="cov0" title="0">case '0' &lt;= r &amp;&amp; r &lt;= '9':
                        return false</span>
                <span class="cov0" title="0">case 'a' &lt;= r &amp;&amp; r &lt;= 'z':
                        return false</span>
                <span class="cov0" title="0">case 'A' &lt;= r &amp;&amp; r &lt;= 'Z':
                        return false</span>
                <span class="cov0" title="0">case r == '_':
                        return false</span>
                }
                <span class="cov0" title="0">return true</span>
        }<span class="cov0" title="0">
</span>        // Letters and digits are not separators
        <span class="cov0" title="0">if unicode.IsLetter(r) || unicode.IsDigit(r) </span><span class="cov0" title="0">{
                return false
        }</span><span class="cov0" title="0">
</span>        // Otherwise, all we can do for now is treat spaces as separators.
        <span class="cov0" title="0">return unicode.IsSpace(r)</span>
}

// Title returns a copy of the string s with all Unicode letters that begin words
// mapped to their Unicode title case.
//
// BUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.
func Title(s string) string <span class="cov0" title="0">{
        // Use a closure here to remember state.
        // Hackish but effective. Depends on Map scanning in order and calling
        // the closure once per rune.
        prev := ' '
        return Map(
                func(r rune) rune </span><span class="cov0" title="0">{
                        if isSeparator(prev) </span><span class="cov0" title="0">{
                                prev = r
                                return unicode.ToTitle(r)
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">prev = r
                        return r</span>
                },
                s)
}

// TrimLeftFunc returns a slice of the string s with all leading
// Unicode code points c satisfying f(c) removed.
func TrimLeftFunc(s string, f func(rune) bool) string <span class="cov0" title="0">{
        i := indexFunc(s, f, false)
        if i == -1 </span><span class="cov0" title="0">{
                return ""
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return s[i:]</span>
}

// TrimRightFunc returns a slice of the string s with all trailing
// Unicode code points c satisfying f(c) removed.
func TrimRightFunc(s string, f func(rune) bool) string <span class="cov0" title="0">{
        i := lastIndexFunc(s, f, false)
        if i &gt;= 0 &amp;&amp; s[i] &gt;= utf8.RuneSelf </span><span class="cov0" title="0">{
                _, wid := utf8.DecodeRuneInString(s[i:])
                i += wid
        }</span><span class="cov0" title="0"> else {
                i++
        }</span>
        <span class="cov0" title="0">return s[0:i]</span>
}

// TrimFunc returns a slice of the string s with all leading
// and trailing Unicode code points c satisfying f(c) removed.
func TrimFunc(s string, f func(rune) bool) string <span class="cov0" title="0">{
        return TrimRightFunc(TrimLeftFunc(s, f), f)
}</span>

// IndexFunc returns the index into s of the first Unicode
// code point satisfying f(c), or -1 if none do.
func IndexFunc(s string, f func(rune) bool) int <span class="cov0" title="0">{
        return indexFunc(s, f, true)
}</span>

// LastIndexFunc returns the index into s of the last
// Unicode code point satisfying f(c), or -1 if none do.
func LastIndexFunc(s string, f func(rune) bool) int <span class="cov0" title="0">{
        return lastIndexFunc(s, f, true)
}</span>

// indexFunc is the same as IndexFunc except that if
// truth==false, the sense of the predicate function is
// inverted.
func indexFunc(s string, f func(rune) bool, truth bool) int <span class="cov0" title="0">{
        for i, r := range s </span><span class="cov0" title="0">{
                if f(r) == truth </span><span class="cov0" title="0">{
                        return i
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return -1</span>
}

// lastIndexFunc is the same as LastIndexFunc except that if
// truth==false, the sense of the predicate function is
// inverted.
func lastIndexFunc(s string, f func(rune) bool, truth bool) int <span class="cov0" title="0">{
        for i := len(s); i &gt; 0; </span><span class="cov0" title="0">{
                r, size := utf8.DecodeLastRuneInString(s[0:i])
                i -= size
                if f(r) == truth </span><span class="cov0" title="0">{
                        return i
                }</span><span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return -1</span>
}

// asciiSet is a 32-byte value, where each bit represents the presence of a
// given ASCII character in the set. The 128-bits of the lower 16 bytes,
// starting with the least-significant bit of the lowest word to the
// most-significant bit of the highest word, map to the full range of all
// 128 ASCII characters. The 128-bits of the upper 16 bytes will be zeroed,
// ensuring that any non-ASCII character will be reported as not in the set.
type asciiSet [8]uint32

// makeASCIISet creates a set of ASCII characters and reports whether all
// characters in chars are ASCII.
func makeASCIISet(chars string) (as asciiSet, ok bool) <span class="cov0" title="0">{
        for i := 0; i &lt; len(chars); i++ </span><span class="cov0" title="0">{
                c := chars[i]
                if c &gt;= utf8.RuneSelf </span><span class="cov0" title="0">{
                        return as, false
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">as[c&gt;&gt;5] |= 1 &lt;&lt; uint(c&amp;31)</span>
        }
        <span class="cov0" title="0">return as, true</span>
}

// contains reports whether c is inside the set.
func (as *asciiSet) contains(c byte) bool <span class="cov0" title="0">{
        return (as[c&gt;&gt;5] &amp; (1 &lt;&lt; uint(c&amp;31))) != 0
}</span>

func makeCutsetFunc(cutset string) func(rune) bool <span class="cov0" title="0">{
        if len(cutset) == 1 &amp;&amp; cutset[0] &lt; utf8.RuneSelf </span><span class="cov0" title="0">{
                return func(r rune) bool </span><span class="cov0" title="0">{
                        return r == rune(cutset[0])
                }</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">if as, isASCII := makeASCIISet(cutset); isASCII </span><span class="cov0" title="0">{
                return func(r rune) bool </span><span class="cov0" title="0">{
                        return r &lt; utf8.RuneSelf &amp;&amp; as.contains(byte(r))
                }</span>
        }<span class="cov0" title="0">
</span>        <span class="cov0" title="0">return func(r rune) bool </span><span class="cov0" title="0">{ return IndexRune(cutset, r) &gt;= 0 }</span>
}

// Trim returns a slice of the string s with all leading and
// trailing Unicode code points contained in cutset removed.
func Trim(s, cutset string) string <span class="cov0" title="0">{
        if s == "" || cutset == "" </span><span class="cov0" title="0">{
                return s
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return TrimFunc(s, makeCutsetFunc(cutset))</span>
}

// TrimLeft returns a slice of the string s with all leading
// Unicode code points contained in cutset removed.
//
// To remove a prefix, use TrimPrefix instead.
func TrimLeft(s, cutset string) string <span class="cov0" title="0">{
        if s == "" || cutset == "" </span><span class="cov0" title="0">{
                return s
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return TrimLeftFunc(s, makeCutsetFunc(cutset))</span>
}

// TrimRight returns a slice of the string s, with all trailing
// Unicode code points contained in cutset removed.
//
// To remove a suffix, use TrimSuffix instead.
func TrimRight(s, cutset string) string <span class="cov0" title="0">{
        if s == "" || cutset == "" </span><span class="cov0" title="0">{
                return s
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return TrimRightFunc(s, makeCutsetFunc(cutset))</span>
}

// TrimSpace returns a slice of the string s, with all leading
// and trailing white space removed, as defined by Unicode.
func TrimSpace(s string) string <span class="cov0" title="0">{
        // Fast path for ASCII: look for the first ASCII non-space byte
        start := 0
        for ; start &lt; len(s); start++ </span><span class="cov0" title="0">{
                c := s[start]
                if c &gt;= utf8.RuneSelf </span><span class="cov0" title="0">{
                        // If we run into a non-ASCII byte, fall back to the
                        // slower unicode-aware method on the remaining bytes
                        return TrimFunc(s[start:], unicode.IsSpace)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if asciiSpace[c] == 0 </span><span class="cov0" title="0">{
                        break</span>
                }<span class="cov0" title="0">
</span>        }

        // Now look for the first ASCII non-space byte from the end
        <span class="cov0" title="0">stop := len(s)
        for ; stop &gt; start; stop-- </span><span class="cov0" title="0">{
                c := s[stop-1]
                if c &gt;= utf8.RuneSelf </span><span class="cov0" title="0">{
                        return TrimFunc(s[start:stop], unicode.IsSpace)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">if asciiSpace[c] == 0 </span><span class="cov0" title="0">{
                        break</span>
                }<span class="cov0" title="0">
</span>        }

        // At this point s[start:stop] starts and ends with an ASCII
        // non-space bytes, so we're done. Non-ASCII cases have already
        // been handled above.
        <span class="cov0" title="0">return s[start:stop]</span>
}

// TrimPrefix returns s without the provided leading prefix string.
// If s doesn't start with prefix, s is returned unchanged.
func TrimPrefix(s, prefix string) string <span class="cov0" title="0">{
        if HasPrefix(s, prefix) </span><span class="cov0" title="0">{
                return s[len(prefix):]
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return s</span>
}

// TrimSuffix returns s without the provided trailing suffix string.
// If s doesn't end with suffix, s is returned unchanged.
func TrimSuffix(s, suffix string) string <span class="cov0" title="0">{
        if HasSuffix(s, suffix) </span><span class="cov0" title="0">{
                return s[:len(s)-len(suffix)]
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return s</span>
}

// Replace returns a copy of the string s with the first n
// non-overlapping instances of old replaced by new.
// If old is empty, it matches at the beginning of the string
// and after each UTF-8 sequence, yielding up to k+1 replacements
// for a k-rune string.
// If n &lt; 0, there is no limit on the number of replacements.
func Replace(s, old, new string, n int) string <span class="cov0" title="0">{
        if old == new || n == 0 </span><span class="cov0" title="0">{
                return s // avoid allocation
        }</span><span class="cov0" title="0">
</span>
        // Compute number of replacements.
        <span class="cov0" title="0">if m := Count(s, old); m == 0 </span><span class="cov0" title="0">{
                return s // avoid allocation
        }</span><span class="cov0" title="0"> else if n &lt; 0 || m &lt; n </span><span class="cov0" title="0">{
                n = m
        }</span><span class="cov0" title="0">
</span>
        // Apply replacements to buffer.
        <span class="cov0" title="0">t := make([]byte, len(s)+n*(len(new)-len(old)))
        w := 0
        start := 0
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                j := start
                if len(old) == 0 </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                _, wid := utf8.DecodeRuneInString(s[start:])
                                j += wid
                        }</span><span class="cov0" title="0">
</span>                }<span class="cov0" title="0"> else {
                        j += Index(s[start:], old)
                }</span>
                <span class="cov0" title="0">w += copy(t[w:], s[start:j])
                w += copy(t[w:], new)
                start = j + len(old)</span>
        }
        <span class="cov0" title="0">w += copy(t[w:], s[start:])
        return string(t[0:w])</span>
}

// ReplaceAll returns a copy of the string s with all
// non-overlapping instances of old replaced by new.
// If old is empty, it matches at the beginning of the string
// and after each UTF-8 sequence, yielding up to k+1 replacements
// for a k-rune string.
func ReplaceAll(s, old, new string) string <span class="cov0" title="0">{
        return Replace(s, old, new, -1)
}</span>

// EqualFold reports whether s and t, interpreted as UTF-8 strings,
// are equal under Unicode case-folding, which is a more general
// form of case-insensitivity.
func EqualFold(s, t string) bool <span class="cov0" title="0">{
        for s != "" &amp;&amp; t != "" </span><span class="cov0" title="0">{
                // Extract first rune from each string.
                var sr, tr rune
                if s[0] &lt; utf8.RuneSelf </span><span class="cov0" title="0">{
                        sr, s = rune(s[0]), s[1:]
                }</span><span class="cov0" title="0"> else {
                        r, size := utf8.DecodeRuneInString(s)
                        sr, s = r, s[size:]
                }</span>
                <span class="cov0" title="0">if t[0] &lt; utf8.RuneSelf </span><span class="cov0" title="0">{
                        tr, t = rune(t[0]), t[1:]
                }</span><span class="cov0" title="0"> else {
                        r, size := utf8.DecodeRuneInString(t)
                        tr, t = r, t[size:]
                }</span>

                // If they match, keep going; if not, return false.

                // Easy case.
                <span class="cov0" title="0">if tr == sr </span><span class="cov0" title="0">{
                        continue</span>
                }<span class="cov0" title="0">
</span>
                // Make sr &lt; tr to simplify what follows.
                <span class="cov0" title="0">if tr &lt; sr </span><span class="cov0" title="0">{
                        tr, sr = sr, tr
                }</span><span class="cov0" title="0">
</span>                // Fast check for ASCII.
                <span class="cov0" title="0">if tr &lt; utf8.RuneSelf </span><span class="cov0" title="0">{
                        // ASCII only, sr/tr must be upper/lower case
                        if 'A' &lt;= sr &amp;&amp; sr &lt;= 'Z' &amp;&amp; tr == sr+'a'-'A' </span><span class="cov0" title="0">{
                                continue</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">return false</span>
                }<span class="cov0" title="0">
</span>
                // General case. SimpleFold(x) returns the next equivalent rune &gt; x
                // or wraps around to smaller values.
                <span class="cov0" title="0">r := unicode.SimpleFold(sr)
                for r != sr &amp;&amp; r &lt; tr </span><span class="cov0" title="0">{
                        r = unicode.SimpleFold(r)
                }</span>
                <span class="cov0" title="0">if r == tr </span><span class="cov0" title="0">{
                        continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">return false</span>
        }

        // One string is empty. Are both?
        <span class="cov0" title="0">return s == t</span>
}

// Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.
func Index(s, substr string) int <span class="cov8" title="1">{
        n := len(substr)
        switch </span>{
        <span class="cov0" title="0">case n == 0:
                return 0</span>
        <span class="cov8" title="1">case n == 1:
                return IndexByte(s, substr[0])</span>
        <span class="cov0" title="0">case n == len(s):
                if substr == s </span><span class="cov0" title="0">{
                        return 0
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">return -1</span>
        <span class="cov0" title="0">case n &gt; len(s):
                return -1</span>
        <span class="cov0" title="0">case n &lt;= bytealg.MaxLen:
                // Use brute force when s and substr both are small
                if len(s) &lt;= bytealg.MaxBruteForce </span><span class="cov0" title="0">{
                        return bytealg.IndexString(s, substr)
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">c0 := substr[0]
                c1 := substr[1]
                i := 0
                t := len(s) - n + 1
                fails := 0
                for i &lt; t </span><span class="cov0" title="0">{
                        if s[i] != c0 </span><span class="cov0" title="0">{
                                // IndexByte is faster than bytealg.IndexString, so use it as long as
                                // we're not getting lots of false positives.
                                o := IndexByte(s[i+1:t], c0)
                                if o &lt; 0 </span><span class="cov0" title="0">{
                                        return -1
                                }</span><span class="cov0" title="0">
</span>                                <span class="cov0" title="0">i += o + 1</span>
                        }<span class="cov0" title="0">
</span>                        <span class="cov0" title="0">if s[i+1] == c1 &amp;&amp; s[i:i+n] == substr </span><span class="cov0" title="0">{
                                return i
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">fails++
                        i++
                        // Switch to bytealg.IndexString when IndexByte produces too many false positives.
                        if fails &gt; bytealg.Cutover(i) </span><span class="cov0" title="0">{
                                r := bytealg.IndexString(s[i:], substr)
                                if r &gt;= 0 </span><span class="cov0" title="0">{
                                        return r + i
                                }</span><span class="cov0" title="0">
</span>                                <span class="cov0" title="0">return -1</span>
                        }<span class="cov0" title="0">
</span>                }
                <span class="cov0" title="0">return -1</span>
        }
        <span class="cov0" title="0">c0 := substr[0]
        c1 := substr[1]
        i := 0
        t := len(s) - n + 1
        fails := 0
        for i &lt; t </span><span class="cov0" title="0">{
                if s[i] != c0 </span><span class="cov0" title="0">{
                        o := IndexByte(s[i+1:t], c0)
                        if o &lt; 0 </span><span class="cov0" title="0">{
                                return -1
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">i += o + 1</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">if s[i+1] == c1 &amp;&amp; s[i:i+n] == substr </span><span class="cov0" title="0">{
                        return i
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">i++
                fails++
                if fails &gt;= 4+i&gt;&gt;4 &amp;&amp; i &lt; t </span><span class="cov0" title="0">{
                        // See comment in ../bytes/bytes.go.
                        j := bytealg.IndexRabinKarp(s[i:], substr)
                        if j &lt; 0 </span><span class="cov0" title="0">{
                                return -1
                        }</span><span class="cov0" title="0">
</span>                        <span class="cov0" title="0">return i + j</span>
                }<span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">return -1</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package utf8 implements functions and constants to support text encoded in
// UTF-8. It includes functions to translate between runes and UTF-8 byte sequences.
// See https://en.wikipedia.org/wiki/UTF-8
package utf8

// The conditions RuneError==unicode.ReplacementChar and
// MaxRune==unicode.MaxRune are verified in the tests.
// Defining them locally avoids this package depending on package unicode.

// Numbers fundamental to the encoding.
const (
        RuneError = '\uFFFD'     // the "error" Rune or "Unicode replacement character"
        RuneSelf  = 0x80         // characters below RuneSelf are represented as themselves in a single byte.
        MaxRune   = '\U0010FFFF' // Maximum valid Unicode code point.
        UTFMax    = 4            // maximum number of bytes of a UTF-8 encoded Unicode character.
)

// Code points in the surrogate range are not valid for UTF-8.
const (
        surrogateMin = 0xD800
        surrogateMax = 0xDFFF
)

const (
        t1 = 0b00000000
        tx = 0b10000000
        t2 = 0b11000000
        t3 = 0b11100000
        t4 = 0b11110000
        t5 = 0b11111000

        maskx = 0b00111111
        mask2 = 0b00011111
        mask3 = 0b00001111
        mask4 = 0b00000111

        rune1Max = 1&lt;&lt;7 - 1
        rune2Max = 1&lt;&lt;11 - 1
        rune3Max = 1&lt;&lt;16 - 1

        // The default lowest and highest continuation byte.
        locb = 0b10000000
        hicb = 0b10111111

        // These names of these constants are chosen to give nice alignment in the
        // table below. The first nibble is an index into acceptRanges or F for
        // special one-byte cases. The second nibble is the Rune length or the
        // Status for the special one-byte case.
        xx = 0xF1 // invalid: size 1
        as = 0xF0 // ASCII: size 1
        s1 = 0x02 // accept 0, size 2
        s2 = 0x13 // accept 1, size 3
        s3 = 0x03 // accept 0, size 3
        s4 = 0x23 // accept 2, size 3
        s5 = 0x34 // accept 3, size 4
        s6 = 0x04 // accept 0, size 4
        s7 = 0x44 // accept 4, size 4
)

// first is information about the first byte in a UTF-8 sequence.
var first = [256]uint8{
        //   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
        as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x00-0x0F
        as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x10-0x1F
        as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x20-0x2F
        as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x30-0x3F
        as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x40-0x4F
        as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x50-0x5F
        as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x60-0x6F
        as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x70-0x7F
        //   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
        xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x80-0x8F
        xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x90-0x9F
        xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xA0-0xAF
        xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xB0-0xBF
        xx, xx, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xC0-0xCF
        s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xD0-0xDF
        s2, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s4, s3, s3, // 0xE0-0xEF
        s5, s6, s6, s6, s7, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xF0-0xFF
}

// acceptRange gives the range of valid values for the second byte in a UTF-8
// sequence.
type acceptRange struct {
        lo uint8 // lowest value for second byte.
        hi uint8 // highest value for second byte.
}

// acceptRanges has size 16 to avoid bounds checks in the code that uses it.
var acceptRanges = [16]acceptRange{
        0: {locb, hicb},
        1: {0xA0, hicb},
        2: {locb, 0x9F},
        3: {0x90, hicb},
        4: {locb, 0x8F},
}

// FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune.
// An invalid encoding is considered a full Rune since it will convert as a width-1 error rune.
func FullRune(p []byte) bool <span class="cov0" title="0">{
        n := len(p)
        if n == 0 </span><span class="cov0" title="0">{
                return false
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">x := first[p[0]]
        if n &gt;= int(x&amp;7) </span><span class="cov0" title="0">{
                return true // ASCII, invalid or valid.
        }</span><span class="cov0" title="0">
</span>        // Must be short or invalid.
        <span class="cov0" title="0">accept := acceptRanges[x&gt;&gt;4]
        if n &gt; 1 &amp;&amp; (p[1] &lt; accept.lo || accept.hi &lt; p[1]) </span><span class="cov0" title="0">{
                return true
        }</span><span class="cov0" title="0"> else if n &gt; 2 &amp;&amp; (p[2] &lt; locb || hicb &lt; p[2]) </span><span class="cov0" title="0">{
                return true
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return false</span>
}

// FullRuneInString is like FullRune but its input is a string.
func FullRuneInString(s string) bool <span class="cov0" title="0">{
        n := len(s)
        if n == 0 </span><span class="cov0" title="0">{
                return false
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">x := first[s[0]]
        if n &gt;= int(x&amp;7) </span><span class="cov0" title="0">{
                return true // ASCII, invalid, or valid.
        }</span><span class="cov0" title="0">
</span>        // Must be short or invalid.
        <span class="cov0" title="0">accept := acceptRanges[x&gt;&gt;4]
        if n &gt; 1 &amp;&amp; (s[1] &lt; accept.lo || accept.hi &lt; s[1]) </span><span class="cov0" title="0">{
                return true
        }</span><span class="cov0" title="0"> else if n &gt; 2 &amp;&amp; (s[2] &lt; locb || hicb &lt; s[2]) </span><span class="cov0" title="0">{
                return true
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return false</span>
}

// DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and
// its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if
// the encoding is invalid, it returns (RuneError, 1). Both are impossible
// results for correct, non-empty UTF-8.
//
// An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
// out of range, or is not the shortest possible UTF-8 encoding for the
// value. No other validation is performed.
func DecodeRune(p []byte) (r rune, size int) <span class="cov0" title="0">{
        n := len(p)
        if n &lt; 1 </span><span class="cov0" title="0">{
                return RuneError, 0
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">p0 := p[0]
        x := first[p0]
        if x &gt;= as </span><span class="cov0" title="0">{
                // The following code simulates an additional check for x == xx and
                // handling the ASCII and invalid cases accordingly. This mask-and-or
                // approach prevents an additional branch.
                mask := rune(x) &lt;&lt; 31 &gt;&gt; 31 // Create 0x0000 or 0xFFFF.
                return rune(p[0])&amp;^mask | RuneError&amp;mask, 1
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">sz := int(x &amp; 7)
        accept := acceptRanges[x&gt;&gt;4]
        if n &lt; sz </span><span class="cov0" title="0">{
                return RuneError, 1
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">b1 := p[1]
        if b1 &lt; accept.lo || accept.hi &lt; b1 </span><span class="cov0" title="0">{
                return RuneError, 1
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if sz &lt;= 2 </span><span class="cov0" title="0">{ // &lt;= instead of == to help the compiler eliminate some bounds checks
                return rune(p0&amp;mask2)&lt;&lt;6 | rune(b1&amp;maskx), 2
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">b2 := p[2]
        if b2 &lt; locb || hicb &lt; b2 </span><span class="cov0" title="0">{
                return RuneError, 1
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">if sz &lt;= 3 </span><span class="cov0" title="0">{
                return rune(p0&amp;mask3)&lt;&lt;12 | rune(b1&amp;maskx)&lt;&lt;6 | rune(b2&amp;maskx), 3
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">b3 := p[3]
        if b3 &lt; locb || hicb &lt; b3 </span><span class="cov0" title="0">{
                return RuneError, 1
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return rune(p0&amp;mask4)&lt;&lt;18 | rune(b1&amp;maskx)&lt;&lt;12 | rune(b2&amp;maskx)&lt;&lt;6 | rune(b3&amp;maskx), 4</span>
}

// DecodeRuneInString is like DecodeRune but its input is a string. If s is
// empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it
// returns (RuneError, 1). Both are impossible results for correct, non-empty
// UTF-8.
//
// An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
// out of range, or is not the shortest possible UTF-8 encoding for the
// value. No other validation is performed.
func DecodeRuneInString(s string) (r rune, size int) <span class="cov8" title="1">{
        n := len(s)
        if n &lt; 1 </span><span class="cov0" title="0">{
                return RuneError, 0
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">s0 := s[0]
        x := first[s0]
        if x &gt;= as </span><span class="cov8" title="1">{
                // The following code simulates an additional check for x == xx and
                // handling the ASCII and invalid cases accordingly. This mask-and-or
                // approach prevents an additional branch.
                mask := rune(x) &lt;&lt; 31 &gt;&gt; 31 // Create 0x0000 or 0xFFFF.
                return rune(s[0])&amp;^mask | RuneError&amp;mask, 1
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">sz := int(x &amp; 7)
        accept := acceptRanges[x&gt;&gt;4]
        if n &lt; sz </span><span class="cov8" title="1">{
                return RuneError, 1
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">s1 := s[1]
        if s1 &lt; accept.lo || accept.hi &lt; s1 </span><span class="cov8" title="1">{
                return RuneError, 1
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">if sz &lt;= 2 </span><span class="cov0" title="0">{ // &lt;= instead of == to help the compiler eliminate some bounds checks
                return rune(s0&amp;mask2)&lt;&lt;6 | rune(s1&amp;maskx), 2
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">s2 := s[2]
        if s2 &lt; locb || hicb &lt; s2 </span><span class="cov8" title="1">{
                return RuneError, 1
        }</span><span class="cov8" title="1">
</span>        <span class="cov8" title="1">if sz &lt;= 3 </span><span class="cov8" title="1">{
                return rune(s0&amp;mask3)&lt;&lt;12 | rune(s1&amp;maskx)&lt;&lt;6 | rune(s2&amp;maskx), 3
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">s3 := s[3]
        if s3 &lt; locb || hicb &lt; s3 </span><span class="cov0" title="0">{
                return RuneError, 1
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return rune(s0&amp;mask4)&lt;&lt;18 | rune(s1&amp;maskx)&lt;&lt;12 | rune(s2&amp;maskx)&lt;&lt;6 | rune(s3&amp;maskx), 4</span>
}

// DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and
// its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if
// the encoding is invalid, it returns (RuneError, 1). Both are impossible
// results for correct, non-empty UTF-8.
//
// An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
// out of range, or is not the shortest possible UTF-8 encoding for the
// value. No other validation is performed.
func DecodeLastRune(p []byte) (r rune, size int) <span class="cov0" title="0">{
        end := len(p)
        if end == 0 </span><span class="cov0" title="0">{
                return RuneError, 0
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">start := end - 1
        r = rune(p[start])
        if r &lt; RuneSelf </span><span class="cov0" title="0">{
                return r, 1
        }</span><span class="cov0" title="0">
</span>        // guard against O(n^2) behavior when traversing
        // backwards through strings with long sequences of
        // invalid UTF-8.
        <span class="cov0" title="0">lim := end - UTFMax
        if lim &lt; 0 </span><span class="cov0" title="0">{
                lim = 0
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">for start--; start &gt;= lim; start-- </span><span class="cov0" title="0">{
                if RuneStart(p[start]) </span><span class="cov0" title="0">{
                        break</span>
                }<span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">if start &lt; 0 </span><span class="cov0" title="0">{
                start = 0
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">r, size = DecodeRune(p[start:end])
        if start+size != end </span><span class="cov0" title="0">{
                return RuneError, 1
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return r, size</span>
}

// DecodeLastRuneInString is like DecodeLastRune but its input is a string. If
// s is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid,
// it returns (RuneError, 1). Both are impossible results for correct,
// non-empty UTF-8.
//
// An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
// out of range, or is not the shortest possible UTF-8 encoding for the
// value. No other validation is performed.
func DecodeLastRuneInString(s string) (r rune, size int) <span class="cov0" title="0">{
        end := len(s)
        if end == 0 </span><span class="cov0" title="0">{
                return RuneError, 0
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">start := end - 1
        r = rune(s[start])
        if r &lt; RuneSelf </span><span class="cov0" title="0">{
                return r, 1
        }</span><span class="cov0" title="0">
</span>        // guard against O(n^2) behavior when traversing
        // backwards through strings with long sequences of
        // invalid UTF-8.
        <span class="cov0" title="0">lim := end - UTFMax
        if lim &lt; 0 </span><span class="cov0" title="0">{
                lim = 0
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">for start--; start &gt;= lim; start-- </span><span class="cov0" title="0">{
                if RuneStart(s[start]) </span><span class="cov0" title="0">{
                        break</span>
                }<span class="cov0" title="0">
</span>        }
        <span class="cov0" title="0">if start &lt; 0 </span><span class="cov8" title="1">{
                start = 0
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">r, size = DecodeRuneInString(s[start:end])
        if start+size != end </span><span class="cov0" title="0">{
                return RuneError, 1
        }</span><span class="cov0" title="0">
</span>        <span class="cov0" title="0">return r, size</span>
}

// RuneLen returns the number of bytes required to encode the rune.
// It returns -1 if the rune is not a valid value to encode in UTF-8.
func RuneLen(r rune) int <span class="cov0" title="0">{
        switch </span>{
        <span class="cov0" title="0">case r &lt; 0:
                return -1</span>
        <span class="cov0" title="0">case r &lt;= rune1Max:
                return 1</span>
        <span class="cov0" title="0">case r &lt;= rune2Max:
                return 2</span>
        <span class="cov0" title="0">case surrogateMin &lt;= r &amp;&amp; r &lt;= surrogateMax:
                return -1</span>
        <span class="cov0" title="0">case r &lt;= rune3Max:
                return 3</span>
        <span class="cov0" title="0">case r &lt;= MaxRune:
                return 4</span>
        }
        <span class="cov0" title="0">return -1</span>
}

// EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.
// It returns the number of bytes written.
func EncodeRune(p []byte, r rune) int <span class="cov8" title="1">{
        // Negative values are erroneous. Making it unsigned addresses the problem.
        switch i := uint32(r); </span>{
        <span class="cov8" title="1">case i &lt;= rune1Max:
                p[0] = byte(r)
                return 1</span>
        <span class="cov0" title="0">case i &lt;= rune2Max:
                _ = p[1] // eliminate bounds checks
                p[0] = t2 | byte(r&gt;&gt;6)
                p[1] = tx | byte(r)&amp;maskx
                return 2</span>
        <span class="cov0" title="0">case i &gt; MaxRune, surrogateMin &lt;= i &amp;&amp; i &lt;= surrogateMax:
                r = RuneError
                fallthrough</span>
        <span class="cov8" title="1">case i &lt;= rune3Max:
                _ = p[2] // eliminate bounds checks
                p[0] = t3 | byte(r&gt;&gt;12)
                p[1] = tx | byte(r&gt;&gt;6)&amp;maskx
                p[2] = tx | byte(r)&amp;maskx
                return 3</span>
        <span class="cov0" title="0">default:
                _ = p[3] // eliminate bounds checks
                p[0] = t4 | byte(r&gt;&gt;18)
                p[1] = tx | byte(r&gt;&gt;12)&amp;maskx
                p[2] = tx | byte(r&gt;&gt;6)&amp;maskx
                p[3] = tx | byte(r)&amp;maskx
                return 4</span>
        }
}

// RuneCount returns the number of runes in p. Erroneous and short
// encodings are treated as single runes of width 1 byte.
func RuneCount(p []byte) int <span class="cov0" title="0">{
        np := len(p)
        var n int
        for i := 0; i &lt; np; </span><span class="cov0" title="0">{
                n++
                c := p[i]
                if c &lt; RuneSelf </span><span class="cov0" title="0">{
                        // ASCII fast path
                        i++
                        continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">x := first[c]
                if x == xx </span><span class="cov0" title="0">{
                        i++ // invalid.
                        continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">size := int(x &amp; 7)
                if i+size &gt; np </span><span class="cov0" title="0">{
                        i++ // Short or invalid.
                        continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">accept := acceptRanges[x&gt;&gt;4]
                if c := p[i+1]; c &lt; accept.lo || accept.hi &lt; c </span><span class="cov0" title="0">{
                        size = 1
                }</span><span class="cov0" title="0"> else if size == 2 </span><span class="cov0" title="0">{
                }</span><span class="cov0" title="0"> else if c := p[i+2]; c &lt; locb || hicb &lt; c </span><span class="cov0" title="0">{
                        size = 1
                }</span><span class="cov0" title="0"> else if size == 3 </span><span class="cov0" title="0">{
                }</span><span class="cov0" title="0"> else if c := p[i+3]; c &lt; locb || hicb &lt; c </span><span class="cov0" title="0">{
                        size = 1
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">i += size</span>
        }
        <span class="cov0" title="0">return n</span>
}

// RuneCountInString is like RuneCount but its input is a string.
func RuneCountInString(s string) (n int) <span class="cov0" title="0">{
        ns := len(s)
        for i := 0; i &lt; ns; n++ </span><span class="cov0" title="0">{
                c := s[i]
                if c &lt; RuneSelf </span><span class="cov0" title="0">{
                        // ASCII fast path
                        i++
                        continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov8" title="1">x := first[c]
                if x == xx </span><span class="cov0" title="0">{
                        i++ // invalid.
                        continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">size := int(x &amp; 7)
                if i+size &gt; ns </span><span class="cov0" title="0">{
                        i++ // Short or invalid.
                        continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">accept := acceptRanges[x&gt;&gt;4]
                if c := s[i+1]; c &lt; accept.lo || accept.hi &lt; c </span><span class="cov0" title="0">{
                        size = 1
                }</span><span class="cov0" title="0"> else if size == 2 </span><span class="cov0" title="0">{
                }</span><span class="cov0" title="0"> else if c := s[i+2]; c &lt; locb || hicb &lt; c </span><span class="cov0" title="0">{
                        size = 1
                }</span><span class="cov0" title="0"> else if size == 3 </span><span class="cov0" title="0">{
                }</span><span class="cov0" title="0"> else if c := s[i+3]; c &lt; locb || hicb &lt; c </span><span class="cov0" title="0">{
                        size = 1
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">i += size</span>
        }
        <span class="cov0" title="0">return n</span>
}

// RuneStart reports whether the byte could be the first byte of an encoded,
// possibly invalid rune. Second and subsequent bytes always have the top two
// bits set to 10.
func RuneStart(b byte) bool <span class="cov0" title="0">{ return b&amp;0xC0 != 0x80 }</span>

// Valid reports whether p consists entirely of valid UTF-8-encoded runes.
func Valid(p []byte) bool <span class="cov0" title="0">{
        // Fast path. Check for and skip 8 bytes of ASCII characters per iteration.
        for len(p) &gt;= 8 </span><span class="cov0" title="0">{
                // Combining two 32 bit loads allows the same code to be used
                // for 32 and 64 bit platforms.
                // The compiler can generate a 32bit load for first32 and second32
                // on many platforms. See test/codegen/memcombine.go.
                first32 := uint32(p[0]) | uint32(p[1])&lt;&lt;8 | uint32(p[2])&lt;&lt;16 | uint32(p[3])&lt;&lt;24
                second32 := uint32(p[4]) | uint32(p[5])&lt;&lt;8 | uint32(p[6])&lt;&lt;16 | uint32(p[7])&lt;&lt;24
                if (first32|second32)&amp;0x80808080 != 0 </span><span class="cov0" title="0">{
                        // Found a non ASCII byte (&gt;= RuneSelf).
                        break</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">p = p[8:]</span>
        }
        <span class="cov0" title="0">n := len(p)
        for i := 0; i &lt; n; </span><span class="cov0" title="0">{
                pi := p[i]
                if pi &lt; RuneSelf </span><span class="cov0" title="0">{
                        i++
                        continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">x := first[pi]
                if x == xx </span><span class="cov0" title="0">{
                        return false // Illegal starter byte.
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">size := int(x &amp; 7)
                if i+size &gt; n </span><span class="cov0" title="0">{
                        return false // Short or invalid.
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">accept := acceptRanges[x&gt;&gt;4]
                if c := p[i+1]; c &lt; accept.lo || accept.hi &lt; c </span><span class="cov0" title="0">{
                        return false
                }</span><span class="cov0" title="0"> else if size == 2 </span><span class="cov0" title="0">{
                }</span><span class="cov0" title="0"> else if c := p[i+2]; c &lt; locb || hicb &lt; c </span><span class="cov0" title="0">{
                        return false
                }</span><span class="cov8" title="1"> else if size == 3 </span><span class="cov0" title="0">{
                }</span><span class="cov0" title="0"> else if c := p[i+3]; c &lt; locb || hicb &lt; c </span><span class="cov0" title="0">{
                        return false
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">i += size</span>
        }
        <span class="cov0" title="0">return true</span>
}

// ValidString reports whether s consists entirely of valid UTF-8-encoded runes.
func ValidString(s string) bool <span class="cov0" title="0">{
        // Fast path. Check for and skip 8 bytes of ASCII characters per iteration.
        for len(s) &gt;= 8 </span><span class="cov0" title="0">{
                // Combining two 32 bit loads allows the same code to be used
                // for 32 and 64 bit platforms.
                // The compiler can generate a 32bit load for first32 and second32
                // on many platforms. See test/codegen/memcombine.go.
                first32 := uint32(s[0]) | uint32(s[1])&lt;&lt;8 | uint32(s[2])&lt;&lt;16 | uint32(s[3])&lt;&lt;24
                second32 := uint32(s[4]) | uint32(s[5])&lt;&lt;8 | uint32(s[6])&lt;&lt;16 | uint32(s[7])&lt;&lt;24
                if (first32|second32)&amp;0x80808080 != 0 </span><span class="cov0" title="0">{
                        // Found a non ASCII byte (&gt;= RuneSelf).
                        break</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">s = s[8:]</span>
        }
        <span class="cov0" title="0">n := len(s)
        for i := 0; i &lt; n; </span><span class="cov0" title="0">{
                si := s[i]
                if si &lt; RuneSelf </span><span class="cov0" title="0">{
                        i++
                        continue</span>
                }<span class="cov0" title="0">
</span>                <span class="cov0" title="0">x := first[si]
                if x == xx </span><span class="cov0" title="0">{
                        return false // Illegal starter byte.
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">size := int(x &amp; 7)
                if i+size &gt; n </span><span class="cov0" title="0">{
                        return false // Short or invalid.
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">accept := acceptRanges[x&gt;&gt;4]
                if c := s[i+1]; c &lt; accept.lo || accept.hi &lt; c </span><span class="cov0" title="0">{
                        return false
                }</span><span class="cov0" title="0"> else if size == 2 </span><span class="cov0" title="0">{
                }</span><span class="cov0" title="0"> else if c := s[i+2]; c &lt; locb || hicb &lt; c </span><span class="cov0" title="0">{
                        return false
                }</span><span class="cov0" title="0"> else if size == 3 </span><span class="cov0" title="0">{
                }</span><span class="cov0" title="0"> else if c := s[i+3]; c &lt; locb || hicb &lt; c </span><span class="cov0" title="0">{
                        return false
                }</span><span class="cov0" title="0">
</span>                <span class="cov0" title="0">i += size</span>
        }
        <span class="cov0" title="0">return true</span>
}

// ValidRune reports whether r can be legally encoded as UTF-8.
// Code points that are out of range or a surrogate half are illegal.
func ValidRune(r rune) bool <span class="cov0" title="0">{
        switch </span>{
        <span class="cov0" title="0">case 0 &lt;= r &amp;&amp; r &lt; surrogateMin:
                return true</span>
        <span class="cov0" title="0">case surrogateMax &lt; r &amp;&amp; r &lt;= MaxRune:
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
