---
title: "CVE-2017-15042"
date: 2017-10-07T14:46:09+01:00
---

# I Went Looking For A [STARTTLS](https://en.wikipedia.org/wiki/Opportunistic_TLS) Bug

I've been putting together a cryptography course for my colleagues which focuses on _mistakes_. Its working title is _Cryptography Done Wrong_ which should give you an idea of the tone. There's a wealth of examples of systems assembled from sound cryptographic components which end up with security issues (for some definition of secure).

Over the years, [TLS](https://en.wikipedia.org/wiki/Transport_Layer_Security) has been an excellent source of examples for such a course. I'm not talking about [heartbleed](heartbleed.com), [CRIME](https://en.wikipedia.org/wiki/CRIME) and all that; I'm talking about mistakes made _using TLS_.

It's very common for developers with only a passing familiarity with TLS to focus primarily on the encryption of the data stream and neglect how the identity of the remote party is established. When the identity of the other party is not established a [man-in-the-middle (MITM)](https://en.wikipedia.org/wiki/Man-in-the-middle_attack) can intercept and modify traffic and the victims will have no idea. Think about how many potential attackers there are: the wifi access point in Starbucks, your ISP, your friendly three-letter-agencies etc. If you haven't already, I suggest reading [_The Most Dangerous Code in the World_](http://crypto.stanford.edu/~dabo/pubs/abstracts/ssl-client-bugs.html) to see just how many big names have gotten this very wrong.  If you're a poor soul working with OpenSSL, I suggest taking a look at the [SSL conservatory project](https://github.com/iSECPartners/ssl-conservatory) for practical advice.

As if to make things more error prone, some protocols ([SMTP](https://www.limilabs.com/blog/ssl-vs-tls-vs-starttls-stls), [XMPP](https://tools.ietf.org/html/rfc6120#section-5), postgresql) were retrofitted with TLS support using STARTTLS so that the same port could be used for legacy plaintext communication and TLS. Having worked in the field of [_unified communications_](https://www.acano.com/) where XMPP was a big deal, I've seen my fair share of STARTTLS related security vulnerabilities. Could I find some new ones on a rainy Saturday afternoon?

# STARTTLS bugs

To STARTTLS, the client and server negotiate in plaintext with a variation on the following:

**Client: "Hey server, how's it going?"**

**Server: "Not bad, client"**

**Server: "Hey client, I support TLS! Do you?"**

**Client: "Yes"**

**Server: "Cool! Let's do TLS"**

**Client: "Ok"**

There is no mechanism to establish the identity of either party or the authenticity of the received messages. Therefore, a MITM can modify this conversation so it appears to the client that the server doesn't support TLS e.g. the client see this:

**Client: "Hey server, how's it going?"**

**Server: "Not bad, client"**

**Server: "Hey client, I don't support TLS"**

**Client: "Ok"**

The client will proceed to communicate in plaintext revealing sensitive data, credentials etc.

When using STARTTLS or other _opportunistic encryption_ schemes it's important that the client can specify a policy which says how to behave if TLS is not negotiated. Your web browser will warn you if there's something wrong with the TLS negotiation with a website and may offer you a chance to proceed at your own risk: you'd expect no less from an email or chat client.


# The Trawl

I work mostly in golang these days so I decided to focus on opensource golang libraries. I picked SMTP, XMPP and postgres wire protocol as targets for investigation.

I looked at some golang SMTP packages and decided quickly that they all boiled down to [net/smtp](https://golang.org/pkg/net/smtp/).

**I wasn't optimistic that I'd find any issues and there's probably a lesson there.**

The function [SendMail](https://golang.org/src/net/smtp/smtp.go?s=8958:9036#L296) was immediately fishy because it has no means to pass in a policy or callback to decide what to do when TLS negotiation fails. A quick read of the code (it's a very easy read like much of golang's standard library) confirmed that the default was to roll on if TLS was not negotiated.

I read the code over and over for about 30 minutes with a vaguely paranoid feeling that I must be wrong. So I parked it and went on the hunt for more bugs and almost immediately found another, though not in something as well-known as golang's standard library. That bug will have to wait for another post. I guess it helps to have a focus for a code review and having many possible targets. Starting off with a single code base looking for _any_ security bug is probably a lot harder than looking for one type of security bug in all public repos on github for a given language.

# Reporting Process

Go has an easy to follow process for reporting security vulnerabilities: https://golang.org/security. Here's how it worked in practice:

* I reported the issue at 11:09 AM GMT on Tuesday 3rd October 2017 via email to security@golang.org
* I received a response at 2:29 AM GMT the following day from Russ Cox (rsc@google.com) confirming the issue and spelling out the timeline for dealing with the issue.
* Over the course of the next 24 hours or so I was informed of the actions which would be taken and given a link to a [patch](https://go-review.googlesource.com/c/go/+/68170) _so I had a chance to comment_
* 1.9.1 and 1.8.4 were released on Oct 4th 2017 addressing the capture of PLAIN credentials
* I was asked if I wanted [credit](https://github.com/golang/go/issues/22134) and since I'm human I said "yes, please"

I was pleasantly surprised by the quick turnaround and the fact that I was kept in the loop. The golang team decided to solve the issues in two stages:

1. in the security point release: disallow PLAIN credentials on non-TLS connections
2. acknowledge the general weakness in a public issue https://github.com/golang/go/issues/22145 and aim to fix in 1.10

As someone who has run a PSIRT (Product Security Incident Response Team) I appreciate the professionalism shown here. They are following the important parts of [ISO 29417](http://standards.iso.org/ittf/PubliclyAvailableStandards/c045170_ISO_IEC_29147_2014.zip).

# Lessons Learned

* No codebase is above suspicion no matter how nice
* Hunting for one type of bug in a large number of projects can yield results quickly
* STARTLS is easy to get wrong
* golang has a mature security vulnerability reporting mechanism





