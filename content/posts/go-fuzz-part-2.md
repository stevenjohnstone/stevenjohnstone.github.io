---
title: "Gofuzz Part 2: Strings"
date: 2021-02-12T13:21:22Z
draft: false
categories:
    - fuzzing
---

In this post, I'll [continue](/posts/go-fuzz-without-the-hyphen) going into far too much detail about how *[NewFromGoFuzz](https://pkg.go.dev/github.com/google/gofuzz#NewFromGoFuzz)* in [gofuzz](https://github.com/google/gofuzz)
doesn't play nicely with [go-fuzz](https://github.com/dvyukov/go-fuzz) (note the hyphen).

## Strings

> It's important to state right up front that a string holds arbitrary bytes. It is not required to hold Unicode text, UTF-8 text, or any other predefined format. As far as the content of a string is concerned, it is exactly equivalent to a slice of bytes.
<https://blog.golang.org/strings>

When fuzzing a function which accepts strings (or objects containing strings),
it's a good idea to try strings which are not well-formed UTF-8.

Strings generated by gofuzz are restricted to well-formed UTF-8 with zero to 19 (inclusive) runes.

```golang
// randString of UnicodeRange makes a random string up to 20 characters long.
// Each character is selected form ur(UnicodeRange).
func (ur UnicodeRange) randString(r *rand.Rand) string {
    n := r.Intn(20)
    sb := strings.Builder{}
    sb.Grow(n)
    for i := 0; i < n; i++ {
        sb.WriteRune(ur.choose(r))
    }
    return sb.String()
}
```

[reference](https://github.com/google/gofuzz/blob/2083bd8c37e7e627ec31e1eea8adcd9ff456fc81/fuzz.go#L550)

Reading the *randString* function, we see that there will be the
following reads from the data provided by go-fuzz:

* r.Intn(20) requires at least eight bytes
* ur.choose(r) calls r.Int63n(), which requires eight bytes

In total, at least n*8 + 1 bytes will be used of the data from go-fuzz
to construct a string. None of the data will survive as
recognisable fragments.
For example,

```golang
package main

import (
    "fmt"

    fuzz "github.com/google/gofuzz"
)

func main() {
    data := []byte("-----BEGIN RSA PRIVATE KEY-----")
    var str string
    fuzz.NewFromGoFuzz(data).Fuzz(&str)
    fmt.Printf("str = %s\n", str)
}
```

outputs

```
str = Ȱ#ǻŐ蒉
```

This renders go-fuzz's sonar, literal and versifier functionality
ineffective. When fuzzing a function with go-fuzz, string comparisons are reported back to go-fuzz by
the sonar. Either side of the comparison can be used as a starting
point for new mutational fuzzing. To be useful, the structure
of the string needs to be preserved but gofuzz slices and dices
the string to feed a random number generator, choose a string length and then choose offsets into an array of unicode characters.

## Experiment

I maintain a [repository](https://github.com/stevenjohnstone/toughfuzzer) which demonstrates how go-fuzz can navigate
"obstacles" in code. Here's an example fuzzer demonstrating how
the sonar can detect string comparisons so as to intelligently
choose fuzzing inputs:

```golang
  
package sonar

const leet = "1337 string abcdefg"

func reverse(s string) string {
    r := make([]rune, len(s))
    for i, c := range s {
        r[len(s)-1-i] = c
    }
    return string(r)
}

func findString(s, t string) {
    if s == reverse(t) {
        panic("found string")
     }
}

// FuzzString challenges the fuzzer to find a simple string which is reversed
func FuzzString(data []byte) int {
    // note that if we swap the arguments of findString,
    // sonar will not help us find a matching string
    findString(string(data), leet)
    return 0
}
```

On my laptop, go-fuzz can discover the input "gfedcba gnirts 7331" in about 6 seconds. Let's see what happens if we build
the string *NewFromGoFuzz*:

```golang
package sonar

import fuzz "github.com/google/gofuzz"

const leet = "1337 string abcdefg"

func reverse(s string) string {
    r := make([]rune, len(s))
    for i, c := range s {
        r[len(s)-1-i] = c
    }
    return string(r)
}

func findString(s, t string) {
    if s == reverse(t) {
        panic("found string")
     }
}

// FuzzString challenges the fuzzer to find a simple string which is reversed
func FuzzString(data []byte) int {
    var str string
    // note that if we swap the arguments of findString,
    // sonar will not help us find a matching string
    fuzz.NewFromGoFuzz(data).Fuzz(&str)
    findString(str, leet)
    return 0
}
```

After an hour on my laptop, no crashers.

## Conclusion

Gofuzz generates strings which are

* limited in length
* well-formed UTF-8
* do not resemble inputs

It's probably not a good idea to use gofuzz to generate objects
from go-fuzz inputs if those object have string elements.

> Note: I'm not saying that gofuzz on its own doesn't work. I'm saying that it's not suited to transforming data provided by a mutational fuzzer into objects
